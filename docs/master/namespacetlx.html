<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Thrill: tlx Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Thrill
   &#160;<span id="projectnumber">0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacetlx.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">tlx Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetlx_1_1detail"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1AllocatorBase.html">AllocatorBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1CmdlineParser.html">CmdlineParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command line parser which automatically fills variables and prints nice usage messages.  <a href="classtlx_1_1CmdlineParser.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1CountingPtr.html">CountingPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">High-performance smart pointer used as a wrapping reference counting pointer.  <a href="classtlx_1_1CountingPtr.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1CountingPtrDefaultDeleter.html">CountingPtrDefaultDeleter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">default deleter for <a class="el" href="classtlx_1_1CountingPtr.html" title="High-performance smart pointer used as a wrapping reference counting pointer. ">CountingPtr</a>  <a href="classtlx_1_1CountingPtrDefaultDeleter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1CountingPtrNoOperationDeleter.html">CountingPtrNoOperationDeleter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">dummy deleter for <a class="el" href="classtlx_1_1CountingPtr.html" title="High-performance smart pointer used as a wrapping reference counting pointer. ">CountingPtr</a>  <a href="classtlx_1_1CountingPtrNoOperationDeleter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate.html">Delegate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html">Delegate&lt; R(A...), Allocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a faster replacement than std::function.  <a href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1FunctionChain.html">FunctionChain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classtlx_1_1FunctionChain.html" title="A FunctionChain is a chain of functors that can be folded to a single functors. ">FunctionChain</a> is a chain of functors that can be folded to a single functors.  <a href="classtlx_1_1FunctionChain.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1FunctionStack.html">FunctionStack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classtlx_1_1FunctionStack.html" title="A FunctionStack is a chain of functor that can be folded to a single functor (which is usually optimi...">FunctionStack</a> is a chain of functor that can be folded to a single functor (which is usually optimize by the compiler).  <a href="classtlx_1_1FunctionStack.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1index__sequence.html">index_sequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1is__std__array.html">is_std_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">test if is std::array&lt;T, N&gt;  <a href="structtlx_1_1is__std__array.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1is__std__array_3_01std_1_1array_3_01T_00_01N_01_4_01_4.html">is_std_array&lt; std::array&lt; T, N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1is__std__pair.html">is_std_pair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">test if is a std::pair&lt;...&gt;  <a href="structtlx_1_1is__std__pair.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1is__std__pair_3_01std_1_1pair_3_01S_00_01T_01_4_01_4.html">is_std_pair&lt; std::pair&lt; S, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1is__std__tuple.html">is_std_tuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">test if is a std::tuple&lt;...&gt;  <a href="structtlx_1_1is__std__tuple.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1is__std__tuple_3_01std_1_1tuple_3_01Ts_8_8_8_4_01_4.html">is_std_tuple&lt; std::tuple&lt; Ts...&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1is__std__vector.html">is_std_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">test if is std::vector&lt;T&gt;  <a href="structtlx_1_1is__std__vector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1is__std__vector_3_01std_1_1vector_3_01T_01_4_01_4.html">is_std_vector&lt; std::vector&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Log2.html">Log2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Log2_3_010_01_4.html">Log2&lt; 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Log2_3_011_01_4.html">Log2&lt; 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Log2Floor.html">Log2Floor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Log2Floor_3_010_01_4.html">Log2Floor&lt; 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Log2Floor_3_011_01_4.html">Log2Floor&lt; 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Logger.html">Logger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">LOG and sLOG for development and debugging.  <a href="classtlx_1_1Logger.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoggerVoidify.html">LoggerVoidify</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoserTreeCopy.html">LoserTreeCopy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarded loser tree/tournament tree, either copying the whole element into the tree structure, or looking up the element via the index.  <a href="classtlx_1_1LoserTreeCopy.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoserTreeCopy_3_01true_00_01ValueType_00_01Comparator_01_4.html">LoserTreeCopy&lt; true, ValueType, Comparator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarded loser tree/tournament tree, either copying the whole element into the tree structure, or looking up the element via the index.  <a href="classtlx_1_1LoserTreeCopy_3_01true_00_01ValueType_00_01Comparator_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoserTreeCopyBase.html">LoserTreeCopyBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarded loser tree/tournament tree, either copying the whole element into the tree structure, or looking up the element via the index.  <a href="classtlx_1_1LoserTreeCopyBase.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoserTreeCopyUnguarded.html">LoserTreeCopyUnguarded</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoserTreeCopyUnguarded_3_01true_00_01ValueType_00_01Comparator_01_4.html">LoserTreeCopyUnguarded&lt; true, ValueType, Comparator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoserTreeCopyUnguardedBase.html">LoserTreeCopyUnguardedBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unguarded loser tree, copying the whole element into the tree structure.  <a href="classtlx_1_1LoserTreeCopyUnguardedBase.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoserTreePointer.html">LoserTreePointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarded loser tree, using pointers to the elements instead of copying them into the tree nodes.  <a href="classtlx_1_1LoserTreePointer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoserTreePointer_3_01true_00_01ValueType_00_01Comparator_01_4.html">LoserTreePointer&lt; true, ValueType, Comparator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarded loser tree, using pointers to the elements instead of copying them into the tree nodes.  <a href="classtlx_1_1LoserTreePointer_3_01true_00_01ValueType_00_01Comparator_01_4.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoserTreePointerBase.html">LoserTreePointerBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarded loser tree, using pointers to the elements instead of copying them into the tree nodes.  <a href="classtlx_1_1LoserTreePointerBase.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoserTreePointerUnguarded.html">LoserTreePointerUnguarded</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoserTreePointerUnguarded_3_01true_00_01ValueType_00_01Comparator_01_4.html">LoserTreePointerUnguarded&lt; true, ValueType, Comparator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoserTreePointerUnguardedBase.html">LoserTreePointerUnguardedBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unguarded loser tree, keeping only pointers to the elements in the tree structure.  <a href="classtlx_1_1LoserTreePointerUnguardedBase.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoserTreeSwitch.html">LoserTreeSwitch</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LruCacheMap.html">LruCacheMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an expected O(1) LRU cache which contains a map of (key -&gt; value) elements.  <a href="classtlx_1_1LruCacheMap.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LruCacheSet.html">LruCacheSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an expected O(1) LRU cache which contains a set of key-only elements.  <a href="classtlx_1_1LruCacheSet.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1make__index__sequence.html">make_index_sequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1ReferenceCounter.html">ReferenceCounter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides reference counting abilities for use with <a class="el" href="classtlx_1_1CountingPtr.html" title="High-performance smart pointer used as a wrapping reference counting pointer. ">CountingPtr</a>.  <a href="classtlx_1_1ReferenceCounter.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1RingBuffer.html">RingBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A ring (circular) buffer of static (non-growing) size.  <a href="classtlx_1_1RingBuffer.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1SimpleVector.html">SimpleVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simpler non-growing vector without initialization.  <a href="classtlx_1_1SimpleVector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1SpacingLogger.html">SpacingLogger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A logging class which outputs spaces between elements pushed via operator&lt;&lt;.  <a href="classtlx_1_1SpacingLogger.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1StackAllocator.html">StackAllocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1StackArena.html">StackArena</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage area allocated on the stack and usable by a <a class="el" href="classtlx_1_1StackAllocator.html">StackAllocator</a>.  <a href="classtlx_1_1StackArena.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1StaticIndex.html">StaticIndex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1ThreadPool.html">ThreadPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtlx_1_1ThreadPool.html" title="ThreadPool starts a fixed number p of std::threads which process Jobs that are enqueued into a concur...">ThreadPool</a> starts a fixed number p of std::threads which process Jobs that are <a class="el" href="classtlx_1_1ThreadPool.html#ac0197b1301f4bec0f2421cfe41e9435a">enqueued</a> into a concurrent job queue.  <a href="classtlx_1_1ThreadPool.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a2c4e023d82bca2172da2f965e3b42b40"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a2c4e023d82bca2172da2f965e3b42b40"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a2c4e023d82bca2172da2f965e3b42b40">counting_ptr</a> = <a class="el" href="classtlx_1_1CountingPtr.html">CountingPtr</a>&lt; Type &gt;</td></tr>
<tr class="memdesc:a2c4e023d82bca2172da2f965e3b42b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">make alias due to similarity with std::shared_ptr&lt;T&gt;  <a href="#a2c4e023d82bca2172da2f965e3b42b40">More...</a><br/></td></tr>
<tr class="separator:a2c4e023d82bca2172da2f965e3b42b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d28f4e50fa9fc359c658b0911ce06b8"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a9d28f4e50fa9fc359c658b0911ce06b8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a9d28f4e50fa9fc359c658b0911ce06b8">CountingPtrNoDelete</a> = <a class="el" href="classtlx_1_1CountingPtr.html">CountingPtr</a>&lt; Type, <a class="el" href="classtlx_1_1CountingPtrNoOperationDeleter.html">CountingPtrNoOperationDeleter</a> &gt;</td></tr>
<tr class="memdesc:a9d28f4e50fa9fc359c658b0911ce06b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">make alias for dummy deleter  <a href="#a9d28f4e50fa9fc359c658b0911ce06b8">More...</a><br/></td></tr>
<tr class="separator:a9d28f4e50fa9fc359c658b0911ce06b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afacc9643f535d390fd0ead73790a6d56"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Allocator  = std::allocator&lt;void&gt;&gt; </td></tr>
<tr class="memitem:afacc9643f535d390fd0ead73790a6d56"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#afacc9643f535d390fd0ead73790a6d56">delegate</a> = <a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&lt; <a class="el" href="logistic__regression_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a>, Allocator &gt;</td></tr>
<tr class="memdesc:afacc9643f535d390fd0ead73790a6d56"><td class="mdescLeft">&#160;</td><td class="mdescRight">make template alias due to similarity with std::function  <a href="#afacc9643f535d390fd0ead73790a6d56">More...</a><br/></td></tr>
<tr class="separator:afacc9643f535d390fd0ead73790a6d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a89ad01492580f7cf07d93a99539cf5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a4a89ad01492580f7cf07d93a99539cf5">reference_counter</a> = <a class="el" href="classtlx_1_1ReferenceCounter.html">ReferenceCounter</a></td></tr>
<tr class="memdesc:a4a89ad01492580f7cf07d93a99539cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">make alias due to <a class="el" href="classtlx_1_1CountingPtr.html" title="High-performance smart pointer used as a wrapping reference counting pointer. ">CountingPtr</a>'s similarity with std::shared_ptr&lt;T&gt;  <a href="#a4a89ad01492580f7cf07d93a99539cf5">More...</a><br/></td></tr>
<tr class="separator:a4a89ad01492580f7cf07d93a99539cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4843a6aed555573a98892469fee27b0b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4843a6aed555573a98892469fee27b0b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__data__structures.html#ga4843a6aed555573a98892469fee27b0b">simple_vector</a> = <a class="el" href="classtlx_1_1SimpleVector.html">SimpleVector</a>&lt; <a class="el" href="logistic__regression_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;</td></tr>
<tr class="memdesc:ga4843a6aed555573a98892469fee27b0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">make template alias due to similarity with std::vector  <a href="group__tlx__data__structures.html#ga4843a6aed555573a98892469fee27b0b">More...</a><br/></td></tr>
<tr class="separator:ga4843a6aed555573a98892469fee27b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga07f67904ca9d31961dc022100101c358"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__data__structures.html#ga07f67904ca9d31961dc022100101c358">SimpleVectorMode</a> { <a class="el" href="group__tlx__data__structures.html#gga07f67904ca9d31961dc022100101c358a960b44c579bc2f6818d2daaf9e4c16f0">Normal</a>, 
<a class="el" href="group__tlx__data__structures.html#gga07f67904ca9d31961dc022100101c358a96726bf24e630d03d0f4e5715e9fd097">NoInitButDestroy</a>, 
<a class="el" href="group__tlx__data__structures.html#gga07f67904ca9d31961dc022100101c358a60008b87abd54104caffab5779ea7244">NoInitNoDestroy</a>
 }</td></tr>
<tr class="memdesc:ga07f67904ca9d31961dc022100101c358"><td class="mdescLeft">&#160;</td><td class="mdescRight">enum class to select SimpleVector object initialization  <a href="group__tlx__data__structures.html#ga07f67904ca9d31961dc022100101c358">More...</a><br/></td></tr>
<tr class="separator:ga07f67904ca9d31961dc022100101c358"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga72ac8fb39736ae5d2b8d920b17d815a8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga72ac8fb39736ae5d2b8d920b17d815a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="logistic__regression_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga72ac8fb39736ae5d2b8d920b17d815a8">abs_diff</a> (const <a class="el" href="logistic__regression_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &amp;a, const <a class="el" href="logistic__regression_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &amp;b)</td></tr>
<tr class="memdesc:ga72ac8fb39736ae5d2b8d920b17d815a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">absolute difference, which also works for unsigned types  <a href="group__tlx__math.html#ga72ac8fb39736ae5d2b8d920b17d815a8">More...</a><br/></td></tr>
<tr class="separator:ga72ac8fb39736ae5d2b8d920b17d815a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga697505eebc05040893022611ce8866c1"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename Tuple &gt; </td></tr>
<tr class="memitem:ga697505eebc05040893022611ce8866c1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__meta.html#ga697505eebc05040893022611ce8866c1">apply_tuple</a> (Functor &amp;&amp;f, Tuple &amp;&amp;t)</td></tr>
<tr class="memdesc:ga697505eebc05040893022611ce8866c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the functor f with the contents of t as arguments.  <a href="group__tlx__meta.html#ga697505eebc05040893022611ce8866c1">More...</a><br/></td></tr>
<tr class="separator:ga697505eebc05040893022611ce8866c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabdeef74e74806d7a81fa708ce9828e2"><td class="memTemplParams" colspan="2">template&lt;size_t Size, typename Functor &gt; </td></tr>
<tr class="memitem:gaabdeef74e74806d7a81fa708ce9828e2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__meta.html#gaabdeef74e74806d7a81fa708ce9828e2">call_for_range</a> (Functor &amp;&amp;f)</td></tr>
<tr class="memdesc:gaabdeef74e74806d7a81fa708ce9828e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a generic functor (like a generic lambda) for the integers [0,Size).  <a href="group__tlx__meta.html#gaabdeef74e74806d7a81fa708ce9828e2">More...</a><br/></td></tr>
<tr class="separator:gaabdeef74e74806d7a81fa708ce9828e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2abdae3c630ff66ff635822c14f8c72a"><td class="memTemplParams" colspan="2">template&lt;size_t Begin, size_t End, typename Functor &gt; </td></tr>
<tr class="memitem:ga2abdae3c630ff66ff635822c14f8c72a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__meta.html#ga2abdae3c630ff66ff635822c14f8c72a">call_for_range</a> (Functor &amp;&amp;f)</td></tr>
<tr class="memdesc:ga2abdae3c630ff66ff635822c14f8c72a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a generic functor (like a generic lambda) for the integers [Begin,End).  <a href="group__tlx__meta.html#ga2abdae3c630ff66ff635822c14f8c72a">More...</a><br/></td></tr>
<tr class="separator:ga2abdae3c630ff66ff635822c14f8c72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga754cf6d5c1cb28e539cbc996af91ecb5"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:ga754cf6d5c1cb28e539cbc996af91ecb5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__meta.html#ga754cf6d5c1cb28e539cbc996af91ecb5">call_foreach</a> (Functor &amp;&amp;f, Args &amp;&amp;...args)</td></tr>
<tr class="separator:ga754cf6d5c1cb28e539cbc996af91ecb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga592749f0b74d1c116893d4bc880343e3"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename Tuple &gt; </td></tr>
<tr class="memitem:ga592749f0b74d1c116893d4bc880343e3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__meta.html#ga592749f0b74d1c116893d4bc880343e3">call_foreach_tuple</a> (Functor &amp;&amp;f, Tuple &amp;&amp;t)</td></tr>
<tr class="separator:ga592749f0b74d1c116893d4bc880343e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83551ec4ad5da9352345f7178abeb056"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename Tuple &gt; </td></tr>
<tr class="memitem:ga83551ec4ad5da9352345f7178abeb056"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__meta.html#ga83551ec4ad5da9352345f7178abeb056">call_foreach_tuple_with_index</a> (Functor &amp;&amp;f, Tuple &amp;&amp;t)</td></tr>
<tr class="separator:ga83551ec4ad5da9352345f7178abeb056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a8854506459ec185c2bcbdd6fe6428b"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:ga9a8854506459ec185c2bcbdd6fe6428b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__meta.html#ga9a8854506459ec185c2bcbdd6fe6428b">call_foreach_with_index</a> (Functor &amp;&amp;f, Args &amp;&amp;...args)</td></tr>
<tr class="separator:ga9a8854506459ec185c2bcbdd6fe6428b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8eebbd26ffd74bb652bdd95bbdf9cff8"><td class="memTemplParams" colspan="2">template&lt;typename Integral &gt; </td></tr>
<tr class="memitem:ga8eebbd26ffd74bb652bdd95bbdf9cff8"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga8eebbd26ffd74bb652bdd95bbdf9cff8">clz</a> (Integral x)</td></tr>
<tr class="separator:ga8eebbd26ffd74bb652bdd95bbdf9cff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09a565e9d3208a46ec2418f3f4af4aec"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ga09a565e9d3208a46ec2418f3f4af4aec"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga09a565e9d3208a46ec2418f3f4af4aec">clz&lt; int &gt;</a> (int i)</td></tr>
<tr class="memdesc:ga09a565e9d3208a46ec2418f3f4af4aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">clz (count leading zeros)  <a href="group__tlx__math.html#ga09a565e9d3208a46ec2418f3f4af4aec">More...</a><br/></td></tr>
<tr class="separator:ga09a565e9d3208a46ec2418f3f4af4aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad963f1305c675db55d4a68c48907ea50"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:gad963f1305c675db55d4a68c48907ea50"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gad963f1305c675db55d4a68c48907ea50">clz&lt; long &gt;</a> (long i)</td></tr>
<tr class="memdesc:gad963f1305c675db55d4a68c48907ea50"><td class="mdescLeft">&#160;</td><td class="mdescRight">clz (count leading zeros)  <a href="group__tlx__math.html#gad963f1305c675db55d4a68c48907ea50">More...</a><br/></td></tr>
<tr class="separator:gad963f1305c675db55d4a68c48907ea50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f1b8534c59b728f99770d9e5fa6f1b1"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ga3f1b8534c59b728f99770d9e5fa6f1b1"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga3f1b8534c59b728f99770d9e5fa6f1b1">clz&lt; long long &gt;</a> (long long i)</td></tr>
<tr class="memdesc:ga3f1b8534c59b728f99770d9e5fa6f1b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">clz (count leading zeros)  <a href="group__tlx__math.html#ga3f1b8534c59b728f99770d9e5fa6f1b1">More...</a><br/></td></tr>
<tr class="separator:ga3f1b8534c59b728f99770d9e5fa6f1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5660978ea3eb7cde5437104e38998cb"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:gaa5660978ea3eb7cde5437104e38998cb"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gaa5660978ea3eb7cde5437104e38998cb">clz&lt; unsigned &gt;</a> (unsigned i)</td></tr>
<tr class="memdesc:gaa5660978ea3eb7cde5437104e38998cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">clz (count leading zeros)  <a href="group__tlx__math.html#gaa5660978ea3eb7cde5437104e38998cb">More...</a><br/></td></tr>
<tr class="separator:gaa5660978ea3eb7cde5437104e38998cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12d5012490e9a781255746b9bfa1973c"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ga12d5012490e9a781255746b9bfa1973c"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga12d5012490e9a781255746b9bfa1973c">clz&lt; unsigned long &gt;</a> (unsigned long i)</td></tr>
<tr class="memdesc:ga12d5012490e9a781255746b9bfa1973c"><td class="mdescLeft">&#160;</td><td class="mdescRight">clz (count leading zeros)  <a href="group__tlx__math.html#ga12d5012490e9a781255746b9bfa1973c">More...</a><br/></td></tr>
<tr class="separator:ga12d5012490e9a781255746b9bfa1973c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5238dcacef0a9e044c65271a676f940a"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ga5238dcacef0a9e044c65271a676f940a"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga5238dcacef0a9e044c65271a676f940a">clz&lt; unsigned long long &gt;</a> (unsigned long long i)</td></tr>
<tr class="memdesc:ga5238dcacef0a9e044c65271a676f940a"><td class="mdescLeft">&#160;</td><td class="mdescRight">clz (count leading zeros)  <a href="group__tlx__math.html#ga5238dcacef0a9e044c65271a676f940a">More...</a><br/></td></tr>
<tr class="separator:ga5238dcacef0a9e044c65271a676f940a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1fdecdbd0923a67672014032e079f16"><td class="memTemplParams" colspan="2">template&lt;typename Integral &gt; </td></tr>
<tr class="memitem:gaf1fdecdbd0923a67672014032e079f16"><td class="memTemplItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gaf1fdecdbd0923a67672014032e079f16">clz_template</a> (Integral x)</td></tr>
<tr class="memdesc:gaf1fdecdbd0923a67672014032e079f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">clz (count leading zeros) - generic implementation  <a href="group__tlx__math.html#gaf1fdecdbd0923a67672014032e079f16">More...</a><br/></td></tr>
<tr class="separator:gaf1fdecdbd0923a67672014032e079f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a87b7f6120ebcde0c01ad293465f9d7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga7a87b7f6120ebcde0c01ad293465f9d7">compare_icase</a> (const char *a, const char *b)</td></tr>
<tr class="memdesc:ga7a87b7f6120ebcde0c01ad293465f9d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns +1/0/-1 like strcmp(a, b) but without regard for letter case  <a href="group__tlx__string.html#ga7a87b7f6120ebcde0c01ad293465f9d7">More...</a><br/></td></tr>
<tr class="separator:ga7a87b7f6120ebcde0c01ad293465f9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga061e7b66eb332d7621ef99d11b724c16"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga061e7b66eb332d7621ef99d11b724c16">compare_icase</a> (const char *a, const std::string &amp;b)</td></tr>
<tr class="memdesc:ga061e7b66eb332d7621ef99d11b724c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns +1/0/-1 like strcmp(a, b) but without regard for letter case  <a href="group__tlx__string.html#ga061e7b66eb332d7621ef99d11b724c16">More...</a><br/></td></tr>
<tr class="separator:ga061e7b66eb332d7621ef99d11b724c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6b99f43a01b6d2ff8ca49f4518297b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gad6b99f43a01b6d2ff8ca49f4518297b9">compare_icase</a> (const std::string &amp;a, const char *b)</td></tr>
<tr class="memdesc:gad6b99f43a01b6d2ff8ca49f4518297b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns +1/0/-1 like strcmp(a, b) but without regard for letter case  <a href="group__tlx__string.html#gad6b99f43a01b6d2ff8ca49f4518297b9">More...</a><br/></td></tr>
<tr class="separator:gad6b99f43a01b6d2ff8ca49f4518297b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga988bb20efc727413da0a9d9d11f488b0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga988bb20efc727413da0a9d9d11f488b0">compare_icase</a> (const std::string &amp;a, const std::string &amp;b)</td></tr>
<tr class="memdesc:ga988bb20efc727413da0a9d9d11f488b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns +1/0/-1 like strcmp(a, b) but without regard for letter case  <a href="group__tlx__string.html#ga988bb20efc727413da0a9d9d11f488b0">More...</a><br/></td></tr>
<tr class="separator:ga988bb20efc727413da0a9d9d11f488b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ff92619b9a2ae3dbbdd6ef511c1779e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga7ff92619b9a2ae3dbbdd6ef511c1779e">contains</a> (const std::string &amp;str, const std::string &amp;pattern)</td></tr>
<tr class="memdesc:ga7ff92619b9a2ae3dbbdd6ef511c1779e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests of string contains pattern.  <a href="group__tlx__string.html#ga7ff92619b9a2ae3dbbdd6ef511c1779e">More...</a><br/></td></tr>
<tr class="separator:ga7ff92619b9a2ae3dbbdd6ef511c1779e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga399719274798a8a808e8e309ab490f03"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga399719274798a8a808e8e309ab490f03">contains</a> (const std::string &amp;str, const char *pattern)</td></tr>
<tr class="memdesc:ga399719274798a8a808e8e309ab490f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests of string contains pattern.  <a href="group__tlx__string.html#ga399719274798a8a808e8e309ab490f03">More...</a><br/></td></tr>
<tr class="separator:ga399719274798a8a808e8e309ab490f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d6aca56ee9463cd116fc8e065c4c3a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga8d6aca56ee9463cd116fc8e065c4c3a0">contains</a> (const std::string &amp;str, const char ch)</td></tr>
<tr class="memdesc:ga8d6aca56ee9463cd116fc8e065c4c3a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests of string contains character.  <a href="group__tlx__string.html#ga8d6aca56ee9463cd116fc8e065c4c3a0">More...</a><br/></td></tr>
<tr class="separator:ga8d6aca56ee9463cd116fc8e065c4c3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fd07edea7502e13dbc9d2991be95f02"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga2fd07edea7502e13dbc9d2991be95f02">contains_word</a> (const std::string &amp;str, const char *word)</td></tr>
<tr class="memdesc:ga2fd07edea7502e13dbc9d2991be95f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the given string for a whitespace-delimited word.  <a href="group__tlx__string.html#ga2fd07edea7502e13dbc9d2991be95f02">More...</a><br/></td></tr>
<tr class="separator:ga2fd07edea7502e13dbc9d2991be95f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f7b2444597941650e05c1bb96b04f45"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga7f7b2444597941650e05c1bb96b04f45">contains_word</a> (const std::string &amp;str, const std::string &amp;word)</td></tr>
<tr class="memdesc:ga7f7b2444597941650e05c1bb96b04f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the given string for a whitespace-delimited word.  <a href="group__tlx__string.html#ga7f7b2444597941650e05c1bb96b04f45">More...</a><br/></td></tr>
<tr class="separator:ga7f7b2444597941650e05c1bb96b04f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8179e15f255f7283de043a22560c25"><td class="memTemplParams" colspan="2">template&lt;typename TypeA , typename TypeB &gt; </td></tr>
<tr class="memitem:a9f8179e15f255f7283de043a22560c25"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a9f8179e15f255f7283de043a22560c25">die_equal_compare</a> (TypeA a, TypeB b)</td></tr>
<tr class="memdesc:a9f8179e15f255f7283de043a22560c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper method to compare two values in <a class="el" href="die_8hpp.html#a334b021076c0dff0e3964c6819774ceb">die_unequal()</a>  <a href="#a9f8179e15f255f7283de043a22560c25">More...</a><br/></td></tr>
<tr class="separator:a9f8179e15f255f7283de043a22560c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac37c2fc10d396b6a0038eb2d643d1360"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ac37c2fc10d396b6a0038eb2d643d1360"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ac37c2fc10d396b6a0038eb2d643d1360">die_equal_compare</a> (const char *a, const char *b)</td></tr>
<tr class="separator:ac37c2fc10d396b6a0038eb2d643d1360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6834365ccbbe0995d597d91cb16ac05c"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a6834365ccbbe0995d597d91cb16ac05c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a6834365ccbbe0995d597d91cb16ac05c">die_equal_compare</a> (float a, float b)</td></tr>
<tr class="separator:a6834365ccbbe0995d597d91cb16ac05c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac215c9815621e2ebbc07da9be07a622f"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ac215c9815621e2ebbc07da9be07a622f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ac215c9815621e2ebbc07da9be07a622f">die_equal_compare</a> (double a, double b)</td></tr>
<tr class="separator:ac215c9815621e2ebbc07da9be07a622f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4f198a88970a7cb1f5d8d3a0555b79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a1a4f198a88970a7cb1f5d8d3a0555b79">die_with_message</a> (const std::string &amp;msg)</td></tr>
<tr class="memdesc:a1a4f198a88970a7cb1f5d8d3a0555b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">die with message - either throw an exception or die via abort()  <a href="#a1a4f198a88970a7cb1f5d8d3a0555b79">More...</a><br/></td></tr>
<tr class="separator:a1a4f198a88970a7cb1f5d8d3a0555b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1972bdbc5b9ff146cf88d18ec9a12d64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a1972bdbc5b9ff146cf88d18ec9a12d64">die_with_message</a> (const char *msg, const char *file, size_t line)</td></tr>
<tr class="memdesc:a1972bdbc5b9ff146cf88d18ec9a12d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">die with message - either throw an exception or die via abort()  <a href="#a1972bdbc5b9ff146cf88d18ec9a12d64">More...</a><br/></td></tr>
<tr class="separator:a1972bdbc5b9ff146cf88d18ec9a12d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7bff2d67e5ed89bd9dc6bea904e1c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#acf7bff2d67e5ed89bd9dc6bea904e1c1">die_with_message</a> (const std::string &amp;msg, const char *file, size_t line)</td></tr>
<tr class="memdesc:acf7bff2d67e5ed89bd9dc6bea904e1c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">die with message - either throw an exception or die via abort()  <a href="#acf7bff2d67e5ed89bd9dc6bea904e1c1">More...</a><br/></td></tr>
<tr class="separator:acf7bff2d67e5ed89bd9dc6bea904e1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa901da3e5d75f6e1891f470b1382562e"><td class="memTemplParams" colspan="2">template&lt;typename IntegralN , typename IntegralK &gt; </td></tr>
<tr class="memitem:gaa901da3e5d75f6e1891f470b1382562e"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gaa901da3e5d75f6e1891f470b1382562e">div_ceil</a> (const IntegralN &amp;n, const IntegralK &amp;k) -&gt; decltype(n+k)</td></tr>
<tr class="memdesc:gaa901da3e5d75f6e1891f470b1382562e"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate n div k with rounding up  <a href="group__tlx__math.html#gaa901da3e5d75f6e1891f470b1382562e">More...</a><br/></td></tr>
<tr class="separator:gaa901da3e5d75f6e1891f470b1382562e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6eadd6e031f051ff44c5ab2935cdddfd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga6eadd6e031f051ff44c5ab2935cdddfd">ends_with</a> (const std::string &amp;str, const std::string &amp;match)</td></tr>
<tr class="memdesc:ga6eadd6e031f051ff44c5ab2935cdddfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the end of this string.  <a href="group__tlx__string.html#ga6eadd6e031f051ff44c5ab2935cdddfd">More...</a><br/></td></tr>
<tr class="separator:ga6eadd6e031f051ff44c5ab2935cdddfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacea7b710bca17bae104e7e5eb6137fcf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gacea7b710bca17bae104e7e5eb6137fcf">ends_with</a> (const std::string &amp;str, const char *match)</td></tr>
<tr class="memdesc:gacea7b710bca17bae104e7e5eb6137fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the end of this string.  <a href="group__tlx__string.html#gacea7b710bca17bae104e7e5eb6137fcf">More...</a><br/></td></tr>
<tr class="separator:gacea7b710bca17bae104e7e5eb6137fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga849ffa2f657372a30b5cfc53fe1267a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga849ffa2f657372a30b5cfc53fe1267a1">ends_with_icase</a> (const std::string &amp;str, const std::string &amp;match)</td></tr>
<tr class="memdesc:ga849ffa2f657372a30b5cfc53fe1267a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the end of this string.  <a href="group__tlx__string.html#ga849ffa2f657372a30b5cfc53fe1267a1">More...</a><br/></td></tr>
<tr class="separator:ga849ffa2f657372a30b5cfc53fe1267a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7e29572ead3f33c45cd95c8d4b720d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gac7e29572ead3f33c45cd95c8d4b720d0">ends_with_icase</a> (const std::string &amp;str, const char *match)</td></tr>
<tr class="memdesc:gac7e29572ead3f33c45cd95c8d4b720d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the end of this string.  <a href="group__tlx__string.html#gac7e29572ead3f33c45cd95c8d4b720d0">More...</a><br/></td></tr>
<tr class="separator:gac7e29572ead3f33c45cd95c8d4b720d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42a4d6e9f12943be811bcb6666d53493"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga42a4d6e9f12943be811bcb6666d53493">equal_icase</a> (const char *a, const char *b)</td></tr>
<tr class="memdesc:ga42a4d6e9f12943be811bcb6666d53493"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a == b without regard for letter case  <a href="group__tlx__string.html#ga42a4d6e9f12943be811bcb6666d53493">More...</a><br/></td></tr>
<tr class="separator:ga42a4d6e9f12943be811bcb6666d53493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad15c6b082515414b93a34b7ac0327df9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gad15c6b082515414b93a34b7ac0327df9">equal_icase</a> (const char *a, const std::string &amp;b)</td></tr>
<tr class="memdesc:gad15c6b082515414b93a34b7ac0327df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a == b without regard for letter case  <a href="group__tlx__string.html#gad15c6b082515414b93a34b7ac0327df9">More...</a><br/></td></tr>
<tr class="separator:gad15c6b082515414b93a34b7ac0327df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga118abe0d4d0cd1d90426121b626aeea9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga118abe0d4d0cd1d90426121b626aeea9">equal_icase</a> (const std::string &amp;a, const char *b)</td></tr>
<tr class="memdesc:ga118abe0d4d0cd1d90426121b626aeea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a == b without regard for letter case  <a href="group__tlx__string.html#ga118abe0d4d0cd1d90426121b626aeea9">More...</a><br/></td></tr>
<tr class="separator:ga118abe0d4d0cd1d90426121b626aeea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c9c153df7b49712108276c9a48fe88e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga2c9c153df7b49712108276c9a48fe88e">equal_icase</a> (const std::string &amp;a, const std::string &amp;b)</td></tr>
<tr class="memdesc:ga2c9c153df7b49712108276c9a48fe88e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a == b without regard for letter case  <a href="group__tlx__string.html#ga2c9c153df7b49712108276c9a48fe88e">More...</a><br/></td></tr>
<tr class="separator:ga2c9c153df7b49712108276c9a48fe88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga593df4d923a5f07d65ff39950e31e367"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga593df4d923a5f07d65ff39950e31e367">erase_all</a> (std::string *str, char drop= ' ')</td></tr>
<tr class="memdesc:ga593df4d923a5f07d65ff39950e31e367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurrences of the given character in-place.  <a href="group__tlx__string.html#ga593df4d923a5f07d65ff39950e31e367">More...</a><br/></td></tr>
<tr class="separator:ga593df4d923a5f07d65ff39950e31e367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga290c6e7261f453c4774a0cf82586bf47"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga290c6e7261f453c4774a0cf82586bf47">erase_all</a> (std::string *str, const char *drop)</td></tr>
<tr class="memdesc:ga290c6e7261f453c4774a0cf82586bf47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurrences of the given characters in-place.  <a href="group__tlx__string.html#ga290c6e7261f453c4774a0cf82586bf47">More...</a><br/></td></tr>
<tr class="separator:ga290c6e7261f453c4774a0cf82586bf47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacefd443f50a3e6123651a031eb1701c4"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gacefd443f50a3e6123651a031eb1701c4">erase_all</a> (std::string *str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:gacefd443f50a3e6123651a031eb1701c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurrences of the given characters in-place.  <a href="group__tlx__string.html#gacefd443f50a3e6123651a031eb1701c4">More...</a><br/></td></tr>
<tr class="separator:gacefd443f50a3e6123651a031eb1701c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86282247928444ece567ced18f0012b1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga86282247928444ece567ced18f0012b1">erase_all</a> (const std::string &amp;str, char drop= ' ')</td></tr>
<tr class="memdesc:ga86282247928444ece567ced18f0012b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurrences of the given character, return copy of string.  <a href="group__tlx__string.html#ga86282247928444ece567ced18f0012b1">More...</a><br/></td></tr>
<tr class="separator:ga86282247928444ece567ced18f0012b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c0aa5a14584e80887d4afc8c34337f8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga7c0aa5a14584e80887d4afc8c34337f8">erase_all</a> (const std::string &amp;str, const char *drop)</td></tr>
<tr class="memdesc:ga7c0aa5a14584e80887d4afc8c34337f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurrences of the given characters, return copy of string.  <a href="group__tlx__string.html#ga7c0aa5a14584e80887d4afc8c34337f8">More...</a><br/></td></tr>
<tr class="separator:ga7c0aa5a14584e80887d4afc8c34337f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09e7dd3f20d8e54c8502c81d540f9916"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga09e7dd3f20d8e54c8502c81d540f9916">erase_all</a> (const std::string &amp;str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:ga09e7dd3f20d8e54c8502c81d540f9916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurrences of the given characters, return copy of string.  <a href="group__tlx__string.html#ga09e7dd3f20d8e54c8502c81d540f9916">More...</a><br/></td></tr>
<tr class="separator:ga09e7dd3f20d8e54c8502c81d540f9916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3ec7c7d258293a6891f016878d22f09"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gaa3ec7c7d258293a6891f016878d22f09">escape_html</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:gaa3ec7c7d258293a6891f016878d22f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escape characters for inclusion in HTML documents: replaces the characters &lt;, &gt;, &amp; and " with HTML entities.  <a href="group__tlx__string.html#gaa3ec7c7d258293a6891f016878d22f09">More...</a><br/></td></tr>
<tr class="separator:gaa3ec7c7d258293a6891f016878d22f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c9dca404398316e3ffb6266d592b38d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga6c9dca404398316e3ffb6266d592b38d">escape_uri</a> (const std::string &amp;src)</td></tr>
<tr class="memdesc:ga6c9dca404398316e3ffb6266d592b38d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escape a string into a URI-encoding.  <a href="group__tlx__string.html#ga6c9dca404398316e3ffb6266d592b38d">More...</a><br/></td></tr>
<tr class="separator:ga6c9dca404398316e3ffb6266d592b38d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga713c5cd2e2209e379c8b79ba2cd3e398"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga713c5cd2e2209e379c8b79ba2cd3e398">extract_between</a> (const std::string &amp;str, const char *sep1, const char *sep2)</td></tr>
<tr class="memdesc:ga713c5cd2e2209e379c8b79ba2cd3e398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the string for given start and end separators and extract all characters between the both, if they are found.  <a href="group__tlx__string.html#ga713c5cd2e2209e379c8b79ba2cd3e398">More...</a><br/></td></tr>
<tr class="separator:ga713c5cd2e2209e379c8b79ba2cd3e398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1ac1e43a5ae269bdbe594c4f4f4a325"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gae1ac1e43a5ae269bdbe594c4f4f4a325">extract_between</a> (const std::string &amp;str, const char *sep1, const std::string &amp;sep2)</td></tr>
<tr class="memdesc:gae1ac1e43a5ae269bdbe594c4f4f4a325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the string for given start and end separators and extract all characters between the both, if they are found.  <a href="group__tlx__string.html#gae1ac1e43a5ae269bdbe594c4f4f4a325">More...</a><br/></td></tr>
<tr class="separator:gae1ac1e43a5ae269bdbe594c4f4f4a325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0c6e73d346e3deda660b2eb24b06c67"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gaf0c6e73d346e3deda660b2eb24b06c67">extract_between</a> (const std::string &amp;str, const std::string &amp;sep1, const char *sep2)</td></tr>
<tr class="memdesc:gaf0c6e73d346e3deda660b2eb24b06c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the string for given start and end separators and extract all characters between the both, if they are found.  <a href="group__tlx__string.html#gaf0c6e73d346e3deda660b2eb24b06c67">More...</a><br/></td></tr>
<tr class="separator:gaf0c6e73d346e3deda660b2eb24b06c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3a44aaf97230d79b6aac046331240d3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gab3a44aaf97230d79b6aac046331240d3">extract_between</a> (const std::string &amp;str, const std::string &amp;sep1, const std::string &amp;sep2)</td></tr>
<tr class="memdesc:gab3a44aaf97230d79b6aac046331240d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the string for given start and end separators and extract all characters between the both, if they are found.  <a href="group__tlx__string.html#gab3a44aaf97230d79b6aac046331240d3">More...</a><br/></td></tr>
<tr class="separator:gab3a44aaf97230d79b6aac046331240d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536ac2439a4b7a17a0e089c443249e67"><td class="memTemplParams" colspan="2">template&lt;typename Separator1 , typename Separator2 &gt; </td></tr>
<tr class="memitem:a536ac2439a4b7a17a0e089c443249e67"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a536ac2439a4b7a17a0e089c443249e67">extract_between_template</a> (const std::string &amp;str, const Separator1 &amp;sep1, size_t sep1_size, const Separator2 &amp;sep2)</td></tr>
<tr class="separator:a536ac2439a4b7a17a0e089c443249e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8fd16e4ccb887bed3fa8563ca38a61d"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gad8fd16e4ccb887bed3fa8563ca38a61d">ffs</a> (int i)</td></tr>
<tr class="memdesc:gad8fd16e4ccb887bed3fa8563ca38a61d"><td class="mdescLeft">&#160;</td><td class="mdescRight">find first set bit in integer, or zero if none are set.  <a href="group__tlx__math.html#gad8fd16e4ccb887bed3fa8563ca38a61d">More...</a><br/></td></tr>
<tr class="separator:gad8fd16e4ccb887bed3fa8563ca38a61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d8d646eb127f0285aacdd5c18c45374"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga7d8d646eb127f0285aacdd5c18c45374">ffs</a> (unsigned int i)</td></tr>
<tr class="memdesc:ga7d8d646eb127f0285aacdd5c18c45374"><td class="mdescLeft">&#160;</td><td class="mdescRight">find first set bit in integer, or zero if none are set.  <a href="group__tlx__math.html#ga7d8d646eb127f0285aacdd5c18c45374">More...</a><br/></td></tr>
<tr class="separator:ga7d8d646eb127f0285aacdd5c18c45374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d2ca2e0837990f307ff6f7129c45cb5"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga8d2ca2e0837990f307ff6f7129c45cb5">ffs</a> (long i)</td></tr>
<tr class="memdesc:ga8d2ca2e0837990f307ff6f7129c45cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">find first set bit in integer, or zero if none are set.  <a href="group__tlx__math.html#ga8d2ca2e0837990f307ff6f7129c45cb5">More...</a><br/></td></tr>
<tr class="separator:ga8d2ca2e0837990f307ff6f7129c45cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf13460ad33c93a724b32cd093ecdb4f9"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gaf13460ad33c93a724b32cd093ecdb4f9">ffs</a> (unsigned long i)</td></tr>
<tr class="memdesc:gaf13460ad33c93a724b32cd093ecdb4f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">find first set bit in integer, or zero if none are set.  <a href="group__tlx__math.html#gaf13460ad33c93a724b32cd093ecdb4f9">More...</a><br/></td></tr>
<tr class="separator:gaf13460ad33c93a724b32cd093ecdb4f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e797816c0711b7a6f99a1544d7a88e2"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga7e797816c0711b7a6f99a1544d7a88e2">ffs</a> (long long i)</td></tr>
<tr class="memdesc:ga7e797816c0711b7a6f99a1544d7a88e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">find first set bit in integer, or zero if none are set.  <a href="group__tlx__math.html#ga7e797816c0711b7a6f99a1544d7a88e2">More...</a><br/></td></tr>
<tr class="separator:ga7e797816c0711b7a6f99a1544d7a88e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0cbdb957bd7c626f6602d1461143357"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gae0cbdb957bd7c626f6602d1461143357">ffs</a> (unsigned long long i)</td></tr>
<tr class="memdesc:gae0cbdb957bd7c626f6602d1461143357"><td class="mdescLeft">&#160;</td><td class="mdescRight">find first set bit in integer, or zero if none are set.  <a href="group__tlx__math.html#gae0cbdb957bd7c626f6602d1461143357">More...</a><br/></td></tr>
<tr class="separator:gae0cbdb957bd7c626f6602d1461143357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b18ba30be90fbdad29253ee722c6ed1"><td class="memTemplParams" colspan="2">template&lt;typename Integral &gt; </td></tr>
<tr class="memitem:ga6b18ba30be90fbdad29253ee722c6ed1"><td class="memTemplItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga6b18ba30be90fbdad29253ee722c6ed1">ffs_template</a> (Integral x)</td></tr>
<tr class="memdesc:ga6b18ba30be90fbdad29253ee722c6ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">ffs (find first set bit) - generic implementation  <a href="group__tlx__math.html#ga6b18ba30be90fbdad29253ee722c6ed1">More...</a><br/></td></tr>
<tr class="separator:ga6b18ba30be90fbdad29253ee722c6ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga937bd46650d317c28df7c7723ae84119"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga937bd46650d317c28df7c7723ae84119">format_iec_units</a> (uint64_t number, int precision)</td></tr>
<tr class="memdesc:ga937bd46650d317c28df7c7723ae84119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format number as something like 1 TiB.  <a href="group__tlx__string.html#ga937bd46650d317c28df7c7723ae84119">More...</a><br/></td></tr>
<tr class="separator:ga937bd46650d317c28df7c7723ae84119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga084c15f3eff7d1eb6018d00779486013"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga084c15f3eff7d1eb6018d00779486013">format_si_units</a> (uint64_t number, int precision)</td></tr>
<tr class="memdesc:ga084c15f3eff7d1eb6018d00779486013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format number as something like 1 TB.  <a href="group__tlx__string.html#ga084c15f3eff7d1eb6018d00779486013">More...</a><br/></td></tr>
<tr class="separator:ga084c15f3eff7d1eb6018d00779486013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15b290439811d07e8fc0a6134c4faa0b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga15b290439811d07e8fc0a6134c4faa0b">index_of</a> (const std::vector&lt; std::string &gt; &amp;list, const char *str)</td></tr>
<tr class="memdesc:ga15b290439811d07e8fc0a6134c4faa0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to find str in the list and return the index.  <a href="group__tlx__string.html#ga15b290439811d07e8fc0a6134c4faa0b">More...</a><br/></td></tr>
<tr class="separator:ga15b290439811d07e8fc0a6134c4faa0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5156b8029cca4a21cb3e1b14ea6526d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gac5156b8029cca4a21cb3e1b14ea6526d">index_of</a> (const std::vector&lt; std::string &gt; &amp;list, const std::string &amp;str)</td></tr>
<tr class="memdesc:gac5156b8029cca4a21cb3e1b14ea6526d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to find str in the list and return the index.  <a href="group__tlx__string.html#gac5156b8029cca4a21cb3e1b14ea6526d">More...</a><br/></td></tr>
<tr class="separator:gac5156b8029cca4a21cb3e1b14ea6526d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00bece0086ba6a8598e97e93694b713f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga00bece0086ba6a8598e97e93694b713f">index_of_icase</a> (const std::vector&lt; std::string &gt; &amp;list, const char *str)</td></tr>
<tr class="memdesc:ga00bece0086ba6a8598e97e93694b713f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to find str in the list and return the index using case-insensitive comparisons.  <a href="group__tlx__string.html#ga00bece0086ba6a8598e97e93694b713f">More...</a><br/></td></tr>
<tr class="separator:ga00bece0086ba6a8598e97e93694b713f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d3b5b0636e261f97ab3292d78f2201b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga2d3b5b0636e261f97ab3292d78f2201b">index_of_icase</a> (const std::vector&lt; std::string &gt; &amp;list, const std::string &amp;str)</td></tr>
<tr class="memdesc:ga2d3b5b0636e261f97ab3292d78f2201b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to find str in the list and return the index using case-insensitive comparisons.  <a href="group__tlx__string.html#ga2d3b5b0636e261f97ab3292d78f2201b">More...</a><br/></td></tr>
<tr class="separator:ga2d3b5b0636e261f97ab3292d78f2201b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga308b250faae05a10c7d606e06d070f54"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga308b250faae05a10c7d606e06d070f54">integer_log2_ceil</a> (int i)</td></tr>
<tr class="memdesc:ga308b250faae05a10c7d606e06d070f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the log2 ceiling of an integer type (by repeated bit shifts)  <a href="group__tlx__math.html#ga308b250faae05a10c7d606e06d070f54">More...</a><br/></td></tr>
<tr class="separator:ga308b250faae05a10c7d606e06d070f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadca678eeb1a4b5fef4dfd53c71f5f0e6"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gadca678eeb1a4b5fef4dfd53c71f5f0e6">integer_log2_ceil</a> (unsigned int i)</td></tr>
<tr class="memdesc:gadca678eeb1a4b5fef4dfd53c71f5f0e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the log2 ceiling of an integer type (by repeated bit shifts)  <a href="group__tlx__math.html#gadca678eeb1a4b5fef4dfd53c71f5f0e6">More...</a><br/></td></tr>
<tr class="separator:gadca678eeb1a4b5fef4dfd53c71f5f0e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab06a5be9a039621a428bad8b52bcb163"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gab06a5be9a039621a428bad8b52bcb163">integer_log2_ceil</a> (long i)</td></tr>
<tr class="memdesc:gab06a5be9a039621a428bad8b52bcb163"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the log2 ceiling of an integer type (by repeated bit shifts)  <a href="group__tlx__math.html#gab06a5be9a039621a428bad8b52bcb163">More...</a><br/></td></tr>
<tr class="separator:gab06a5be9a039621a428bad8b52bcb163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae906418b06ec57db053663d0437545ca"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gae906418b06ec57db053663d0437545ca">integer_log2_ceil</a> (unsigned long i)</td></tr>
<tr class="memdesc:gae906418b06ec57db053663d0437545ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the log2 ceiling of an integer type (by repeated bit shifts)  <a href="group__tlx__math.html#gae906418b06ec57db053663d0437545ca">More...</a><br/></td></tr>
<tr class="separator:gae906418b06ec57db053663d0437545ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf5b320c0091db1c3911af02aeb242877"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gaf5b320c0091db1c3911af02aeb242877">integer_log2_ceil</a> (long long i)</td></tr>
<tr class="memdesc:gaf5b320c0091db1c3911af02aeb242877"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the log2 ceiling of an integer type (by repeated bit shifts)  <a href="group__tlx__math.html#gaf5b320c0091db1c3911af02aeb242877">More...</a><br/></td></tr>
<tr class="separator:gaf5b320c0091db1c3911af02aeb242877"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae02589b516d44d66e4a9513d3f8f064f"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gae02589b516d44d66e4a9513d3f8f064f">integer_log2_ceil</a> (unsigned long long i)</td></tr>
<tr class="memdesc:gae02589b516d44d66e4a9513d3f8f064f"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the log2 ceiling of an integer type (by repeated bit shifts)  <a href="group__tlx__math.html#gae02589b516d44d66e4a9513d3f8f064f">More...</a><br/></td></tr>
<tr class="separator:gae02589b516d44d66e4a9513d3f8f064f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeab5bbc00713a95adc413ee5ddd0cb65"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gaeab5bbc00713a95adc413ee5ddd0cb65">integer_log2_floor</a> (int i)</td></tr>
<tr class="memdesc:gaeab5bbc00713a95adc413ee5ddd0cb65"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the log2 floor of an integer type (by repeated bit shifts)  <a href="group__tlx__math.html#gaeab5bbc00713a95adc413ee5ddd0cb65">More...</a><br/></td></tr>
<tr class="separator:gaeab5bbc00713a95adc413ee5ddd0cb65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e254c8067dc87ac0ce3bc8d29f338ad"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga6e254c8067dc87ac0ce3bc8d29f338ad">integer_log2_floor</a> (unsigned int i)</td></tr>
<tr class="memdesc:ga6e254c8067dc87ac0ce3bc8d29f338ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the log2 floor of an integer type (by repeated bit shifts)  <a href="group__tlx__math.html#ga6e254c8067dc87ac0ce3bc8d29f338ad">More...</a><br/></td></tr>
<tr class="separator:ga6e254c8067dc87ac0ce3bc8d29f338ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87a2457261b3eb2c6b0f8af2a058bf18"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga87a2457261b3eb2c6b0f8af2a058bf18">integer_log2_floor</a> (long i)</td></tr>
<tr class="memdesc:ga87a2457261b3eb2c6b0f8af2a058bf18"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the log2 floor of an integer type (by repeated bit shifts)  <a href="group__tlx__math.html#ga87a2457261b3eb2c6b0f8af2a058bf18">More...</a><br/></td></tr>
<tr class="separator:ga87a2457261b3eb2c6b0f8af2a058bf18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c3ab78b29d4ec0f8e9282cc0828e206"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga4c3ab78b29d4ec0f8e9282cc0828e206">integer_log2_floor</a> (unsigned long i)</td></tr>
<tr class="memdesc:ga4c3ab78b29d4ec0f8e9282cc0828e206"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the log2 floor of an integer type (by repeated bit shifts)  <a href="group__tlx__math.html#ga4c3ab78b29d4ec0f8e9282cc0828e206">More...</a><br/></td></tr>
<tr class="separator:ga4c3ab78b29d4ec0f8e9282cc0828e206"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab51c66cfcb5cacb134fc03cc76729988"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gab51c66cfcb5cacb134fc03cc76729988">integer_log2_floor</a> (long long i)</td></tr>
<tr class="memdesc:gab51c66cfcb5cacb134fc03cc76729988"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the log2 floor of an integer type (by repeated bit shifts)  <a href="group__tlx__math.html#gab51c66cfcb5cacb134fc03cc76729988">More...</a><br/></td></tr>
<tr class="separator:gab51c66cfcb5cacb134fc03cc76729988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf78c1a129c9a05c883d267e2639a045b"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gaf78c1a129c9a05c883d267e2639a045b">integer_log2_floor</a> (unsigned long long i)</td></tr>
<tr class="memdesc:gaf78c1a129c9a05c883d267e2639a045b"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the log2 floor of an integer type (by repeated bit shifts)  <a href="group__tlx__math.html#gaf78c1a129c9a05c883d267e2639a045b">More...</a><br/></td></tr>
<tr class="separator:gaf78c1a129c9a05c883d267e2639a045b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819e2d0d244166deaf699dbd962dfc4c"><td class="memTemplParams" colspan="2">template&lt;typename IntegerType &gt; </td></tr>
<tr class="memitem:a819e2d0d244166deaf699dbd962dfc4c"><td class="memTemplItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a819e2d0d244166deaf699dbd962dfc4c">integer_log2_floor_template</a> (IntegerType i)</td></tr>
<tr class="separator:a819e2d0d244166deaf699dbd962dfc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea4dbc101569da260c218aad97698847"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gaea4dbc101569da260c218aad97698847">is_power_of_two</a> (int i)</td></tr>
<tr class="memdesc:gaea4dbc101569da260c218aad97698847"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: true if i is a power of two  <a href="group__tlx__math.html#gaea4dbc101569da260c218aad97698847">More...</a><br/></td></tr>
<tr class="separator:gaea4dbc101569da260c218aad97698847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8aeeed5b11812ed9fc4e12c093f887ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga8aeeed5b11812ed9fc4e12c093f887ee">is_power_of_two</a> (unsigned int i)</td></tr>
<tr class="memdesc:ga8aeeed5b11812ed9fc4e12c093f887ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: true if i is a power of two  <a href="group__tlx__math.html#ga8aeeed5b11812ed9fc4e12c093f887ee">More...</a><br/></td></tr>
<tr class="separator:ga8aeeed5b11812ed9fc4e12c093f887ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cef6cc9dc38f1ba57d4759906369852"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga5cef6cc9dc38f1ba57d4759906369852">is_power_of_two</a> (long i)</td></tr>
<tr class="memdesc:ga5cef6cc9dc38f1ba57d4759906369852"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: true if i is a power of two  <a href="group__tlx__math.html#ga5cef6cc9dc38f1ba57d4759906369852">More...</a><br/></td></tr>
<tr class="separator:ga5cef6cc9dc38f1ba57d4759906369852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4bb5d2b01bb4f7abee2de54f1dca2f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gab4bb5d2b01bb4f7abee2de54f1dca2f9">is_power_of_two</a> (unsigned long i)</td></tr>
<tr class="memdesc:gab4bb5d2b01bb4f7abee2de54f1dca2f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: true if i is a power of two  <a href="group__tlx__math.html#gab4bb5d2b01bb4f7abee2de54f1dca2f9">More...</a><br/></td></tr>
<tr class="separator:gab4bb5d2b01bb4f7abee2de54f1dca2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73ba4e580abaebcd88684ab089ba22e3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga73ba4e580abaebcd88684ab089ba22e3">is_power_of_two</a> (long long i)</td></tr>
<tr class="memdesc:ga73ba4e580abaebcd88684ab089ba22e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: true if i is a power of two  <a href="group__tlx__math.html#ga73ba4e580abaebcd88684ab089ba22e3">More...</a><br/></td></tr>
<tr class="separator:ga73ba4e580abaebcd88684ab089ba22e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae254dcf57628545d17e5b70148c63c47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gae254dcf57628545d17e5b70148c63c47">is_power_of_two</a> (unsigned long long i)</td></tr>
<tr class="memdesc:gae254dcf57628545d17e5b70148c63c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: true if i is a power of two  <a href="group__tlx__math.html#gae254dcf57628545d17e5b70148c63c47">More...</a><br/></td></tr>
<tr class="separator:gae254dcf57628545d17e5b70148c63c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bd0c156caa682f81c584b29f1d62104"><td class="memTemplParams" colspan="2">template&lt;typename Integral &gt; </td></tr>
<tr class="memitem:a6bd0c156caa682f81c584b29f1d62104"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a6bd0c156caa682f81c584b29f1d62104">is_power_of_two_template</a> (Integral i)</td></tr>
<tr class="separator:a6bd0c156caa682f81c584b29f1d62104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced5355a13aebabfa68ca4100e507e83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#aced5355a13aebabfa68ca4100e507e83">is_space</a> (char ch)</td></tr>
<tr class="separator:aced5355a13aebabfa68ca4100e507e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aebcd1b9a6ce6667c8bbcab36aeaadb"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a7aebcd1b9a6ce6667c8bbcab36aeaadb">is_white</a> (char c)</td></tr>
<tr class="separator:a7aebcd1b9a6ce6667c8bbcab36aeaadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad383d32ace209b51abe936d256d0bb1e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gad383d32ace209b51abe936d256d0bb1e">join</a> (char glue, const std::vector&lt; std::string &gt; &amp;parts)</td></tr>
<tr class="memdesc:gad383d32ace209b51abe936d256d0bb1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a vector of strings by some glue character between each pair from the sequence.  <a href="group__tlx__string.html#gad383d32ace209b51abe936d256d0bb1e">More...</a><br/></td></tr>
<tr class="separator:gad383d32ace209b51abe936d256d0bb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cb20ee53f25c37880faf1b5e5ac3619"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga0cb20ee53f25c37880faf1b5e5ac3619">join</a> (const char *glue, const std::vector&lt; std::string &gt; &amp;parts)</td></tr>
<tr class="memdesc:ga0cb20ee53f25c37880faf1b5e5ac3619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a vector of strings by some glue string between each pair from the sequence.  <a href="group__tlx__string.html#ga0cb20ee53f25c37880faf1b5e5ac3619">More...</a><br/></td></tr>
<tr class="separator:ga0cb20ee53f25c37880faf1b5e5ac3619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga206c170915b483387448714300d311c1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga206c170915b483387448714300d311c1">join</a> (const std::string &amp;glue, const std::vector&lt; std::string &gt; &amp;parts)</td></tr>
<tr class="memdesc:ga206c170915b483387448714300d311c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a vector of strings by some glue string between each pair from the sequence.  <a href="group__tlx__string.html#ga206c170915b483387448714300d311c1">More...</a><br/></td></tr>
<tr class="separator:ga206c170915b483387448714300d311c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1af0448079469f224ea8905c34dc1868"><td class="memTemplParams" colspan="2">template&lt;typename Glue , typename Iterator &gt; </td></tr>
<tr class="memitem:ga1af0448079469f224ea8905c34dc1868"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga1af0448079469f224ea8905c34dc1868">join</a> (Glue glue, Iterator first, Iterator last)</td></tr>
<tr class="memdesc:ga1af0448079469f224ea8905c34dc1868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a sequence of strings by some glue string between each pair from the sequence.  <a href="group__tlx__string.html#ga1af0448079469f224ea8905c34dc1868">More...</a><br/></td></tr>
<tr class="separator:ga1af0448079469f224ea8905c34dc1868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a96227b0edd6c65800124ba1dac82cf"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:ga4a96227b0edd6c65800124ba1dac82cf"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga4a96227b0edd6c65800124ba1dac82cf">join</a> (char glue, const Container &amp;parts)</td></tr>
<tr class="memdesc:ga4a96227b0edd6c65800124ba1dac82cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a Container of strings by some glue character between each pair from the sequence.  <a href="group__tlx__string.html#ga4a96227b0edd6c65800124ba1dac82cf">More...</a><br/></td></tr>
<tr class="separator:ga4a96227b0edd6c65800124ba1dac82cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffea57c0c1e61aa8c9bc50e1ec2f9fe2"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:gaffea57c0c1e61aa8c9bc50e1ec2f9fe2"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gaffea57c0c1e61aa8c9bc50e1ec2f9fe2">join</a> (const char *glue, const Container &amp;parts)</td></tr>
<tr class="memdesc:gaffea57c0c1e61aa8c9bc50e1ec2f9fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a Container of strings by some glue string between each pair from the sequence.  <a href="group__tlx__string.html#gaffea57c0c1e61aa8c9bc50e1ec2f9fe2">More...</a><br/></td></tr>
<tr class="separator:gaffea57c0c1e61aa8c9bc50e1ec2f9fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e35ca12bd4564ba470e3bf4f6a91798"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:ga2e35ca12bd4564ba470e3bf4f6a91798"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga2e35ca12bd4564ba470e3bf4f6a91798">join</a> (const std::string &amp;glue, const Container &amp;parts)</td></tr>
<tr class="memdesc:ga2e35ca12bd4564ba470e3bf4f6a91798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a Container of strings by some glue string between each pair from the sequence.  <a href="group__tlx__string.html#ga2e35ca12bd4564ba470e3bf4f6a91798">More...</a><br/></td></tr>
<tr class="separator:ga2e35ca12bd4564ba470e3bf4f6a91798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a73759be8d7ec5778cb6192bc32c4c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga3a73759be8d7ec5778cb6192bc32c4c2">less_icase</a> (const char *a, const char *b)</td></tr>
<tr class="memdesc:ga3a73759be8d7ec5778cb6192bc32c4c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a &lt; b without regard for letter case  <a href="group__tlx__string.html#ga3a73759be8d7ec5778cb6192bc32c4c2">More...</a><br/></td></tr>
<tr class="separator:ga3a73759be8d7ec5778cb6192bc32c4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e53bb43043cc4fdf6fef5a9f017957c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga0e53bb43043cc4fdf6fef5a9f017957c">less_icase</a> (const char *a, const std::string &amp;b)</td></tr>
<tr class="memdesc:ga0e53bb43043cc4fdf6fef5a9f017957c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a &lt; b without regard for letter case  <a href="group__tlx__string.html#ga0e53bb43043cc4fdf6fef5a9f017957c">More...</a><br/></td></tr>
<tr class="separator:ga0e53bb43043cc4fdf6fef5a9f017957c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25e2629353a36fb47c587b4eef89c0d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga25e2629353a36fb47c587b4eef89c0d2">less_icase</a> (const std::string &amp;a, const char *b)</td></tr>
<tr class="memdesc:ga25e2629353a36fb47c587b4eef89c0d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a &lt; b without regard for letter case  <a href="group__tlx__string.html#ga25e2629353a36fb47c587b4eef89c0d2">More...</a><br/></td></tr>
<tr class="separator:ga25e2629353a36fb47c587b4eef89c0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fb49f152c6bf0d96ec46bfb90a38bfc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga9fb49f152c6bf0d96ec46bfb90a38bfc">less_icase</a> (const std::string &amp;a, const std::string &amp;b)</td></tr>
<tr class="memdesc:ga9fb49f152c6bf0d96ec46bfb90a38bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a &lt; b without regard for letter case  <a href="group__tlx__string.html#ga9fb49f152c6bf0d96ec46bfb90a38bfc">More...</a><br/></td></tr>
<tr class="separator:ga9fb49f152c6bf0d96ec46bfb90a38bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae38d352a065543cf324f52a58bd2b026"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename... Args&gt; </td></tr>
<tr class="memitem:ae38d352a065543cf324f52a58bd2b026"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1CountingPtr.html">CountingPtr</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ae38d352a065543cf324f52a58bd2b026">make_counting</a> (Args &amp;&amp;...args)</td></tr>
<tr class="memdesc:ae38d352a065543cf324f52a58bd2b026"><td class="mdescLeft">&#160;</td><td class="mdescRight">method analogous to std::make_shared and std::make_unique.  <a href="#ae38d352a065543cf324f52a58bd2b026">More...</a><br/></td></tr>
<tr class="separator:ae38d352a065543cf324f52a58bd2b026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac208faa35171eb6016cf9730ed83f3"><td class="memTemplParams" colspan="2">template&lt;class C , typename R , typename... A&gt; </td></tr>
<tr class="memitem:abac208faa35171eb6016cf9730ed83f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&lt; R(A...)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#abac208faa35171eb6016cf9730ed83f3">make_delegate</a> (C *const object_ptr, R(C::*const method_ptr)(A...)) noexcept</td></tr>
<tr class="memdesc:abac208faa35171eb6016cf9730ed83f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for wrapping a class::method with object pointer.  <a href="#abac208faa35171eb6016cf9730ed83f3">More...</a><br/></td></tr>
<tr class="separator:abac208faa35171eb6016cf9730ed83f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e57fc132415d92776d9eed01ae3442"><td class="memTemplParams" colspan="2">template&lt;class C , typename R , typename... A&gt; </td></tr>
<tr class="memitem:a36e57fc132415d92776d9eed01ae3442"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&lt; R(A...)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a36e57fc132415d92776d9eed01ae3442">make_delegate</a> (C &amp;object_ptr, R(C::*const method_ptr)(A...)) noexcept</td></tr>
<tr class="memdesc:a36e57fc132415d92776d9eed01ae3442"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for wrapping a class::method with object reference.  <a href="#a36e57fc132415d92776d9eed01ae3442">More...</a><br/></td></tr>
<tr class="separator:a36e57fc132415d92776d9eed01ae3442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf10f085647ba34ff677aeecba994064"><td class="memTemplParams" colspan="2">template&lt;class C , typename R , typename... A&gt; </td></tr>
<tr class="memitem:aaf10f085647ba34ff677aeecba994064"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&lt; R(A...)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#aaf10f085647ba34ff677aeecba994064">make_delegate</a> (C const &amp;object_ptr, R(C::*const method_ptr)(A...) const) noexcept</td></tr>
<tr class="memdesc:aaf10f085647ba34ff677aeecba994064"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for wrapping a const class::method with object reference.  <a href="#aaf10f085647ba34ff677aeecba994064">More...</a><br/></td></tr>
<tr class="separator:aaf10f085647ba34ff677aeecba994064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2afc1ff7d0b9ea7a6583d0573e36ef7"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:gab2afc1ff7d0b9ea7a6583d0573e36ef7"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__meta.html#gab2afc1ff7d0b9ea7a6583d0573e36ef7">make_function_chain</a> (const Functor &amp;functor)</td></tr>
<tr class="memdesc:gab2afc1ff7d0b9ea7a6583d0573e36ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor chain maker. Can also be called with a lambda function.  <a href="group__tlx__meta.html#gab2afc1ff7d0b9ea7a6583d0573e36ef7">More...</a><br/></td></tr>
<tr class="separator:gab2afc1ff7d0b9ea7a6583d0573e36ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd2b32ffd2415899c6a69ccac4d7138f"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__meta.html#gadd2b32ffd2415899c6a69ccac4d7138f">make_function_chain</a> ()</td></tr>
<tr class="memdesc:gadd2b32ffd2415899c6a69ccac4d7138f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and empty function chain.  <a href="group__tlx__meta.html#gadd2b32ffd2415899c6a69ccac4d7138f">More...</a><br/></td></tr>
<tr class="separator:gadd2b32ffd2415899c6a69ccac4d7138f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4f5461dca9e4be26479c56a5500357e"><td class="memTemplParams" colspan="2">template&lt;typename Input , typename Functor &gt; </td></tr>
<tr class="memitem:gaf4f5461dca9e4be26479c56a5500357e"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__meta.html#gaf4f5461dca9e4be26479c56a5500357e">make_function_stack</a> (const Functor &amp;functor)</td></tr>
<tr class="memdesc:gaf4f5461dca9e4be26479c56a5500357e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function-style construction of a <a class="el" href="classtlx_1_1FunctionStack.html" title="A FunctionStack is a chain of functor that can be folded to a single functor (which is usually optimi...">FunctionStack</a>.  <a href="group__tlx__meta.html#gaf4f5461dca9e4be26479c56a5500357e">More...</a><br/></td></tr>
<tr class="separator:gaf4f5461dca9e4be26479c56a5500357e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571b1c19ce4d530c4aaa3cd797c8ccae"><td class="memTemplParams" colspan="2">template&lt;typename A , typename D &gt; </td></tr>
<tr class="memitem:a571b1c19ce4d530c4aaa3cd797c8ccae"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a571b1c19ce4d530c4aaa3cd797c8ccae">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classtlx_1_1CountingPtr.html">CountingPtr</a>&lt; A, D &gt; &amp;c)</td></tr>
<tr class="memdesc:a571b1c19ce4d530c4aaa3cd797c8ccae"><td class="mdescLeft">&#160;</td><td class="mdescRight">print pointer  <a href="#a571b1c19ce4d530c4aaa3cd797c8ccae">More...</a><br/></td></tr>
<tr class="separator:a571b1c19ce4d530c4aaa3cd797c8ccae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03240bad0b02669f254c21c28009c21a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga03240bad0b02669f254c21c28009c21a">pad</a> (const std::string &amp;s, size_t len, char pad_char= ' ')</td></tr>
<tr class="memdesc:ga03240bad0b02669f254c21c28009c21a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate or pad string to exactly len characters.  <a href="group__tlx__string.html#ga03240bad0b02669f254c21c28009c21a">More...</a><br/></td></tr>
<tr class="separator:ga03240bad0b02669f254c21c28009c21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58be0557b1b38913b28d947c935aed42"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga58be0557b1b38913b28d947c935aed42">parse_si_iec_units</a> (const char *str, uint64_t *out_size, char default_unit=0)</td></tr>
<tr class="memdesc:ga58be0557b1b38913b28d947c935aed42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a string like "343KB" or "44 GiB" into the corresponding size in bytes.  <a href="group__tlx__string.html#ga58be0557b1b38913b28d947c935aed42">More...</a><br/></td></tr>
<tr class="separator:ga58be0557b1b38913b28d947c935aed42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42a656ed3586b515140cb71b312f0f9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga42a656ed3586b515140cb71b312f0f9b">parse_si_iec_units</a> (const std::string &amp;str, uint64_t *out_size, char default_unit=0)</td></tr>
<tr class="memdesc:ga42a656ed3586b515140cb71b312f0f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a string like "343KB" or "44 GiB" into the corresponding size in bytes.  <a href="group__tlx__string.html#ga42a656ed3586b515140cb71b312f0f9b">More...</a><br/></td></tr>
<tr class="separator:ga42a656ed3586b515140cb71b312f0f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7021d36930f4bd434b2082dce8bd43cf"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga7021d36930f4bd434b2082dce8bd43cf">replace_all</a> (std::string *str, const std::string &amp;needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:ga7021d36930f4bd434b2082dce8bd43cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="group__tlx__string.html#ga7021d36930f4bd434b2082dce8bd43cf">More...</a><br/></td></tr>
<tr class="separator:ga7021d36930f4bd434b2082dce8bd43cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd5bd9f9a887fa20b4a8ebaf987fd5de"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gadd5bd9f9a887fa20b4a8ebaf987fd5de">replace_all</a> (std::string *str, const std::string &amp;needle, const char *instead)</td></tr>
<tr class="memdesc:gadd5bd9f9a887fa20b4a8ebaf987fd5de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="group__tlx__string.html#gadd5bd9f9a887fa20b4a8ebaf987fd5de">More...</a><br/></td></tr>
<tr class="separator:gadd5bd9f9a887fa20b4a8ebaf987fd5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b4b8117690af529b7051a3c10c382ff"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga6b4b8117690af529b7051a3c10c382ff">replace_all</a> (std::string *str, const char *needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:ga6b4b8117690af529b7051a3c10c382ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="group__tlx__string.html#ga6b4b8117690af529b7051a3c10c382ff">More...</a><br/></td></tr>
<tr class="separator:ga6b4b8117690af529b7051a3c10c382ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d7d14badd05473e5a5c847b3f91b9e9"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga0d7d14badd05473e5a5c847b3f91b9e9">replace_all</a> (std::string *str, const char *needle, const char *instead)</td></tr>
<tr class="memdesc:ga0d7d14badd05473e5a5c847b3f91b9e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="group__tlx__string.html#ga0d7d14badd05473e5a5c847b3f91b9e9">More...</a><br/></td></tr>
<tr class="separator:ga0d7d14badd05473e5a5c847b3f91b9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga768d59e5cc6d2c91f25a441ab4d265a6"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga768d59e5cc6d2c91f25a441ab4d265a6">replace_all</a> (std::string *str, char needle, char instead)</td></tr>
<tr class="memdesc:ga768d59e5cc6d2c91f25a441ab4d265a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="group__tlx__string.html#ga768d59e5cc6d2c91f25a441ab4d265a6">More...</a><br/></td></tr>
<tr class="separator:ga768d59e5cc6d2c91f25a441ab4d265a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac001aff0fa6c3bee2e9755e3ddd516f9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gac001aff0fa6c3bee2e9755e3ddd516f9">replace_all</a> (const std::string &amp;str, const std::string &amp;needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:gac001aff0fa6c3bee2e9755e3ddd516f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="group__tlx__string.html#gac001aff0fa6c3bee2e9755e3ddd516f9">More...</a><br/></td></tr>
<tr class="separator:gac001aff0fa6c3bee2e9755e3ddd516f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfe9c066393585d1a769cbd55e9f9960"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gadfe9c066393585d1a769cbd55e9f9960">replace_all</a> (const std::string &amp;str, const std::string &amp;needle, const char *instead)</td></tr>
<tr class="memdesc:gadfe9c066393585d1a769cbd55e9f9960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="group__tlx__string.html#gadfe9c066393585d1a769cbd55e9f9960">More...</a><br/></td></tr>
<tr class="separator:gadfe9c066393585d1a769cbd55e9f9960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e3b406ea495a236fff401c3585d8814"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga4e3b406ea495a236fff401c3585d8814">replace_all</a> (const std::string &amp;str, const char *needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:ga4e3b406ea495a236fff401c3585d8814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="group__tlx__string.html#ga4e3b406ea495a236fff401c3585d8814">More...</a><br/></td></tr>
<tr class="separator:ga4e3b406ea495a236fff401c3585d8814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14cfa75fa579e1d4943855455d9e605d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga14cfa75fa579e1d4943855455d9e605d">replace_all</a> (const std::string &amp;str, const char *needle, const char *instead)</td></tr>
<tr class="memdesc:ga14cfa75fa579e1d4943855455d9e605d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="group__tlx__string.html#ga14cfa75fa579e1d4943855455d9e605d">More...</a><br/></td></tr>
<tr class="separator:ga14cfa75fa579e1d4943855455d9e605d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae87b40ae8e461c110fffcb7a12b066d5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gae87b40ae8e461c110fffcb7a12b066d5">replace_all</a> (const std::string &amp;str, char needle, char instead)</td></tr>
<tr class="memdesc:gae87b40ae8e461c110fffcb7a12b066d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="group__tlx__string.html#gae87b40ae8e461c110fffcb7a12b066d5">More...</a><br/></td></tr>
<tr class="separator:gae87b40ae8e461c110fffcb7a12b066d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca0aeb9a74105ec849e939229d47970b"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gaca0aeb9a74105ec849e939229d47970b">replace_first</a> (std::string *str, const std::string &amp;needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:gaca0aeb9a74105ec849e939229d47970b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="group__tlx__string.html#gaca0aeb9a74105ec849e939229d47970b">More...</a><br/></td></tr>
<tr class="separator:gaca0aeb9a74105ec849e939229d47970b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32d2a706e20d6e5b07cbb677c340deba"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga32d2a706e20d6e5b07cbb677c340deba">replace_first</a> (std::string *str, const std::string &amp;needle, const char *instead)</td></tr>
<tr class="memdesc:ga32d2a706e20d6e5b07cbb677c340deba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="group__tlx__string.html#ga32d2a706e20d6e5b07cbb677c340deba">More...</a><br/></td></tr>
<tr class="separator:ga32d2a706e20d6e5b07cbb677c340deba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2b83d93d49145437aec2964f30e4cd1"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gab2b83d93d49145437aec2964f30e4cd1">replace_first</a> (std::string *str, const char *needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:gab2b83d93d49145437aec2964f30e4cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="group__tlx__string.html#gab2b83d93d49145437aec2964f30e4cd1">More...</a><br/></td></tr>
<tr class="separator:gab2b83d93d49145437aec2964f30e4cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ed49bc3eebffeefeff05f84ffbcc086"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga6ed49bc3eebffeefeff05f84ffbcc086">replace_first</a> (std::string *str, const char *needle, const char *instead)</td></tr>
<tr class="memdesc:ga6ed49bc3eebffeefeff05f84ffbcc086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="group__tlx__string.html#ga6ed49bc3eebffeefeff05f84ffbcc086">More...</a><br/></td></tr>
<tr class="separator:ga6ed49bc3eebffeefeff05f84ffbcc086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4865798a465a43845804dda0fe21f888"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga4865798a465a43845804dda0fe21f888">replace_first</a> (std::string *str, char needle, char instead)</td></tr>
<tr class="memdesc:ga4865798a465a43845804dda0fe21f888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="group__tlx__string.html#ga4865798a465a43845804dda0fe21f888">More...</a><br/></td></tr>
<tr class="separator:ga4865798a465a43845804dda0fe21f888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b0092a333e84d0c4eaae50955bc5a71"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga8b0092a333e84d0c4eaae50955bc5a71">replace_first</a> (const std::string &amp;str, const std::string &amp;needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:ga8b0092a333e84d0c4eaae50955bc5a71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="group__tlx__string.html#ga8b0092a333e84d0c4eaae50955bc5a71">More...</a><br/></td></tr>
<tr class="separator:ga8b0092a333e84d0c4eaae50955bc5a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6b1e9aa3d513c96cd5973e50551d6b5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gab6b1e9aa3d513c96cd5973e50551d6b5">replace_first</a> (const std::string &amp;str, const std::string &amp;needle, const char *instead)</td></tr>
<tr class="memdesc:gab6b1e9aa3d513c96cd5973e50551d6b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="group__tlx__string.html#gab6b1e9aa3d513c96cd5973e50551d6b5">More...</a><br/></td></tr>
<tr class="separator:gab6b1e9aa3d513c96cd5973e50551d6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7e6db7b1dfe54efc4b195f27df5ed71"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gae7e6db7b1dfe54efc4b195f27df5ed71">replace_first</a> (const std::string &amp;str, const char *needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:gae7e6db7b1dfe54efc4b195f27df5ed71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="group__tlx__string.html#gae7e6db7b1dfe54efc4b195f27df5ed71">More...</a><br/></td></tr>
<tr class="separator:gae7e6db7b1dfe54efc4b195f27df5ed71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga711f2f36ac6d9cb35a6a63672e47a47c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga711f2f36ac6d9cb35a6a63672e47a47c">replace_first</a> (const std::string &amp;str, const char *needle, const char *instead)</td></tr>
<tr class="memdesc:ga711f2f36ac6d9cb35a6a63672e47a47c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="group__tlx__string.html#ga711f2f36ac6d9cb35a6a63672e47a47c">More...</a><br/></td></tr>
<tr class="separator:ga711f2f36ac6d9cb35a6a63672e47a47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga276e1110c0ea48a01ef5a84f8ff40f37"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga276e1110c0ea48a01ef5a84f8ff40f37">replace_first</a> (const std::string &amp;str, char needle, char instead)</td></tr>
<tr class="memdesc:ga276e1110c0ea48a01ef5a84f8ff40f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="group__tlx__string.html#ga276e1110c0ea48a01ef5a84f8ff40f37">More...</a><br/></td></tr>
<tr class="separator:ga276e1110c0ea48a01ef5a84f8ff40f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa50e73c46089254357071626407f6ae5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gaa50e73c46089254357071626407f6ae5">round_down_to_power_of_two</a> (int i)</td></tr>
<tr class="memdesc:gaa50e73c46089254357071626407f6ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: round down to next power of two  <a href="group__tlx__math.html#gaa50e73c46089254357071626407f6ae5">More...</a><br/></td></tr>
<tr class="separator:gaa50e73c46089254357071626407f6ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabba29a3381e0f408d02fdcfcf902d231"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gabba29a3381e0f408d02fdcfcf902d231">round_down_to_power_of_two</a> (unsigned int i)</td></tr>
<tr class="memdesc:gabba29a3381e0f408d02fdcfcf902d231"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: round down to next power of two  <a href="group__tlx__math.html#gabba29a3381e0f408d02fdcfcf902d231">More...</a><br/></td></tr>
<tr class="separator:gabba29a3381e0f408d02fdcfcf902d231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4491e641b62d7fce29c55c6f433eb27"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gab4491e641b62d7fce29c55c6f433eb27">round_down_to_power_of_two</a> (long i)</td></tr>
<tr class="memdesc:gab4491e641b62d7fce29c55c6f433eb27"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: round down to next power of two  <a href="group__tlx__math.html#gab4491e641b62d7fce29c55c6f433eb27">More...</a><br/></td></tr>
<tr class="separator:gab4491e641b62d7fce29c55c6f433eb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac4552e08e9a23d0e81ee4f8ee59120cf"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gac4552e08e9a23d0e81ee4f8ee59120cf">round_down_to_power_of_two</a> (unsigned long i)</td></tr>
<tr class="memdesc:gac4552e08e9a23d0e81ee4f8ee59120cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: round down to next power of two  <a href="group__tlx__math.html#gac4552e08e9a23d0e81ee4f8ee59120cf">More...</a><br/></td></tr>
<tr class="separator:gac4552e08e9a23d0e81ee4f8ee59120cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ec390489ce7fdc3894c0fad838cf5a1"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga8ec390489ce7fdc3894c0fad838cf5a1">round_down_to_power_of_two</a> (long long i)</td></tr>
<tr class="memdesc:ga8ec390489ce7fdc3894c0fad838cf5a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: round down to next power of two  <a href="group__tlx__math.html#ga8ec390489ce7fdc3894c0fad838cf5a1">More...</a><br/></td></tr>
<tr class="separator:ga8ec390489ce7fdc3894c0fad838cf5a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff63db7737beabefc45daa2078c4652a"><td class="memItemLeft" align="right" valign="top">unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gaff63db7737beabefc45daa2078c4652a">round_down_to_power_of_two</a> (unsigned long long i)</td></tr>
<tr class="memdesc:gaff63db7737beabefc45daa2078c4652a"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: round down to next power of two  <a href="group__tlx__math.html#gaff63db7737beabefc45daa2078c4652a">More...</a><br/></td></tr>
<tr class="separator:gaff63db7737beabefc45daa2078c4652a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa9b29ed1503f8d8345c0b3c6daad3a63"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gaa9b29ed1503f8d8345c0b3c6daad3a63">round_up_to_power_of_two</a> (int i)</td></tr>
<tr class="memdesc:gaa9b29ed1503f8d8345c0b3c6daad3a63"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: round up to next power of two  <a href="group__tlx__math.html#gaa9b29ed1503f8d8345c0b3c6daad3a63">More...</a><br/></td></tr>
<tr class="separator:gaa9b29ed1503f8d8345c0b3c6daad3a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9684b11398f4dc70e94b512e70b791d7"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga9684b11398f4dc70e94b512e70b791d7">round_up_to_power_of_two</a> (unsigned int i)</td></tr>
<tr class="memdesc:ga9684b11398f4dc70e94b512e70b791d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: round up to next power of two  <a href="group__tlx__math.html#ga9684b11398f4dc70e94b512e70b791d7">More...</a><br/></td></tr>
<tr class="separator:ga9684b11398f4dc70e94b512e70b791d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga181e095bba991ad9f8174a6eff001ad7"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga181e095bba991ad9f8174a6eff001ad7">round_up_to_power_of_two</a> (long i)</td></tr>
<tr class="memdesc:ga181e095bba991ad9f8174a6eff001ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: round up to next power of two  <a href="group__tlx__math.html#ga181e095bba991ad9f8174a6eff001ad7">More...</a><br/></td></tr>
<tr class="separator:ga181e095bba991ad9f8174a6eff001ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06e019352e0529b297d39bfbb591775f"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga06e019352e0529b297d39bfbb591775f">round_up_to_power_of_two</a> (unsigned long i)</td></tr>
<tr class="memdesc:ga06e019352e0529b297d39bfbb591775f"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: round up to next power of two  <a href="group__tlx__math.html#ga06e019352e0529b297d39bfbb591775f">More...</a><br/></td></tr>
<tr class="separator:ga06e019352e0529b297d39bfbb591775f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad221e96917e629c78fde55e8a365691f"><td class="memItemLeft" align="right" valign="top">long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gad221e96917e629c78fde55e8a365691f">round_up_to_power_of_two</a> (long long i)</td></tr>
<tr class="memdesc:gad221e96917e629c78fde55e8a365691f"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: round up to next power of two  <a href="group__tlx__math.html#gad221e96917e629c78fde55e8a365691f">More...</a><br/></td></tr>
<tr class="separator:gad221e96917e629c78fde55e8a365691f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a38aaf9675c285b2902a60148a7e932"><td class="memItemLeft" align="right" valign="top">unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga6a38aaf9675c285b2902a60148a7e932">round_up_to_power_of_two</a> (unsigned long long i)</td></tr>
<tr class="memdesc:ga6a38aaf9675c285b2902a60148a7e932"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: round up to next power of two  <a href="group__tlx__math.html#ga6a38aaf9675c285b2902a60148a7e932">More...</a><br/></td></tr>
<tr class="separator:ga6a38aaf9675c285b2902a60148a7e932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a165140a3f756701491e3958c9858ea2c"><td class="memTemplParams" colspan="2">template&lt;typename Integral &gt; </td></tr>
<tr class="memitem:a165140a3f756701491e3958c9858ea2c"><td class="memTemplItemLeft" align="right" valign="top">static Integral&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a165140a3f756701491e3958c9858ea2c">round_up_to_power_of_two_template</a> (Integral n)</td></tr>
<tr class="separator:a165140a3f756701491e3958c9858ea2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac377d7abe96391a306d74f49c1f92ab0"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ac377d7abe96391a306d74f49c1f92ab0">siphash</a> (const uint8_t key[16], const uint8_t *msg, size_t size)</td></tr>
<tr class="separator:ac377d7abe96391a306d74f49c1f92ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b74a8ec4e849ee19578715c65836ab"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ab5b74a8ec4e849ee19578715c65836ab">siphash</a> (const uint8_t *msg, size_t size)</td></tr>
<tr class="separator:ab5b74a8ec4e849ee19578715c65836ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e52665aa49af074f344396ad6264f8"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a36e52665aa49af074f344396ad6264f8"><td class="memTemplItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a36e52665aa49af074f344396ad6264f8">siphash</a> (const Type &amp;value)</td></tr>
<tr class="separator:a36e52665aa49af074f344396ad6264f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbb7e10c5e866474d0a516ba06388f8"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a1dbb7e10c5e866474d0a516ba06388f8">siphash_plain</a> (const uint8_t key[16], const uint8_t *m, size_t len)</td></tr>
<tr class="separator:a1dbb7e10c5e866474d0a516ba06388f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fb56b145f00428be03f74257c61f1cc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga4fb56b145f00428be03f74257c61f1cc">split</a> (char sep, const std::string &amp;str, std::string::size_type limit=std::string::npos)</td></tr>
<tr class="memdesc:ga4fb56b145f00428be03f74257c61f1cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator character into distinct substrings.  <a href="group__tlx__string.html#ga4fb56b145f00428be03f74257c61f1cc">More...</a><br/></td></tr>
<tr class="separator:ga4fb56b145f00428be03f74257c61f1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad838882b8fc992742b09450925758b32"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gad838882b8fc992742b09450925758b32">split</a> (const char *sep, const std::string &amp;str, std::string::size_type limit=std::string::npos)</td></tr>
<tr class="memdesc:gad838882b8fc992742b09450925758b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator string into distinct substrings.  <a href="group__tlx__string.html#gad838882b8fc992742b09450925758b32">More...</a><br/></td></tr>
<tr class="separator:gad838882b8fc992742b09450925758b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d57e8e6ac19e94787bf3cd44a79c1fe"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga0d57e8e6ac19e94787bf3cd44a79c1fe">split</a> (const std::string &amp;sep, const std::string &amp;str, std::string::size_type limit=std::string::npos)</td></tr>
<tr class="memdesc:ga0d57e8e6ac19e94787bf3cd44a79c1fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator string into distinct substrings.  <a href="group__tlx__string.html#ga0d57e8e6ac19e94787bf3cd44a79c1fe">More...</a><br/></td></tr>
<tr class="separator:ga0d57e8e6ac19e94787bf3cd44a79c1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00c921a6a793d9c4e59e380b2bb32fca"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga00c921a6a793d9c4e59e380b2bb32fca">split</a> (char sep, const std::string &amp;str, std::string::size_type min_fields, std::string::size_type limit)</td></tr>
<tr class="memdesc:ga00c921a6a793d9c4e59e380b2bb32fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator character into distinct substrings.  <a href="group__tlx__string.html#ga00c921a6a793d9c4e59e380b2bb32fca">More...</a><br/></td></tr>
<tr class="separator:ga00c921a6a793d9c4e59e380b2bb32fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5fb737c26e5fa4d63467b0ded2a1b90"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gac5fb737c26e5fa4d63467b0ded2a1b90">split</a> (const char *sep, const std::string &amp;str, std::string::size_type min_fields, std::string::size_type limit)</td></tr>
<tr class="memdesc:gac5fb737c26e5fa4d63467b0ded2a1b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator string into distinct substrings.  <a href="group__tlx__string.html#gac5fb737c26e5fa4d63467b0ded2a1b90">More...</a><br/></td></tr>
<tr class="separator:gac5fb737c26e5fa4d63467b0ded2a1b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a0a5d581ecd362eaae43bdee50b3896"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga7a0a5d581ecd362eaae43bdee50b3896">split</a> (const std::string &amp;sep, const std::string &amp;str, std::string::size_type min_fields, std::string::size_type limit)</td></tr>
<tr class="memdesc:ga7a0a5d581ecd362eaae43bdee50b3896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator string into distinct substrings.  <a href="group__tlx__string.html#ga7a0a5d581ecd362eaae43bdee50b3896">More...</a><br/></td></tr>
<tr class="separator:ga7a0a5d581ecd362eaae43bdee50b3896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17fd4a3698ca54702b30dddc232bf903"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga17fd4a3698ca54702b30dddc232bf903">split</a> (std::vector&lt; std::string &gt; *into, char sep, const std::string &amp;str, std::string::size_type limit=std::string::npos)</td></tr>
<tr class="memdesc:ga17fd4a3698ca54702b30dddc232bf903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator character into distinct substrings.  <a href="group__tlx__string.html#ga17fd4a3698ca54702b30dddc232bf903">More...</a><br/></td></tr>
<tr class="separator:ga17fd4a3698ca54702b30dddc232bf903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88597e53210df27ef4d5db668a02fa7"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ae88597e53210df27ef4d5db668a02fa7">split</a> (std::vector&lt; std::string &gt; *into, const char *sep, size_t sep_size, const std::string &amp;str, std::string::size_type limit)</td></tr>
<tr class="separator:ae88597e53210df27ef4d5db668a02fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga177a8fd78d5cc4e0fd8dc50810967d89"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga177a8fd78d5cc4e0fd8dc50810967d89">split</a> (std::vector&lt; std::string &gt; *into, const char *sep, const std::string &amp;str, std::string::size_type limit=std::string::npos)</td></tr>
<tr class="memdesc:ga177a8fd78d5cc4e0fd8dc50810967d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator string into distinct substrings.  <a href="group__tlx__string.html#ga177a8fd78d5cc4e0fd8dc50810967d89">More...</a><br/></td></tr>
<tr class="separator:ga177a8fd78d5cc4e0fd8dc50810967d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga431c048d40a30f531e2e419e26582e4c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga431c048d40a30f531e2e419e26582e4c">split</a> (std::vector&lt; std::string &gt; *into, const std::string &amp;sep, const std::string &amp;str, std::string::size_type limit=std::string::npos)</td></tr>
<tr class="memdesc:ga431c048d40a30f531e2e419e26582e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator string into distinct substrings.  <a href="group__tlx__string.html#ga431c048d40a30f531e2e419e26582e4c">More...</a><br/></td></tr>
<tr class="separator:ga431c048d40a30f531e2e419e26582e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4997fcbeb1c6a97d23bce8ea590b3ce3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga4997fcbeb1c6a97d23bce8ea590b3ce3">split</a> (std::vector&lt; std::string &gt; *into, char sep, const std::string &amp;str, std::string::size_type min_fields, std::string::size_type limit)</td></tr>
<tr class="memdesc:ga4997fcbeb1c6a97d23bce8ea590b3ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator character into distinct substrings.  <a href="group__tlx__string.html#ga4997fcbeb1c6a97d23bce8ea590b3ce3">More...</a><br/></td></tr>
<tr class="separator:ga4997fcbeb1c6a97d23bce8ea590b3ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40222e4ae7f552a3d6f8d485ced3d91d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga40222e4ae7f552a3d6f8d485ced3d91d">split</a> (std::vector&lt; std::string &gt; *into, const char *sep, const std::string &amp;str, std::string::size_type min_fields, std::string::size_type limit)</td></tr>
<tr class="memdesc:ga40222e4ae7f552a3d6f8d485ced3d91d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator string into distinct substrings.  <a href="group__tlx__string.html#ga40222e4ae7f552a3d6f8d485ced3d91d">More...</a><br/></td></tr>
<tr class="separator:ga40222e4ae7f552a3d6f8d485ced3d91d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4aa7e0fb9bd81e31214087d3d85367a3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga4aa7e0fb9bd81e31214087d3d85367a3">split</a> (std::vector&lt; std::string &gt; *into, const std::string &amp;sep, const std::string &amp;str, std::string::size_type min_fields, std::string::size_type limit)</td></tr>
<tr class="memdesc:ga4aa7e0fb9bd81e31214087d3d85367a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator string into distinct substrings.  <a href="group__tlx__string.html#ga4aa7e0fb9bd81e31214087d3d85367a3">More...</a><br/></td></tr>
<tr class="separator:ga4aa7e0fb9bd81e31214087d3d85367a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92d58b1e8b06cbb57400b5959281a4a1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga92d58b1e8b06cbb57400b5959281a4a1">split_words</a> (const std::string &amp;str, std::string::size_type limit=std::string::npos)</td></tr>
<tr class="memdesc:ga92d58b1e8b06cbb57400b5959281a4a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string by whitespaces into distinct words.  <a href="group__tlx__string.html#ga92d58b1e8b06cbb57400b5959281a4a1">More...</a><br/></td></tr>
<tr class="separator:ga92d58b1e8b06cbb57400b5959281a4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc5cce7e8c7fd30078b9129a7ae1d74b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gadc5cce7e8c7fd30078b9129a7ae1d74b">starts_with</a> (const std::string &amp;str, const std::string &amp;match)</td></tr>
<tr class="memdesc:gadc5cce7e8c7fd30078b9129a7ae1d74b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the start of this string.  <a href="group__tlx__string.html#gadc5cce7e8c7fd30078b9129a7ae1d74b">More...</a><br/></td></tr>
<tr class="separator:gadc5cce7e8c7fd30078b9129a7ae1d74b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga125efbe989d08402389613766af825b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga125efbe989d08402389613766af825b5">starts_with</a> (const std::string &amp;str, const char *match)</td></tr>
<tr class="memdesc:ga125efbe989d08402389613766af825b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the start of this string.  <a href="group__tlx__string.html#ga125efbe989d08402389613766af825b5">More...</a><br/></td></tr>
<tr class="separator:ga125efbe989d08402389613766af825b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbcdc1f2a056e954b197ce9c1d236522"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gadbcdc1f2a056e954b197ce9c1d236522">starts_with_icase</a> (const std::string &amp;str, const std::string &amp;match)</td></tr>
<tr class="memdesc:gadbcdc1f2a056e954b197ce9c1d236522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the start of this string.  <a href="group__tlx__string.html#gadbcdc1f2a056e954b197ce9c1d236522">More...</a><br/></td></tr>
<tr class="separator:gadbcdc1f2a056e954b197ce9c1d236522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6d169441d65d96bceb7c936e88afc67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gab6d169441d65d96bceb7c936e88afc67">starts_with_icase</a> (const std::string &amp;str, const char *match)</td></tr>
<tr class="memdesc:gab6d169441d65d96bceb7c936e88afc67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the start of this string.  <a href="group__tlx__string.html#gab6d169441d65d96bceb7c936e88afc67">More...</a><br/></td></tr>
<tr class="separator:gab6d169441d65d96bceb7c936e88afc67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1320658af9846df1831480a96e7a38"><td class="memTemplParams" colspan="2">template&lt;typename A , typename D &gt; </td></tr>
<tr class="memitem:ade1320658af9846df1831480a96e7a38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ade1320658af9846df1831480a96e7a38">swap</a> (<a class="el" href="classtlx_1_1CountingPtr.html">CountingPtr</a>&lt; A, D &gt; &amp;a1, <a class="el" href="classtlx_1_1CountingPtr.html">CountingPtr</a>&lt; A, D &gt; &amp;a2) noexcept</td></tr>
<tr class="separator:ade1320658af9846df1831480a96e7a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga355a332620f8220ecbb0dc5a0aa67350"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga355a332620f8220ecbb0dc5a0aa67350">to_lower</a> (char ch)</td></tr>
<tr class="memdesc:ga355a332620f8220ecbb0dc5a0aa67350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform the given character to lower case without any localization.  <a href="group__tlx__string.html#ga355a332620f8220ecbb0dc5a0aa67350">More...</a><br/></td></tr>
<tr class="separator:ga355a332620f8220ecbb0dc5a0aa67350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ec240b74b77e3ce42f8d67079dea430"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga4ec240b74b77e3ce42f8d67079dea430">to_lower</a> (std::string *str)</td></tr>
<tr class="memdesc:ga4ec240b74b77e3ce42f8d67079dea430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the given string to lowercase and returns a reference to it.  <a href="group__tlx__string.html#ga4ec240b74b77e3ce42f8d67079dea430">More...</a><br/></td></tr>
<tr class="separator:ga4ec240b74b77e3ce42f8d67079dea430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga647f5157d00473cf9bf37c92044bd9a8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga647f5157d00473cf9bf37c92044bd9a8">to_lower</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga647f5157d00473cf9bf37c92044bd9a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the given string converted to lowercase.  <a href="group__tlx__string.html#ga647f5157d00473cf9bf37c92044bd9a8">More...</a><br/></td></tr>
<tr class="separator:ga647f5157d00473cf9bf37c92044bd9a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa00b5d705507da8f74f1ba3874174d8d"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gaa00b5d705507da8f74f1ba3874174d8d">to_upper</a> (char ch)</td></tr>
<tr class="memdesc:gaa00b5d705507da8f74f1ba3874174d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform the given character to upper case without any localization.  <a href="group__tlx__string.html#gaa00b5d705507da8f74f1ba3874174d8d">More...</a><br/></td></tr>
<tr class="separator:gaa00b5d705507da8f74f1ba3874174d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d9edcc3303203825126d7d422e8ab75"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga7d9edcc3303203825126d7d422e8ab75">to_upper</a> (std::string *str)</td></tr>
<tr class="memdesc:ga7d9edcc3303203825126d7d422e8ab75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the given string to uppercase and returns a reference to it.  <a href="group__tlx__string.html#ga7d9edcc3303203825126d7d422e8ab75">More...</a><br/></td></tr>
<tr class="separator:ga7d9edcc3303203825126d7d422e8ab75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2be559f6e498862bec070f122feb6e14"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga2be559f6e498862bec070f122feb6e14">to_upper</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga2be559f6e498862bec070f122feb6e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the given string converted to uppercase.  <a href="group__tlx__string.html#ga2be559f6e498862bec070f122feb6e14">More...</a><br/></td></tr>
<tr class="separator:ga2be559f6e498862bec070f122feb6e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef21c8a44ad85b60cee80e66ae877b9a"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gaef21c8a44ad85b60cee80e66ae877b9a">trim</a> (std::string *str, const char *drop=&quot; \r\n\t&quot;)</td></tr>
<tr class="memdesc:gaef21c8a44ad85b60cee80e66ae877b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place on the left and right.  <a href="group__tlx__string.html#gaef21c8a44ad85b60cee80e66ae877b9a">More...</a><br/></td></tr>
<tr class="separator:gaef21c8a44ad85b60cee80e66ae877b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f5067eb83515704232300be374b2857"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga9f5067eb83515704232300be374b2857">trim</a> (std::string *str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:ga9f5067eb83515704232300be374b2857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place on the left and right.  <a href="group__tlx__string.html#ga9f5067eb83515704232300be374b2857">More...</a><br/></td></tr>
<tr class="separator:ga9f5067eb83515704232300be374b2857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6b44c87fe78e1d7479b7a4fff91cc2e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gac6b44c87fe78e1d7479b7a4fff91cc2e">trim</a> (const std::string &amp;str, const char *drop=&quot; \r\n\t&quot;)</td></tr>
<tr class="memdesc:gac6b44c87fe78e1d7479b7a4fff91cc2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place on the left and right.  <a href="group__tlx__string.html#gac6b44c87fe78e1d7479b7a4fff91cc2e">More...</a><br/></td></tr>
<tr class="separator:gac6b44c87fe78e1d7479b7a4fff91cc2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7aacbd967bfb76fcb4b4d977b4f5d838"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga7aacbd967bfb76fcb4b4d977b4f5d838">trim</a> (const std::string &amp;str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:ga7aacbd967bfb76fcb4b4d977b4f5d838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place on the left and right.  <a href="group__tlx__string.html#ga7aacbd967bfb76fcb4b4d977b4f5d838">More...</a><br/></td></tr>
<tr class="separator:ga7aacbd967bfb76fcb4b4d977b4f5d838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9990f13215dc89af47b26ed8f2d26c9e"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga9990f13215dc89af47b26ed8f2d26c9e">trim_left</a> (std::string *str, const char *drop=&quot; \r\n\t&quot;)</td></tr>
<tr class="memdesc:ga9990f13215dc89af47b26ed8f2d26c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place only on the left.  <a href="group__tlx__string.html#ga9990f13215dc89af47b26ed8f2d26c9e">More...</a><br/></td></tr>
<tr class="separator:ga9990f13215dc89af47b26ed8f2d26c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9db0b1db4ab3774221363c2fafa8bbdf"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga9db0b1db4ab3774221363c2fafa8bbdf">trim_left</a> (std::string *str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:ga9db0b1db4ab3774221363c2fafa8bbdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place only on the left.  <a href="group__tlx__string.html#ga9db0b1db4ab3774221363c2fafa8bbdf">More...</a><br/></td></tr>
<tr class="separator:ga9db0b1db4ab3774221363c2fafa8bbdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafaed624d011733264819eb39daae7d64"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gafaed624d011733264819eb39daae7d64">trim_left</a> (const std::string &amp;str, const char *drop=&quot; \r\n\t&quot;)</td></tr>
<tr class="memdesc:gafaed624d011733264819eb39daae7d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string only on the left.  <a href="group__tlx__string.html#gafaed624d011733264819eb39daae7d64">More...</a><br/></td></tr>
<tr class="separator:gafaed624d011733264819eb39daae7d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f870dbf0b1602d063de42caefde8b68"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga9f870dbf0b1602d063de42caefde8b68">trim_left</a> (const std::string &amp;str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:ga9f870dbf0b1602d063de42caefde8b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string only on the left.  <a href="group__tlx__string.html#ga9f870dbf0b1602d063de42caefde8b68">More...</a><br/></td></tr>
<tr class="separator:ga9f870dbf0b1602d063de42caefde8b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae59121dc9b7582edd903016d412bdb4b"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gae59121dc9b7582edd903016d412bdb4b">trim_right</a> (std::string *str, const char *drop=&quot; \r\n\t&quot;)</td></tr>
<tr class="memdesc:gae59121dc9b7582edd903016d412bdb4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place only on the right.  <a href="group__tlx__string.html#gae59121dc9b7582edd903016d412bdb4b">More...</a><br/></td></tr>
<tr class="separator:gae59121dc9b7582edd903016d412bdb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff5e9a8a1501b420ae5a5f8eca2a2f01"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gaff5e9a8a1501b420ae5a5f8eca2a2f01">trim_right</a> (std::string *str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:gaff5e9a8a1501b420ae5a5f8eca2a2f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place only on the right.  <a href="group__tlx__string.html#gaff5e9a8a1501b420ae5a5f8eca2a2f01">More...</a><br/></td></tr>
<tr class="separator:gaff5e9a8a1501b420ae5a5f8eca2a2f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75e734df783f6b4f70f75a8031d930aa"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga75e734df783f6b4f70f75a8031d930aa">trim_right</a> (const std::string &amp;str, const char *drop=&quot; \r\n\t&quot;)</td></tr>
<tr class="memdesc:ga75e734df783f6b4f70f75a8031d930aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string only on the right.  <a href="group__tlx__string.html#ga75e734df783f6b4f70f75a8031d930aa">More...</a><br/></td></tr>
<tr class="separator:ga75e734df783f6b4f70f75a8031d930aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b761b3a20c3f400f4f3451511016a07"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga4b761b3a20c3f400f4f3451511016a07">trim_right</a> (const std::string &amp;str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:ga4b761b3a20c3f400f4f3451511016a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string only on the right.  <a href="group__tlx__string.html#ga4b761b3a20c3f400f4f3451511016a07">More...</a><br/></td></tr>
<tr class="separator:ga4b761b3a20c3f400f4f3451511016a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39619db78c7e916bff3544fb07cbe462"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga39619db78c7e916bff3544fb07cbe462">union_words</a> (const std::string &amp;wordsA, const std::string &amp;wordsB)</td></tr>
<tr class="memdesc:ga39619db78c7e916bff3544fb07cbe462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return union of two keyword sets.  <a href="group__tlx__string.html#ga39619db78c7e916bff3544fb07cbe462">More...</a><br/></td></tr>
<tr class="separator:ga39619db78c7e916bff3544fb07cbe462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a63b398e6678264958fb8590e9332bf"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a5a63b398e6678264958fb8590e9332bf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a5a63b398e6678264958fb8590e9332bf">unused</a> (Types &amp;&amp;...)</td></tr>
<tr class="separator:a5a63b398e6678264958fb8590e9332bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44a90b0de44f0e1aa17ae215db35f458"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga44a90b0de44f0e1aa17ae215db35f458"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__meta.html#ga44a90b0de44f0e1aa17ae215db35f458">vexpand</a> (Types &amp;&amp;...)</td></tr>
<tr class="separator:ga44a90b0de44f0e1aa17ae215db35f458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a1c233e7ab713b8f8f77f7149f2bc4b"><td class="memTemplParams" colspan="2">template&lt;size_t Size, typename Functor &gt; </td></tr>
<tr class="memitem:ga4a1c233e7ab713b8f8f77f7149f2bc4b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__meta.html#ga4a1c233e7ab713b8f8f77f7149f2bc4b">vmap_for_range</a> (Functor &amp;&amp;f)</td></tr>
<tr class="memdesc:ga4a1c233e7ab713b8f8f77f7149f2bc4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vmap a generic functor (like a generic lambda) for the integers [0,Size).  <a href="group__tlx__meta.html#ga4a1c233e7ab713b8f8f77f7149f2bc4b">More...</a><br/></td></tr>
<tr class="separator:ga4a1c233e7ab713b8f8f77f7149f2bc4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36807642146dd614b63d26ed6bba9c19"><td class="memTemplParams" colspan="2">template&lt;size_t Begin, size_t End, typename Functor &gt; </td></tr>
<tr class="memitem:ga36807642146dd614b63d26ed6bba9c19"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__meta.html#ga36807642146dd614b63d26ed6bba9c19">vmap_for_range</a> (Functor &amp;&amp;f)</td></tr>
<tr class="memdesc:ga36807642146dd614b63d26ed6bba9c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vmap a generic functor (like a generic lambda) for the integers [Begin,End).  <a href="group__tlx__meta.html#ga36807642146dd614b63d26ed6bba9c19">More...</a><br/></td></tr>
<tr class="separator:ga36807642146dd614b63d26ed6bba9c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf379571cbffcf0273d0203ef53bca2b8"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:gaf379571cbffcf0273d0203ef53bca2b8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__meta.html#gaf379571cbffcf0273d0203ef53bca2b8">vmap_foreach</a> (Functor &amp;&amp;f, Args &amp;&amp;...args)</td></tr>
<tr class="separator:gaf379571cbffcf0273d0203ef53bca2b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a5c01183e4cc91ffbec284e8bd9437e"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:ga1a5c01183e4cc91ffbec284e8bd9437e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__meta.html#ga1a5c01183e4cc91ffbec284e8bd9437e">vmap_foreach_with_index</a> (Functor &amp;&amp;f, Args &amp;&amp;...args)</td></tr>
<tr class="separator:ga1a5c01183e4cc91ffbec284e8bd9437e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d0ada76ddce7fc09d770fa512780839"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga2d0ada76ddce7fc09d770fa512780839">word_wrap</a> (const std::string &amp;str, unsigned int wrap=80)</td></tr>
<tr class="memdesc:ga2d0ada76ddce7fc09d770fa512780839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to wrap a string to 80 columns without split words.  <a href="group__tlx__string.html#ga2d0ada76ddce7fc09d770fa512780839">More...</a><br/></td></tr>
<tr class="separator:ga2d0ada76ddce7fc09d770fa512780839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Base64 Encoding and Decoding</div></td></tr>
<tr class="memitem:ga691477f59c8496eec65e994ce3f6e6e5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga691477f59c8496eec65e994ce3f6e6e5">base64_encode</a> (const void *data, size_t size, size_t line_break=0)</td></tr>
<tr class="memdesc:ga691477f59c8496eec65e994ce3f6e6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode the given binary data into base64 representation as described in RFC 2045 or RFC 3548.  <a href="group__tlx__string.html#ga691477f59c8496eec65e994ce3f6e6e5">More...</a><br/></td></tr>
<tr class="separator:ga691477f59c8496eec65e994ce3f6e6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16a12f591febaeddffd2ffca031c8bf4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga16a12f591febaeddffd2ffca031c8bf4">base64_encode</a> (const std::string &amp;str, size_t line_break=0)</td></tr>
<tr class="memdesc:ga16a12f591febaeddffd2ffca031c8bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode the given binary string into base64 representation as described in RFC 2045 or RFC 3548.  <a href="group__tlx__string.html#ga16a12f591febaeddffd2ffca031c8bf4">More...</a><br/></td></tr>
<tr class="separator:ga16a12f591febaeddffd2ffca031c8bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2775fbea220f27325aba0f8af1cc9a8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gac2775fbea220f27325aba0f8af1cc9a8">base64_decode</a> (const void *data, size_t size, bool strict=true)</td></tr>
<tr class="memdesc:gac2775fbea220f27325aba0f8af1cc9a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a string in base64 representation as described in RFC 2045 or RFC 3548 and return the original data.  <a href="group__tlx__string.html#gac2775fbea220f27325aba0f8af1cc9a8">More...</a><br/></td></tr>
<tr class="separator:gac2775fbea220f27325aba0f8af1cc9a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe1e973cd3a2d5b7e55544d4c616da49"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gabe1e973cd3a2d5b7e55544d4c616da49">base64_decode</a> (const std::string &amp;str, bool strict=true)</td></tr>
<tr class="memdesc:gabe1e973cd3a2d5b7e55544d4c616da49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a string in base64 representation as described in RFC 2045 or RFC 3548 and return the original data.  <a href="group__tlx__string.html#gabe1e973cd3a2d5b7e55544d4c616da49">More...</a><br/></td></tr>
<tr class="separator:gabe1e973cd3a2d5b7e55544d4c616da49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Hexdump Methods</div></td></tr>
<tr class="memitem:gab4c0ada9ff7b0d905361e60050316899"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gab4c0ada9ff7b0d905361e60050316899">hexdump</a> (const void *const data, size_t size)</td></tr>
<tr class="memdesc:gab4c0ada9ff7b0d905361e60050316899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) string as a sequence of uppercase hexadecimal pairs.  <a href="group__tlx__string.html#gab4c0ada9ff7b0d905361e60050316899">More...</a><br/></td></tr>
<tr class="separator:gab4c0ada9ff7b0d905361e60050316899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0757bf9871dc4e2526ab48e4cde28e1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gaa0757bf9871dc4e2526ab48e4cde28e1">hexdump</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:gaa0757bf9871dc4e2526ab48e4cde28e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) string as a sequence of uppercase hexadecimal pairs.  <a href="group__tlx__string.html#gaa0757bf9871dc4e2526ab48e4cde28e1">More...</a><br/></td></tr>
<tr class="separator:gaa0757bf9871dc4e2526ab48e4cde28e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15c83e3e2055412b0440758c98b3f148"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga15c83e3e2055412b0440758c98b3f148">hexdump</a> (const std::vector&lt; char &gt; &amp;data)</td></tr>
<tr class="memdesc:ga15c83e3e2055412b0440758c98b3f148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a char vector as a sequence of uppercase hexadecimal pairs.  <a href="group__tlx__string.html#ga15c83e3e2055412b0440758c98b3f148">More...</a><br/></td></tr>
<tr class="separator:ga15c83e3e2055412b0440758c98b3f148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c6446ce9a61a434b3a10345cbf3ebed"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga6c6446ce9a61a434b3a10345cbf3ebed">hexdump</a> (const std::vector&lt; uint8_t &gt; &amp;data)</td></tr>
<tr class="memdesc:ga6c6446ce9a61a434b3a10345cbf3ebed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a uint8_t vector as a sequence of uppercase hexadecimal pairs.  <a href="group__tlx__string.html#ga6c6446ce9a61a434b3a10345cbf3ebed">More...</a><br/></td></tr>
<tr class="separator:ga6c6446ce9a61a434b3a10345cbf3ebed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab10f91fa3b24c787e4e0d88c009ac298"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gab10f91fa3b24c787e4e0d88c009ac298">hexdump_sourcecode</a> (const std::string &amp;str, const std::string &amp;var_name=&quot;name&quot;)</td></tr>
<tr class="memdesc:gab10f91fa3b24c787e4e0d88c009ac298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) string into a C source code snippet.  <a href="group__tlx__string.html#gab10f91fa3b24c787e4e0d88c009ac298">More...</a><br/></td></tr>
<tr class="separator:gab10f91fa3b24c787e4e0d88c009ac298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c47a216e0abcdf9a88fc50bb79c98ba"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga0c47a216e0abcdf9a88fc50bb79c98ba">hexdump_lc</a> (const void *const data, size_t size)</td></tr>
<tr class="memdesc:ga0c47a216e0abcdf9a88fc50bb79c98ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) string as a sequence of lowercase hexadecimal pairs.  <a href="group__tlx__string.html#ga0c47a216e0abcdf9a88fc50bb79c98ba">More...</a><br/></td></tr>
<tr class="separator:ga0c47a216e0abcdf9a88fc50bb79c98ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60e8912db4511738cfdbf3e97ff6dbbf"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga60e8912db4511738cfdbf3e97ff6dbbf">hexdump_lc</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga60e8912db4511738cfdbf3e97ff6dbbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) string as a sequence of lowercase hexadecimal pairs.  <a href="group__tlx__string.html#ga60e8912db4511738cfdbf3e97ff6dbbf">More...</a><br/></td></tr>
<tr class="separator:ga60e8912db4511738cfdbf3e97ff6dbbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae749cedcfc25af4f829d70e8febba7a1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gae749cedcfc25af4f829d70e8febba7a1">hexdump_lc</a> (const std::vector&lt; char &gt; &amp;data)</td></tr>
<tr class="memdesc:gae749cedcfc25af4f829d70e8febba7a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a char vector as a sequence of lowercase hexadecimal pairs.  <a href="group__tlx__string.html#gae749cedcfc25af4f829d70e8febba7a1">More...</a><br/></td></tr>
<tr class="separator:gae749cedcfc25af4f829d70e8febba7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b35bd68e5974e78327fce13e0e2eaf6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga0b35bd68e5974e78327fce13e0e2eaf6">hexdump_lc</a> (const std::vector&lt; uint8_t &gt; &amp;data)</td></tr>
<tr class="memdesc:ga0b35bd68e5974e78327fce13e0e2eaf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a uint8_t vector as a sequence of lowercase hexadecimal pairs.  <a href="group__tlx__string.html#ga0b35bd68e5974e78327fce13e0e2eaf6">More...</a><br/></td></tr>
<tr class="separator:ga0b35bd68e5974e78327fce13e0e2eaf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81809bc5e0b69034f39659303baa4bf9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga81809bc5e0b69034f39659303baa4bf9">parse_hexdump</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga81809bc5e0b69034f39659303baa4bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a string as a sequence of hexadecimal pairs.  <a href="group__tlx__string.html#ga81809bc5e0b69034f39659303baa4bf9">More...</a><br/></td></tr>
<tr class="separator:ga81809bc5e0b69034f39659303baa4bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2a485134f5e618b846abb630d44ec6f"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:gae2a485134f5e618b846abb630d44ec6f"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gae2a485134f5e618b846abb630d44ec6f">hexdump_type</a> (const Type &amp;t)</td></tr>
<tr class="memdesc:gae2a485134f5e618b846abb630d44ec6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) item as a sequence of uppercase hexadecimal pairs.  <a href="group__tlx__string.html#gae2a485134f5e618b846abb630d44ec6f">More...</a><br/></td></tr>
<tr class="separator:gae2a485134f5e618b846abb630d44ec6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b2f444830d8f7b1b0eaf93b5f514bf7"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ga0b2f444830d8f7b1b0eaf93b5f514bf7"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga0b2f444830d8f7b1b0eaf93b5f514bf7">hexdump_lc_type</a> (const Type &amp;t)</td></tr>
<tr class="memdesc:ga0b2f444830d8f7b1b0eaf93b5f514bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) item as a sequence of lowercase hexadecimal pairs.  <a href="group__tlx__string.html#ga0b2f444830d8f7b1b0eaf93b5f514bf7">More...</a><br/></td></tr>
<tr class="separator:ga0b2f444830d8f7b1b0eaf93b5f514bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac57ddd8d5c4eebe0f8a5d889b29c8823"><td class="memItemLeft" align="right" valign="top">static std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ac57ddd8d5c4eebe0f8a5d889b29c8823">s_logger_mutex</a></td></tr>
<tr class="memdesc:ac57ddd8d5c4eebe0f8a5d889b29c8823"><td class="mdescLeft">&#160;</td><td class="mdescRight">mutex for log output  <a href="#ac57ddd8d5c4eebe0f8a5d889b29c8823">More...</a><br/></td></tr>
<tr class="separator:ac57ddd8d5c4eebe0f8a5d889b29c8823"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a2c4e023d82bca2172da2f965e3b42b40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetlx.html#a2c4e023d82bca2172da2f965e3b42b40">counting_ptr</a> =  <a class="el" href="classtlx_1_1CountingPtr.html">CountingPtr</a>&lt;Type&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>make alias due to similarity with std::shared_ptr&lt;T&gt; </p>

<p>Definition at line <a class="el" href="counting__ptr_8hpp_source.html#l00248">248</a> of file <a class="el" href="counting__ptr_8hpp_source.html">counting_ptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9d28f4e50fa9fc359c658b0911ce06b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetlx.html#a9d28f4e50fa9fc359c658b0911ce06b8">CountingPtrNoDelete</a> =  <a class="el" href="classtlx_1_1CountingPtr.html">CountingPtr</a>&lt;Type, <a class="el" href="classtlx_1_1CountingPtrNoOperationDeleter.html">CountingPtrNoOperationDeleter</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>make alias for dummy deleter </p>

<p>Definition at line <a class="el" href="counting__ptr_8hpp_source.html#l00252">252</a> of file <a class="el" href="counting__ptr_8hpp_source.html">counting_ptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afacc9643f535d390fd0ead73790a6d56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetlx.html#afacc9643f535d390fd0ead73790a6d56">delegate</a> =  <a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&lt;<a class="el" href="logistic__regression_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a>, Allocator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>make template alias due to similarity with std::function </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00426">426</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4a89ad01492580f7cf07d93a99539cf5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetlx.html#a4a89ad01492580f7cf07d93a99539cf5">reference_counter</a> =  <a class="el" href="classtlx_1_1ReferenceCounter.html">ReferenceCounter</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>make alias due to <a class="el" href="classtlx_1_1CountingPtr.html" title="High-performance smart pointer used as a wrapping reference counting pointer. ">CountingPtr</a>'s similarity with std::shared_ptr&lt;T&gt; </p>

<p>Definition at line <a class="el" href="counting__ptr_8hpp_source.html#l00332">332</a> of file <a class="el" href="counting__ptr_8hpp_source.html">counting_ptr.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a9f8179e15f255f7283de043a22560c25"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::die_equal_compare </td>
          <td>(</td>
          <td class="paramtype">TypeA&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeB&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helper method to compare two values in <a class="el" href="die_8hpp.html#a334b021076c0dff0e3964c6819774ceb">die_unequal()</a> </p>

<p>Definition at line <a class="el" href="die_8hpp_source.html#l00075">75</a> of file <a class="el" href="die_8hpp_source.html">die.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac37c2fc10d396b6a0038eb2d643d1360"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::die_equal_compare </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="die_8hpp_source.html#l00080">80</a> of file <a class="el" href="die_8hpp_source.html">die.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6834365ccbbe0995d597d91cb16ac05c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::die_equal_compare </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="die_8hpp_source.html#l00086">86</a> of file <a class="el" href="die_8hpp_source.html">die.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac215c9815621e2ebbc07da9be07a622f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::die_equal_compare </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="die_8hpp_source.html#l00092">92</a> of file <a class="el" href="die_8hpp_source.html">die.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1a4f198a88970a7cb1f5d8d3a0555b79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void die_with_message </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>die with message - either throw an exception or die via abort() </p>

<p>Definition at line <a class="el" href="die_8cpp_source.html#l00018">18</a> of file <a class="el" href="die_8cpp_source.html">die.cpp</a>.</p>

<p>Referenced by <a class="el" href="die_8cpp_source.html#l00023">die_with_message()</a>.</p>

</div>
</div>
<a class="anchor" id="a1972bdbc5b9ff146cf88d18ec9a12d64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void die_with_message </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>die with message - either throw an exception or die via abort() </p>

<p>Definition at line <a class="el" href="die_8cpp_source.html#l00023">23</a> of file <a class="el" href="die_8cpp_source.html">die.cpp</a>.</p>

<p>References <a class="el" href="die_8cpp_source.html#l00018">die_with_message()</a>.</p>

</div>
</div>
<a class="anchor" id="acf7bff2d67e5ed89bd9dc6bea904e1c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void die_with_message </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>die with message - either throw an exception or die via abort() </p>

<p>Definition at line <a class="el" href="die_8cpp_source.html#l00029">29</a> of file <a class="el" href="die_8cpp_source.html">die.cpp</a>.</p>

<p>References <a class="el" href="die_8cpp_source.html#l00018">die_with_message()</a>.</p>

</div>
</div>
<a class="anchor" id="a536ac2439a4b7a17a0e089c443249e67"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string tlx::extract_between_template </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Separator1 &amp;&#160;</td>
          <td class="paramname"><em>sep1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sep1_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Separator2 &amp;&#160;</td>
          <td class="paramname"><em>sep2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="extract__between_8cpp_source.html#l00019">19</a> of file <a class="el" href="extract__between_8cpp_source.html">extract_between.cpp</a>.</p>

<p>Referenced by <a class="el" href="extract__between_8cpp_source.html#l00037">extract_between()</a>.</p>

</div>
</div>
<a class="anchor" id="a819e2d0d244166deaf699dbd962dfc4c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned tlx::integer_log2_floor_template </td>
          <td>(</td>
          <td class="paramtype">IntegerType&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="integer__log2_8cpp_source.html#l00016">16</a> of file <a class="el" href="integer__log2_8cpp_source.html">integer_log2.cpp</a>.</p>

<p>Referenced by <a class="el" href="integer__log2_8cpp_source.html#l00026">integer_log2_floor()</a>.</p>

</div>
</div>
<a class="anchor" id="a6bd0c156caa682f81c584b29f1d62104"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool tlx::is_power_of_two_template </td>
          <td>(</td>
          <td class="paramtype">Integral&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="is__power__of__two_8cpp_source.html#l00016">16</a> of file <a class="el" href="is__power__of__two_8cpp_source.html">is_power_of_two.cpp</a>.</p>

<p>Referenced by <a class="el" href="is__power__of__two_8cpp_source.html#l00023">is_power_of_two()</a>.</p>

</div>
</div>
<a class="anchor" id="aced5355a13aebabfa68ca4100e507e83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::is_space </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="word__wrap_8cpp_source.html#l00017">17</a> of file <a class="el" href="word__wrap_8cpp_source.html">word_wrap.cpp</a>.</p>

<p>Referenced by <a class="el" href="word__wrap_8cpp_source.html#l00022">word_wrap()</a>.</p>

</div>
</div>
<a class="anchor" id="a7aebcd1b9a6ce6667c8bbcab36aeaadb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool tlx::is_white </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="contains__word_8cpp_source.html#l00015">15</a> of file <a class="el" href="contains__word_8cpp_source.html">contains_word.cpp</a>.</p>

<p>Referenced by <a class="el" href="contains__word_8cpp_source.html#l00019">contains_word()</a>.</p>

</div>
</div>
<a class="anchor" id="ae38d352a065543cf324f52a58bd2b026"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1CountingPtr.html">CountingPtr</a>&lt;Type&gt; tlx::make_counting </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>method analogous to std::make_shared and std::make_unique. </p>

<p>Definition at line <a class="el" href="counting__ptr_8hpp_source.html#l00256">256</a> of file <a class="el" href="counting__ptr_8hpp_source.html">counting_ptr.hpp</a>.</p>

<p>Referenced by <a class="el" href="dyn__block__reader_8hpp_source.html#l00111">thrill::data::ConstructDynBlockSource()</a>.</p>

</div>
</div>
<a class="anchor" id="abac208faa35171eb6016cf9730ed83f3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&lt; R(A...)&gt; make_delegate </td>
          <td>(</td>
          <td class="paramtype">C *const&#160;</td>
          <td class="paramname"><em>object_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(C::*)(A...)&#160;</td>
          <td class="paramname"><em>method_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor for wrapping a class::method with object pointer. </p>
<p>constructor for wrapping a const class::method with object pointer. </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00431">431</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a36e57fc132415d92776d9eed01ae3442"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&lt;R(A...)&gt; tlx::make_delegate </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>object_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(C::*)(A...)&#160;</td>
          <td class="paramname"><em>method_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor for wrapping a class::method with object reference. </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00447">447</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaf10f085647ba34ff677aeecba994064"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&lt;R(A...)&gt; tlx::make_delegate </td>
          <td>(</td>
          <td class="paramtype">C const &amp;&#160;</td>
          <td class="paramname"><em>object_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(C::*)(A...) const&#160;</td>
          <td class="paramname"><em>method_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor for wrapping a const class::method with object reference. </p>

<p>Definition at line <a class="el" href="delegate_8hpp_source.html#l00455">455</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a571b1c19ce4d530c4aaa3cd797c8ccae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; tlx::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CountingPtr&lt; A, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>print pointer </p>

<p>Definition at line <a class="el" href="counting__ptr_8hpp_source.html#l00269">269</a> of file <a class="el" href="counting__ptr_8hpp_source.html">counting_ptr.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a165140a3f756701491e3958c9858ea2c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static Integral tlx::round_up_to_power_of_two_template </td>
          <td>(</td>
          <td class="paramtype">Integral&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="round__to__power__of__two_8cpp_source.html#l00018">18</a> of file <a class="el" href="round__to__power__of__two_8cpp_source.html">round_to_power_of_two.cpp</a>.</p>

<p>Referenced by <a class="el" href="round__to__power__of__two_8cpp_source.html#l00029">round_up_to_power_of_two()</a>.</p>

</div>
</div>
<a class="anchor" id="ac377d7abe96391a306d74f49c1f92ab0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t tlx::siphash </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>key</em>[16], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="siphash_8hpp_source.html#l00242">242</a> of file <a class="el" href="siphash_8hpp_source.html">siphash.hpp</a>.</p>

<p>References <a class="el" href="siphash_8hpp_source.html#l00045">siphash_plain()</a>.</p>

<p>Referenced by <a class="el" href="core_2hyperloglog_8hpp_source.html#l00047">HyperLogLogRegisters&lt; p &gt;::insert()</a>, and <a class="el" href="siphash_8hpp_source.html#l00251">siphash()</a>.</p>

</div>
</div>
<a class="anchor" id="ab5b74a8ec4e849ee19578715c65836ab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t tlx::siphash </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="siphash_8hpp_source.html#l00251">251</a> of file <a class="el" href="siphash_8hpp_source.html">siphash.hpp</a>.</p>

<p>References <a class="el" href="siphash_8hpp_source.html#l00242">siphash()</a>.</p>

</div>
</div>
<a class="anchor" id="a36e52665aa49af074f344396ad6264f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t tlx::siphash </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="siphash_8hpp_source.html#l00260">260</a> of file <a class="el" href="siphash_8hpp_source.html">siphash.hpp</a>.</p>

<p>References <a class="el" href="siphash_8hpp_source.html#l00242">siphash()</a>.</p>

</div>
</div>
<a class="anchor" id="a1dbb7e10c5e866474d0a516ba06388f8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t tlx::siphash_plain </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>key</em>[16], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="siphash_8hpp_source.html#l00045">45</a> of file <a class="el" href="siphash_8hpp_source.html">siphash.hpp</a>.</p>

<p>References <a class="el" href="siphash_8hpp.html#a0388d30a5a74a4ec9c9f289e5152a4b0">sipcompress</a>, and <a class="el" href="attribute__fallthrough_8hpp_source.html#l00024">TLX_ATTRIBUTE_FALLTHROUGH</a>.</p>

<p>Referenced by <a class="el" href="siphash_8hpp_source.html#l00242">siphash()</a>.</p>

</div>
</div>
<a class="anchor" id="ae88597e53210df27ef4d5db668a02fa7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;std::string&gt;&amp; tlx::split </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; *&#160;</td>
          <td class="paramname"><em>into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sep_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="split_8cpp_source.html#l00107">107</a> of file <a class="el" href="split_8cpp_source.html">split.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ade1320658af9846df1831480a96e7a38"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tlx::swap </td>
          <td>(</td>
          <td class="paramtype">CountingPtr&lt; A, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CountingPtr&lt; A, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>swap enclosed object with another counting pointer (no reference counts need change) </p>

<p>Definition at line <a class="el" href="counting__ptr_8hpp_source.html#l00263">263</a> of file <a class="el" href="counting__ptr_8hpp_source.html">counting_ptr.hpp</a>.</p>

<p>Referenced by <a class="el" href="inner__join_8hpp_source.html#l00381">JoinNode&lt; ValueType, FirstDIA, SecondDIA, KeyExtractor1, KeyExtractor2, JoinFunction, HashFunction, UseLocationDetection &gt;::AddEqualKeysToVec()</a>, <a class="el" href="file_8cpp_source.html#l00057">File::Clear()</a>, <a class="el" href="loser__tree_8hpp_source.html#l00192">LoserTreeCopy&lt; Stable, ValueType, Comparator &gt;::delete_min_insert()</a>, <a class="el" href="loser__tree_8hpp_source.html#l00259">LoserTreeCopy&lt; true, ValueType, Comparator &gt;::delete_min_insert()</a>, <a class="el" href="loser__tree_8hpp_source.html#l00421">LoserTreePointer&lt; Stable, ValueType, Comparator &gt;::delete_min_insert()</a>, <a class="el" href="loser__tree_8hpp_source.html#l00481">LoserTreePointer&lt; true, ValueType, Comparator &gt;::delete_min_insert()</a>, <a class="el" href="loser__tree_8hpp_source.html#l00611">LoserTreeCopyUnguarded&lt; Stable, ValueType, Comparator &gt;::delete_min_insert()</a>, <a class="el" href="loser__tree_8hpp_source.html#l00652">LoserTreeCopyUnguarded&lt; true, ValueType, Comparator &gt;::delete_min_insert()</a>, <a class="el" href="loser__tree_8hpp_source.html#l00780">LoserTreePointerUnguarded&lt; Stable, ValueType, Comparator &gt;::delete_min_insert()</a>, <a class="el" href="loser__tree_8hpp_source.html#l00818">LoserTreePointerUnguarded&lt; true, ValueType, Comparator &gt;::delete_min_insert()</a>, <a class="el" href="concat__to__dia_8hpp_source.html#l00052">ConcatToDIANode&lt; ValueType &gt;::Dispose()</a>, <a class="el" href="equal__to__dia_8hpp_source.html#l00054">EqualToDIANode&lt; ValueType &gt;::Dispose()</a>, <a class="el" href="distribute_8hpp_source.html#l00082">DistributeNode&lt; ValueType &gt;::Dispose()</a>, <a class="el" href="reduce__table_8hpp_source.html#l00150">ReduceTable&lt; TableItem, Key, Value, KeyExtractor, ReduceFunction, Emitter, VolatileKey, ReduceConfig_, IndexFunction, KeyEqualFunction &gt;::Dispose()</a>, <a class="el" href="reduce__by__index__post__phase_8hpp_source.html#l00197">ReduceByIndexPostPhase&lt; TableItem, Key, ValueType, KeyExtractor, ReduceFunction, thrill::api::ReduceToIndexNode::Emitter, VolatileKey, ReduceConfig &gt;::Dispose()</a>, <a class="el" href="reduce__old__probing__hash__table_8hpp_source.html#l00253">ReduceOldProbingHashTable&lt; TableItem, Key, Value, KeyExtractor, ReduceFunction, Emitter, VolatileKey, ReduceConfig_, IndexFunction, KeyEqualFunction &gt;::Dispose()</a>, <a class="el" href="reduce__bucket__hash__table_8hpp_source.html#l00334">ReduceBucketHashTable&lt; TableItem, Key, Value, KeyExtractor, ReduceFunction, Emitter, VolatileKey, ReduceConfig, IndexFunction, KeyEqualFunction &gt;::Dispose()</a>, <a class="el" href="location__detection_8hpp_source.html#l00358">LocationDetection&lt; thrill::api::JoinNode::HashCount &gt;::Dispose()</a>, <a class="el" href="binary__heap_8hpp_source.html#l00079">BinaryHeap&lt; Timer &gt;::erase()</a>, <a class="el" href="location__detection_8hpp_source.html#l00192">LocationDetection&lt; thrill::api::JoinNode::HashCount &gt;::Flush()</a>, <a class="el" href="qsort_8hpp_source.html#l00113">thrill::common::qsort_local::InsertionSort()</a>, <a class="el" href="group__to__index_8hpp_source.html#l00233">GroupToIndexNode&lt; ValueType, KeyExtractor, GroupFunction &gt;::MainOp()</a>, <a class="el" href="group__by__key_8hpp_source.html#l00341">GroupByNode&lt; ValueType, KeyExtractor, GroupFunction, HashFunction, UseLocationDetection &gt;::MainOp()</a>, <a class="el" href="sort_8hpp_source.html#l00541">SortNode&lt; ValueType, CompareFunction, SortAlgorithm &gt;::MainOp()</a>, <a class="el" href="binary__heap_8hpp_source.html#l00173">BinaryHeap&lt; Timer &gt;::pop_heap()</a>, <a class="el" href="qsort_8hpp_source.html#l00244">thrill::common::qsort_three_pivots()</a>, <a class="el" href="qsort_8hpp_source.html#l00186">thrill::common::qsort_two_pivots_yaroslavskiy()</a>, <a class="el" href="radix__sort_8hpp_source.html#l00037">thrill::common::radix_sort_CI()</a>, <a class="el" href="qsort_8hpp_source.html#l00051">thrill::common::qsort_local::sort3()</a>, <a class="el" href="qsort_8hpp_source.html#l00076">thrill::common::qsort_local::sort4()</a>, <a class="el" href="qsort_8hpp_source.html#l00093">thrill::common::qsort_local::sort5()</a>, <a class="el" href="thrill_2common_2math_8hpp_source.html#l00065">Range::Swap()</a>, <a class="el" href="simple__vector_8hpp_source.html#l00104">SimpleVector&lt; std::thread &gt;::swap()</a>, <a class="el" href="counting__ptr_8hpp_source.html#l00242">CountingPtr&lt; FileBase &gt;::swap()</a>, <a class="el" href="delegate_8hpp_source.html#l00266">Delegate&lt; R(A...), Allocator &gt;::swap()</a>, and <a class="el" href="sort_8hpp_source.html#l00435">SortNode&lt; ValueType, CompareFunction, SortAlgorithm &gt;::TransmitItems()</a>.</p>

</div>
</div>
<a class="anchor" id="a5a63b398e6678264958fb8590e9332bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tlx::unused </td>
          <td>(</td>
          <td class="paramtype">Types &amp;&amp;&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="unused_8hpp_source.html#l00020">20</a> of file <a class="el" href="unused_8hpp_source.html">unused.hpp</a>.</p>

<p>Referenced by <a class="el" href="loser__tree_8hpp_source.html#l00421">LoserTreePointer&lt; Stable, ValueType, Comparator &gt;::delete_min_insert()</a>, <a class="el" href="loser__tree_8hpp_source.html#l00481">LoserTreePointer&lt; true, ValueType, Comparator &gt;::delete_min_insert()</a>, <a class="el" href="loser__tree_8hpp_source.html#l00611">LoserTreeCopyUnguarded&lt; Stable, ValueType, Comparator &gt;::delete_min_insert()</a>, <a class="el" href="loser__tree_8hpp_source.html#l00652">LoserTreeCopyUnguarded&lt; true, ValueType, Comparator &gt;::delete_min_insert()</a>, <a class="el" href="loser__tree_8hpp_source.html#l00780">LoserTreePointerUnguarded&lt; Stable, ValueType, Comparator &gt;::delete_min_insert()</a>, <a class="el" href="loser__tree_8hpp_source.html#l00818">LoserTreePointerUnguarded&lt; true, ValueType, Comparator &gt;::delete_min_insert()</a>, <a class="el" href="memory__file_8cpp_source.html#l00067">MemoryFile::discard()</a>, <a class="el" href="file__base_8hpp_source.html#l00152">FileBase::discard()</a>, <a class="el" href="reduce__by__index__post__phase_8hpp_source.html#l00102">ReduceByIndexPostPhase&lt; TableItem, Key, ValueType, KeyExtractor, ReduceFunction, thrill::api::ReduceToIndexNode::Emitter, VolatileKey, ReduceConfig &gt;::Insert()</a>, <a class="el" href="loser__tree_8hpp_source.html#l00356">LoserTreePointerBase&lt; ValueType, Comparator &gt;::insert_start()</a>, <a class="el" href="loser__tree_8hpp_source.html#l00561">LoserTreeCopyUnguardedBase&lt; ValueType, Comparator &gt;::insert_start()</a>, <a class="el" href="loser__tree_8hpp_source.html#l00731">LoserTreePointerUnguardedBase&lt; ValueType, Comparator &gt;::insert_start()</a>, <a class="el" href="porting_8cpp_source.html#l00067">thrill::common::LogCmdlineParams()</a>, <a class="el" href="k-means__run_8cpp_source.html#l00048">OutputSVG()</a>, <a class="el" href="porting_8cpp_source.html#l00041">thrill::common::PortSetCloseOnExec()</a>, <a class="el" href="iostats_8cpp_source.html#l00099">Stats::read_started()</a>, <a class="el" href="reduce__pre__phase_8hpp_source.html#l00130">ReducePrePhase&lt; TableItem, Key, Value, KeyExtractor, ReduceFunction, VolatileKey, BlockWriter, ReduceConfig_, IndexFunction, KeyEqualFunction, HashFunction, false &gt;::ReducePrePhase()</a>, <a class="el" href="request__queue__impl__1q_8cpp_source.html#l00038">RequestQueueImpl1Q::RequestQueueImpl1Q()</a>, <a class="el" href="request__queue__impl__qw__qr_8cpp_source.html#l00037">RequestQueueImplQwQr::RequestQueueImplQwQr()</a>, <a class="el" href="iostats_8hpp_source.html#l00205">Stats::ScopedWaitTimer::ScopedWaitTimer()</a>, <a class="el" href="porting_8cpp_source.html#l00110">thrill::common::SetCpuAffinity()</a>, <a class="el" href="request__queue_8hpp_source.html#l00049">RequestQueue::SetPriorityOp()</a>, <a class="el" href="request__queue__impl__1q_8hpp_source.html#l00057">RequestQueueImpl1Q::SetPriorityOp()</a>, <a class="el" href="request__queue__impl__qw__qr_8hpp_source.html#l00064">RequestQueueImplQwQr::SetPriorityOp()</a>, and <a class="el" href="iostats_8cpp_source.html#l00031">Stats::write_started()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="ac57ddd8d5c4eebe0f8a5d889b29c8823"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex s_logger_mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>mutex for log output </p>

<p>Definition at line <a class="el" href="extlib_2tlx_2tlx_2logger_8cpp_source.html#l00024">24</a> of file <a class="el" href="extlib_2tlx_2tlx_2logger_8cpp_source.html">logger.cpp</a>.</p>

<p>Referenced by <a class="el" href="extlib_2tlx_2tlx_2logger_8cpp_source.html#l00026">Logger::Output()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacetlx.html">tlx</a></li>
    <li class="footer">Generated on Fri Oct 27 2017 09:23:37 for Thrill by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
