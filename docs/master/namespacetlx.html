<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Thrill: tlx Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Thrill
   &#160;<span id="projectnumber">0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespacetlx.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">tlx Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetlx_1_1digest__detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx_1_1digest__detail.html">digest_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetlx_1_1meta__detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx_1_1meta__detail.html">meta_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetlx_1_1multisequence__partition__detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx_1_1multisequence__partition__detail.html">multisequence_partition_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetlx_1_1multisequence__selection__detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx_1_1multisequence__selection__detail.html">multisequence_selection_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetlx_1_1multiway__merge__detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx_1_1multiway__merge__detail.html">multiway_merge_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetlx_1_1parallel__mergesort__detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx_1_1parallel__mergesort__detail.html">parallel_mergesort_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetlx_1_1radix__heap__detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx_1_1radix__heap__detail.html">radix_heap_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetlx_1_1sort__strings__detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx_1_1sort__strings__detail.html">sort_strings_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Aggregate.html">Aggregate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate running aggregate statistics: feed it with values, and it will keep the minimum, the maximum, the average, the value number, and the standard deviation is values.  <a href="classtlx_1_1Aggregate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1AggregateMinMax.html">AggregateMinMax</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate running aggregate statistics: feed it with values, and it will keep the minimum and the maximum values.  <a href="classtlx_1_1AggregateMinMax.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1AllocatorBase.html">AllocatorBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html">BTree</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic class implementing a B+ tree data structure in memory.  <a href="classtlx_1_1BTree.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1btree__default__traits.html">btree_default_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates default traits for a B+ tree used as a set or map.  <a href="structtlx_1_1btree__default__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1btree__map.html">btree_map</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized B+ tree template class implementing STL's map container.  <a href="classtlx_1_1btree__map.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1btree__multimap.html">btree_multimap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized B+ tree template class implementing STL's multimap container.  <a href="classtlx_1_1btree__multimap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1btree__multiset.html">btree_multiset</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized B+ tree template class implementing STL's multiset container.  <a href="classtlx_1_1btree__multiset.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1btree__set.html">btree_set</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized B+ tree template class implementing STL's set container.  <a href="classtlx_1_1btree__set.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1CmdlineParser.html">CmdlineParser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command line parser which automatically fills variables and prints nice usage messages.  <a href="classtlx_1_1CmdlineParser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1CountingPtr.html">CountingPtr</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">High-performance smart pointer used as a wrapping reference counting pointer.  <a href="classtlx_1_1CountingPtr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1CountingPtrDefaultDeleter.html">CountingPtrDefaultDeleter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">default deleter for <a class="el" href="classtlx_1_1CountingPtr.html" title="High-performance smart pointer used as a wrapping reference counting pointer. ">CountingPtr</a>  <a href="classtlx_1_1CountingPtrDefaultDeleter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1CountingPtrNoOperationDeleter.html">CountingPtrNoOperationDeleter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">dummy deleter for <a class="el" href="classtlx_1_1CountingPtr.html" title="High-performance smart pointer used as a wrapping reference counting pointer. ">CountingPtr</a>  <a href="classtlx_1_1CountingPtrNoOperationDeleter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1DAryAddressableIntHeap.html">DAryAddressableIntHeap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements an addressable integer priority queue, precisely a d-ary heap.  <a href="classtlx_1_1DAryAddressableIntHeap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1DAryHeap.html">DAryHeap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a d-ary comparison-based heap usable as a priority queue.  <a href="classtlx_1_1DAryHeap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate.html">Delegate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html">Delegate&lt; R(A...), Allocator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a faster replacement than std::function.  <a href="classtlx_1_1Delegate_3_01R_07A_8_8_8_08_00_01Allocator_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1DieException.html">DieException</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exception thrown by <a class="el" href="namespacetlx.html#a1a4f198a88970a7cb1f5d8d3a0555b79" title="die with message - either throw an exception or die via std::terminate() ">die_with_message()</a> if.  <a href="classtlx_1_1DieException.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1enable__if.html">enable_if</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SFINAE <a class="el" href="structtlx_1_1enable__if.html" title="SFINAE enable_if â€“ copy of std::enable_if&lt;&gt; with less extra cruft. ">enable_if</a> &ndash; copy of std::enable_if&lt;&gt; with less extra cruft.  <a href="structtlx_1_1enable__if.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1enable__if_3_01true_00_01T_01_4.html">enable_if&lt; true, T &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1FunctionChain.html">FunctionChain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classtlx_1_1FunctionChain.html" title="A FunctionChain is a chain of functors that can be folded to a single functors. ">FunctionChain</a> is a chain of functors that can be folded to a single functors.  <a href="classtlx_1_1FunctionChain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1FunctionStack.html">FunctionStack</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A <a class="el" href="classtlx_1_1FunctionStack.html" title="A FunctionStack is a chain of functor that can be folded to a single functor (which is usually optimi...">FunctionStack</a> is a chain of functor that can be folded to a single functor (which is usually optimize by the compiler).  <a href="classtlx_1_1FunctionStack.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1has__ostream__operator.html">has_ostream_operator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SFINAE magic helper for <a class="el" href="namespacetlx.html#a4685dbcbe251d930c560b5071ece8049">wrap_unprintable()</a>  <a href="structtlx_1_1has__ostream__operator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1has__ostream__operator_3_01Type_00_01decltype_07std_1_1declval_3_01std_1_1ostream_06b744f30b39306299f1971daf5fa9614.html">declval&lt; std::ostream &amp; &gt;()&lt;&lt; std::declval&lt; Type const &amp; &gt;(), void())&gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1index__sequence.html">index_sequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1is__std__array.html">is_std_array</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">test if is std::array&lt;T, N&gt;  <a href="structtlx_1_1is__std__array.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1is__std__array_3_01std_1_1array_3_01T_00_01N_01_4_01_4.html">is_std_array&lt; std::array&lt; T, N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1is__std__pair.html">is_std_pair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">test if is a std::pair&lt;...&gt;  <a href="structtlx_1_1is__std__pair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1is__std__pair_3_01std_1_1pair_3_01S_00_01T_01_4_01_4.html">is_std_pair&lt; std::pair&lt; S, T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1is__std__tuple.html">is_std_tuple</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">test if is a std::tuple&lt;...&gt;  <a href="structtlx_1_1is__std__tuple.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1is__std__tuple_3_01std_1_1tuple_3_01Ts_8_8_8_01_4_01_4.html">is_std_tuple&lt; std::tuple&lt; Ts... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1is__std__vector.html">is_std_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">test if is std::vector&lt;T&gt;  <a href="structtlx_1_1is__std__vector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1is__std__vector_3_01std_1_1vector_3_01T_01_4_01_4.html">is_std_vector&lt; std::vector&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1less__icase__asc.html">less_icase_asc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Case-insensitive less order relation functional class for std::map, etc.  <a href="structtlx_1_1less__icase__asc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1less__icase__desc.html">less_icase_desc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1LevenshteinStandardICaseParameters.html">LevenshteinStandardICaseParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard parameters to Levenshtein distance function.  <a href="structtlx_1_1LevenshteinStandardICaseParameters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1LevenshteinStandardParameters.html">LevenshteinStandardParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard parameters to levenshtein distance function.  <a href="structtlx_1_1LevenshteinStandardParameters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Log2.html">Log2</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Log2_3_010_01_4.html">Log2&lt; 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Log2_3_011_01_4.html">Log2&lt; 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Log2Floor.html">Log2Floor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Log2Floor_3_010_01_4.html">Log2Floor&lt; 0 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Log2Floor_3_011_01_4.html">Log2Floor&lt; 1 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Logger.html">Logger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">LOG and sLOG for development and debugging.  <a href="classtlx_1_1Logger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoggerCollectOutput.html">LoggerCollectOutput</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class to hook logger output in the local thread.  <a href="classtlx_1_1LoggerCollectOutput.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoggerFormatter.html">LoggerFormatter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">template class for formatting. contains a print() method.  <a href="classtlx_1_1LoggerFormatter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoggerFormatter_3_01AnyType_01_4.html">LoggerFormatter&lt; AnyType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoggerFormatter_3_01std_1_1array_3_01T_00_01N_01_4_01_4.html">LoggerFormatter&lt; std::array&lt; T, N &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoggerFormatter_3_01std_1_1deque_3_01T_00_01A_01_4_01_4.html">LoggerFormatter&lt; std::deque&lt; T, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoggerFormatter_3_01std_1_1map_3_01K_00_01V_00_01C_00_01A_01_4_01_4.html">LoggerFormatter&lt; std::map&lt; K, V, C, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoggerFormatter_3_01std_1_1multimap_3_01K_00_01V_00_01C_00_01A_01_4_01_4.html">LoggerFormatter&lt; std::multimap&lt; K, V, C, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoggerFormatter_3_01std_1_1multiset_3_01T_00_01C_00_01A_01_4_01_4.html">LoggerFormatter&lt; std::multiset&lt; T, C, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoggerFormatter_3_01std_1_1pair_3_01A_00_01B_01_4_01_4.html">LoggerFormatter&lt; std::pair&lt; A, B &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoggerFormatter_3_01std_1_1set_3_01T_00_01C_00_01A_01_4_01_4.html">LoggerFormatter&lt; std::set&lt; T, C, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoggerFormatter_3_01std_1_1tuple_3_01Args_8_8_8_01_4_01_4.html">LoggerFormatter&lt; std::tuple&lt; Args... &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoggerFormatter_3_01std_1_1tuple_3_4_01_4.html">LoggerFormatter&lt; std::tuple&lt;&gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoggerFormatter_3_01std_1_1unordered__map_3_01K_00_01V_00_01H_00_01E_00_01A_01_4_01_4.html">LoggerFormatter&lt; std::unordered_map&lt; K, V, H, E, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoggerFormatter_3_01std_1_1unordered__multimap_3_01K_00_01V_00_01H_00_01E_00_01A_01_4_01_4.html">LoggerFormatter&lt; std::unordered_multimap&lt; K, V, H, E, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoggerFormatter_3_01std_1_1unordered__multiset_3_01T_00_01H_00_01E_00_01A_01_4_01_4.html">LoggerFormatter&lt; std::unordered_multiset&lt; T, H, E, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoggerFormatter_3_01std_1_1unordered__set_3_01T_00_01H_00_01E_00_01A_01_4_01_4.html">LoggerFormatter&lt; std::unordered_set&lt; T, H, E, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoggerFormatter_3_01std_1_1vector_3_01T_00_01A_01_4_01_4.html">LoggerFormatter&lt; std::vector&lt; T, A &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoggerOutputHook.html">LoggerOutputHook</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class to implement output hooks for logging.  <a href="classtlx_1_1LoggerOutputHook.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoggerPrefixHook.html">LoggerPrefixHook</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class to implement prefix output hooks for logging.  <a href="classtlx_1_1LoggerPrefixHook.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoggerTupleFormatter.html">LoggerTupleFormatter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoggerVoidify.html">LoggerVoidify</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoserTreeCopy.html">LoserTreeCopy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarded loser tree/tournament tree, either copying the whole element into the tree structure, or looking up the element via the index.  <a href="classtlx_1_1LoserTreeCopy.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoserTreeCopy_3_01true_00_01ValueType_00_01Comparator_01_4.html">LoserTreeCopy&lt; true, ValueType, Comparator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarded loser tree/tournament tree, either copying the whole element into the tree structure, or looking up the element via the index.  <a href="classtlx_1_1LoserTreeCopy_3_01true_00_01ValueType_00_01Comparator_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoserTreeCopyBase.html">LoserTreeCopyBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarded loser tree/tournament tree, either copying the whole element into the tree structure, or looking up the element via the index.  <a href="classtlx_1_1LoserTreeCopyBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoserTreeCopyUnguarded.html">LoserTreeCopyUnguarded</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoserTreeCopyUnguarded_3_01true_00_01ValueType_00_01Comparator_01_4.html">LoserTreeCopyUnguarded&lt; true, ValueType, Comparator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoserTreeCopyUnguardedBase.html">LoserTreeCopyUnguardedBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unguarded loser tree, copying the whole element into the tree structure.  <a href="classtlx_1_1LoserTreeCopyUnguardedBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoserTreePointer.html">LoserTreePointer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarded loser tree, using pointers to the elements instead of copying them into the tree nodes.  <a href="classtlx_1_1LoserTreePointer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoserTreePointer_3_01true_00_01ValueType_00_01Comparator_01_4.html">LoserTreePointer&lt; true, ValueType, Comparator &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarded loser tree, using pointers to the elements instead of copying them into the tree nodes.  <a href="classtlx_1_1LoserTreePointer_3_01true_00_01ValueType_00_01Comparator_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoserTreePointerBase.html">LoserTreePointerBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Guarded loser tree, using pointers to the elements instead of copying them into the tree nodes.  <a href="classtlx_1_1LoserTreePointerBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoserTreePointerUnguarded.html">LoserTreePointerUnguarded</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoserTreePointerUnguarded_3_01true_00_01ValueType_00_01Comparator_01_4.html">LoserTreePointerUnguarded&lt; true, ValueType, Comparator &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoserTreePointerUnguardedBase.html">LoserTreePointerUnguardedBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unguarded loser tree, keeping only pointers to the elements in the tree structure.  <a href="classtlx_1_1LoserTreePointerUnguardedBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LoserTreeSwitch.html">LoserTreeSwitch</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LruCacheMap.html">LruCacheMap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an expected O(1) LRU cache which contains a map of (key -&gt; value) elements.  <a href="classtlx_1_1LruCacheMap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1LruCacheSet.html">LruCacheSet</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an expected O(1) LRU cache which contains a set of key-only elements.  <a href="classtlx_1_1LruCacheSet.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1make__index__sequence.html">make_index_sequence</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1MD5.html">MD5</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">MD-5 processor without external dependencies.  <a href="classtlx_1_1MD5.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1MultiTimer.html">MultiTimer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtlx_1_1MultiTimer.html" title="MultiTimer can be used to measure time usage of different phases in a program or algorithm. ">MultiTimer</a> can be used to measure time usage of different phases in a program or algorithm.  <a href="classtlx_1_1MultiTimer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1NoOperation.html">NoOperation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1NoOperation_3_01void_01_4.html">NoOperation&lt; void &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialized noop functor which returns a void.  <a href="classtlx_1_1NoOperation_3_01void_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1PolynomialRegression.html">PolynomialRegression</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the regression polynomial \( a_0+a_1x^1+a_2x^2+\cdots+a_nx^n \) from a list of 2D points.  <a href="classtlx_1_1PolynomialRegression.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1RadixHeap.html">RadixHeap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements a monotonic integer min priority queue, more specific a multi-level radix heap.  <a href="classtlx_1_1RadixHeap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1ReferenceCounter.html">ReferenceCounter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides reference counting abilities for use with <a class="el" href="classtlx_1_1CountingPtr.html" title="High-performance smart pointer used as a wrapping reference counting pointer. ">CountingPtr</a>.  <a href="classtlx_1_1ReferenceCounter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1RingBuffer.html">RingBuffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A ring (circular) buffer of static (non-growing) size.  <a href="classtlx_1_1RingBuffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1ScopedMultiTimer.html">ScopedMultiTimer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1ScopedMultiTimerSwitch.html">ScopedMultiTimerSwitch</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1Semaphore.html">Semaphore</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple semaphore implementation using C++11 synchronization methods.  <a href="classtlx_1_1Semaphore.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1SHA1.html">SHA1</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SHA-1 processor without external dependencies.  <a href="classtlx_1_1SHA1.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1SHA256.html">SHA256</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SHA-256 processor without external dependencies.  <a href="classtlx_1_1SHA256.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1SHA512.html">SHA512</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">SHA-512 processor without external dependencies.  <a href="classtlx_1_1SHA512.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1SimpleVector.html">SimpleVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simpler non-growing vector without initialization.  <a href="classtlx_1_1SimpleVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1SpacingLogger.html">SpacingLogger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A logging class which outputs spaces between elements pushed via operator&lt;&lt;.  <a href="classtlx_1_1SpacingLogger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1SplayTree.html">SplayTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1StackAllocator.html">StackAllocator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1StackArena.html">StackArena</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Storage area allocated on the stack and usable by a <a class="el" href="classtlx_1_1StackAllocator.html">StackAllocator</a>.  <a href="classtlx_1_1StackArena.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1StaticIndex.html">StaticIndex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1StringView.html">StringView</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtlx_1_1StringView.html" title="StringView is a reference to a part of a string, consisting of only a char pointer and a length...">StringView</a> is a reference to a part of a string, consisting of only a char pointer and a length.  <a href="classtlx_1_1StringView.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1ThreadBarrierMutex.html">ThreadBarrierMutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a thread barrier using mutex locking and condition variables that can be used to synchronize threads.  <a href="classtlx_1_1ThreadBarrierMutex.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1ThreadBarrierSpin.html">ThreadBarrierSpin</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a thread barrier using atomics and a spin lock that can be used to synchronize threads.  <a href="classtlx_1_1ThreadBarrierSpin.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1ThreadPool.html">ThreadPool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classtlx_1_1ThreadPool.html" title="ThreadPool starts a fixed number p of std::threads which process Jobs that are enqueued into a concur...">ThreadPool</a> starts a fixed number p of std::threads which process Jobs that are <a class="el" href="classtlx_1_1ThreadPool.html#ac0197b1301f4bec0f2421cfe41e9435a">enqueued</a> into a concurrent job queue.  <a href="classtlx_1_1ThreadPool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a2c4e023d82bca2172da2f965e3b42b40"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a2c4e023d82bca2172da2f965e3b42b40"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a2c4e023d82bca2172da2f965e3b42b40">counting_ptr</a> = <a class="el" href="classtlx_1_1CountingPtr.html">CountingPtr</a>&lt; Type &gt;</td></tr>
<tr class="memdesc:a2c4e023d82bca2172da2f965e3b42b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">make alias due to similarity with std::shared_ptr&lt;T&gt;  <a href="#a2c4e023d82bca2172da2f965e3b42b40">More...</a><br /></td></tr>
<tr class="separator:a2c4e023d82bca2172da2f965e3b42b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d28f4e50fa9fc359c658b0911ce06b8"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a9d28f4e50fa9fc359c658b0911ce06b8"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a9d28f4e50fa9fc359c658b0911ce06b8">CountingPtrNoDelete</a> = <a class="el" href="classtlx_1_1CountingPtr.html">CountingPtr</a>&lt; Type, <a class="el" href="classtlx_1_1CountingPtrNoOperationDeleter.html">CountingPtrNoOperationDeleter</a> &gt;</td></tr>
<tr class="memdesc:a9d28f4e50fa9fc359c658b0911ce06b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">make alias for dummy deleter  <a href="#a9d28f4e50fa9fc359c658b0911ce06b8">More...</a><br /></td></tr>
<tr class="separator:a9d28f4e50fa9fc359c658b0911ce06b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1689ee2489dc0a29c45605ae5ee25cd3"><td class="memTemplParams" colspan="2">template&lt;typename KeyType , unsigned Arity = 2, typename Compare  = std::less&lt;KeyType&gt;&gt; </td></tr>
<tr class="memitem:ga1689ee2489dc0a29c45605ae5ee25cd3"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__container.html#ga1689ee2489dc0a29c45605ae5ee25cd3">d_ary_addressable_int_heap</a> = <a class="el" href="classtlx_1_1DAryAddressableIntHeap.html">DAryAddressableIntHeap</a>&lt; KeyType, Arity, Compare &gt;</td></tr>
<tr class="memdesc:ga1689ee2489dc0a29c45605ae5ee25cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">make template alias due to similarity with std::priority_queue  <a href="group__tlx__container.html#ga1689ee2489dc0a29c45605ae5ee25cd3">More...</a><br /></td></tr>
<tr class="separator:ga1689ee2489dc0a29c45605ae5ee25cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36e59dd0c9957af99aa5f99b30ab7fd5"><td class="memTemplParams" colspan="2">template&lt;typename KeyType , unsigned Arity = 2, typename Compare  = std::less&lt;KeyType&gt;&gt; </td></tr>
<tr class="memitem:ga36e59dd0c9957af99aa5f99b30ab7fd5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__container.html#ga36e59dd0c9957af99aa5f99b30ab7fd5">d_ary_heap</a> = <a class="el" href="classtlx_1_1DAryHeap.html">DAryHeap</a>&lt; KeyType, Arity, Compare &gt;</td></tr>
<tr class="memdesc:ga36e59dd0c9957af99aa5f99b30ab7fd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">make template alias due to similarity with std::priority_queue  <a href="group__tlx__container.html#ga36e59dd0c9957af99aa5f99b30ab7fd5">More...</a><br /></td></tr>
<tr class="separator:ga36e59dd0c9957af99aa5f99b30ab7fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afacc9643f535d390fd0ead73790a6d56"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Allocator  = std::allocator&lt;void&gt;&gt; </td></tr>
<tr class="memitem:afacc9643f535d390fd0ead73790a6d56"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#afacc9643f535d390fd0ead73790a6d56">delegate</a> = <a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&lt; <a class="el" href="logistic__regression_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a>, Allocator &gt;</td></tr>
<tr class="memdesc:afacc9643f535d390fd0ead73790a6d56"><td class="mdescLeft">&#160;</td><td class="mdescRight">make template alias due to similarity with std::function  <a href="#afacc9643f535d390fd0ead73790a6d56">More...</a><br /></td></tr>
<tr class="separator:afacc9643f535d390fd0ead73790a6d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c9a8c3eea280d29bd2da8df37a01d9a"><td class="memTemplParams" colspan="2">template&lt;typename KeyType , typename DataType , unsigned Radix = 8&gt; </td></tr>
<tr class="memitem:ga1c9a8c3eea280d29bd2da8df37a01d9a"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__container.html#ga1c9a8c3eea280d29bd2da8df37a01d9a">RadixHeapPair</a> = <a class="el" href="classtlx_1_1RadixHeap.html">RadixHeap</a>&lt; std::pair&lt; KeyType, DataType &gt;, <a class="el" href="structtlx_1_1radix__heap__detail_1_1PairKeyExtract.html">radix_heap_detail::PairKeyExtract</a>&lt; KeyType, DataType &gt;, KeyType, Radix &gt;</td></tr>
<tr class="memdesc:ga1c9a8c3eea280d29bd2da8df37a01d9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a variant of <a class="el" href="classtlx_1_1RadixHeap.html" title="This class implements a monotonic integer min priority queue, more specific a multi-level radix heap...">tlx::RadixHeap</a> for data types which do not include the key directly.  <a href="group__tlx__container.html#ga1c9a8c3eea280d29bd2da8df37a01d9a">More...</a><br /></td></tr>
<tr class="separator:ga1c9a8c3eea280d29bd2da8df37a01d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a89ad01492580f7cf07d93a99539cf5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a4a89ad01492580f7cf07d93a99539cf5">reference_counter</a> = <a class="el" href="classtlx_1_1ReferenceCounter.html">ReferenceCounter</a></td></tr>
<tr class="memdesc:a4a89ad01492580f7cf07d93a99539cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">make alias due to <a class="el" href="classtlx_1_1CountingPtr.html" title="High-performance smart pointer used as a wrapping reference counting pointer. ">CountingPtr</a>'s similarity with std::shared_ptr&lt;T&gt;  <a href="#a4a89ad01492580f7cf07d93a99539cf5">More...</a><br /></td></tr>
<tr class="separator:a4a89ad01492580f7cf07d93a99539cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13b278f8ac00c463d949d2297f0c3381"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a13b278f8ac00c463d949d2297f0c3381">semaphore</a> = <a class="el" href="classtlx_1_1Semaphore.html">Semaphore</a></td></tr>
<tr class="memdesc:a13b278f8ac00c463d949d2297f0c3381"><td class="mdescLeft">&#160;</td><td class="mdescRight">alias for STL-like code style  <a href="#a13b278f8ac00c463d949d2297f0c3381">More...</a><br /></td></tr>
<tr class="separator:a13b278f8ac00c463d949d2297f0c3381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4843a6aed555573a98892469fee27b0b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4843a6aed555573a98892469fee27b0b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__container.html#ga4843a6aed555573a98892469fee27b0b">simple_vector</a> = <a class="el" href="classtlx_1_1SimpleVector.html">SimpleVector</a>&lt; <a class="el" href="logistic__regression_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &gt;</td></tr>
<tr class="memdesc:ga4843a6aed555573a98892469fee27b0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">make template alias due to similarity with std::vector  <a href="group__tlx__container.html#ga4843a6aed555573a98892469fee27b0b">More...</a><br /></td></tr>
<tr class="separator:ga4843a6aed555573a98892469fee27b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c6288bed9ea72458c107ba60de69776"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename Compare  = std::less&lt;Key&gt;, typename Allocator  = std::allocator&lt;Key&gt;&gt; </td></tr>
<tr class="memitem:ga7c6288bed9ea72458c107ba60de69776"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__container.html#ga7c6288bed9ea72458c107ba60de69776">splay_multiset</a> = <a class="el" href="classtlx_1_1SplayTree.html">SplayTree</a>&lt; Key, Compare, true, Allocator &gt;</td></tr>
<tr class="separator:ga7c6288bed9ea72458c107ba60de69776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41e381f67b77a92a0521fb1b268c930c"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename Compare  = std::less&lt;Key&gt;, typename Allocator  = std::allocator&lt;Key&gt;&gt; </td></tr>
<tr class="memitem:ga41e381f67b77a92a0521fb1b268c930c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__container.html#ga41e381f67b77a92a0521fb1b268c930c">splay_set</a> = <a class="el" href="classtlx_1_1SplayTree.html">SplayTree</a>&lt; Key, Compare, false, Allocator &gt;</td></tr>
<tr class="separator:ga41e381f67b77a92a0521fb1b268c930c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga325e3200f2c48d6cc3c8e198a2426f4e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__container.html#ga325e3200f2c48d6cc3c8e198a2426f4e">string_view</a> = <a class="el" href="classtlx_1_1StringView.html">StringView</a></td></tr>
<tr class="memdesc:ga325e3200f2c48d6cc3c8e198a2426f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">make alias due to STL similarity  <a href="group__tlx__container.html#ga325e3200f2c48d6cc3c8e198a2426f4e">More...</a><br /></td></tr>
<tr class="separator:ga325e3200f2c48d6cc3c8e198a2426f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa62991928fb9fb18ff0db62a040aba"><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#afaa62991928fb9fb18ff0db62a040aba">u32</a></td></tr>
<tr class="separator:afaa62991928fb9fb18ff0db62a040aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7e2bcbb0b4c338f3c4f6c937cd4234"><td class="memItemLeft" align="right" valign="top">typedef uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a3f7e2bcbb0b4c338f3c4f6c937cd4234">u64</a></td></tr>
<tr class="separator:a3f7e2bcbb0b4c338f3c4f6c937cd4234"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga98e900a348b28aa3709eb5e6d897ffbb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#ga98e900a348b28aa3709eb5e6d897ffbb">MultiwayMergeAlgorithm</a> { <br />
&#160;&#160;<a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbbac1488a90ba6e18d5f936e51cbc5625e1">MWMA_LOSER_TREE</a>, 
<a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbbadd051fbbe4e1346d6357c82d56add811">MWMA_LOSER_TREE_COMBINED</a>, 
<a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbba8f020d718b11548f7d45b3d56fb37981">MWMA_LOSER_TREE_SENTINEL</a>, 
<a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbba097e6877921551867e9681ff56411d10">MWMA_BUBBLE</a>, 
<br />
&#160;&#160;<a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbba9fbb6366507fb2f30a433c51366719b6">MWMA_ALGORITHM_LAST</a>, 
<a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbba332bba921707cc62f6a682b8ac2c9013">MWMA_ALGORITHM_DEFAULT</a> = MWMA_LOSER_TREE_COMBINED
<br />
 }<tr class="memdesc:ga98e900a348b28aa3709eb5e6d897ffbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different merging algorithms: bubblesort-alike, loser-tree variants, enum sentinel.  <a href="group__tlx__algorithm.html#ga98e900a348b28aa3709eb5e6d897ffbb">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga98e900a348b28aa3709eb5e6d897ffbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a7342a22bda2a80ef56d779ceae36c0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#ga8a7342a22bda2a80ef56d779ceae36c0">MultiwayMergeSplittingAlgorithm</a> { <a class="el" href="group__tlx__algorithm.html#gga8a7342a22bda2a80ef56d779ceae36c0abccc0e651299ce4048220b307340aff3">MWMSA_SAMPLING</a>, 
<a class="el" href="group__tlx__algorithm.html#gga8a7342a22bda2a80ef56d779ceae36c0aa7c13c05b4dd92e3fce043e8d4cc5f43">MWMSA_EXACT</a>, 
<a class="el" href="group__tlx__algorithm.html#gga8a7342a22bda2a80ef56d779ceae36c0a93014d67de65dba047c131661369e38c">MWMSA_LAST</a>, 
<a class="el" href="group__tlx__algorithm.html#gga8a7342a22bda2a80ef56d779ceae36c0acfb06584091121c62050c13c54e0e298">MWMSA_DEFAULT</a> = MWMSA_EXACT
 }<tr class="memdesc:ga8a7342a22bda2a80ef56d779ceae36c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different splitting strategies for sorting/merging: by sampling, exact.  <a href="group__tlx__algorithm.html#ga8a7342a22bda2a80ef56d779ceae36c0">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga8a7342a22bda2a80ef56d779ceae36c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07f67904ca9d31961dc022100101c358"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__container.html#ga07f67904ca9d31961dc022100101c358">SimpleVectorMode</a> { <a class="el" href="group__tlx__container.html#gga07f67904ca9d31961dc022100101c358a960b44c579bc2f6818d2daaf9e4c16f0">Normal</a>, 
<a class="el" href="group__tlx__container.html#gga07f67904ca9d31961dc022100101c358a96726bf24e630d03d0f4e5715e9fd097">NoInitButDestroy</a>, 
<a class="el" href="group__tlx__container.html#gga07f67904ca9d31961dc022100101c358a60008b87abd54104caffab5779ea7244">NoInitNoDestroy</a>
 }<tr class="memdesc:ga07f67904ca9d31961dc022100101c358"><td class="mdescLeft">&#160;</td><td class="mdescRight">enum class to select SimpleVector object initialization  <a href="group__tlx__container.html#ga07f67904ca9d31961dc022100101c358">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga07f67904ca9d31961dc022100101c358"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga72ac8fb39736ae5d2b8d920b17d815a8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga72ac8fb39736ae5d2b8d920b17d815a8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="logistic__regression_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga72ac8fb39736ae5d2b8d920b17d815a8">abs_diff</a> (const <a class="el" href="logistic__regression_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &amp;a, const <a class="el" href="logistic__regression_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &amp;b)</td></tr>
<tr class="memdesc:ga72ac8fb39736ae5d2b8d920b17d815a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">absolute difference, which also works for unsigned types  <a href="group__tlx__math.html#ga72ac8fb39736ae5d2b8d920b17d815a8">More...</a><br /></td></tr>
<tr class="separator:ga72ac8fb39736ae5d2b8d920b17d815a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7de31bec5774af4c0a81b579dd87be53"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga7de31bec5774af4c0a81b579dd87be53">appendline</a> (std::istream &amp;is, std::string &amp;str, char delim)</td></tr>
<tr class="separator:ga7de31bec5774af4c0a81b579dd87be53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga697505eebc05040893022611ce8866c1"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename Tuple &gt; </td></tr>
<tr class="memitem:ga697505eebc05040893022611ce8866c1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__meta.html#ga697505eebc05040893022611ce8866c1">apply_tuple</a> (Functor &amp;&amp;f, Tuple &amp;&amp;t)</td></tr>
<tr class="memdesc:ga697505eebc05040893022611ce8866c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call the functor f with the contents of t as arguments.  <a href="group__tlx__meta.html#ga697505eebc05040893022611ce8866c1">More...</a><br /></td></tr>
<tr class="separator:ga697505eebc05040893022611ce8866c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaed291452463c14987f064718b577b4e0"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gaed291452463c14987f064718b577b4e0">bswap16</a> (const uint16_t &amp;v)</td></tr>
<tr class="memdesc:gaed291452463c14987f064718b577b4e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">bswap16 - generic  <a href="group__tlx__math.html#gaed291452463c14987f064718b577b4e0">More...</a><br /></td></tr>
<tr class="separator:gaed291452463c14987f064718b577b4e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac03c8212547da938040fb7418763de20"><td class="memItemLeft" align="right" valign="top">static uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gac03c8212547da938040fb7418763de20">bswap16_generic</a> (const uint16_t &amp;x)</td></tr>
<tr class="memdesc:gac03c8212547da938040fb7418763de20"><td class="mdescLeft">&#160;</td><td class="mdescRight">bswap16 - generic implementation  <a href="group__tlx__math.html#gac03c8212547da938040fb7418763de20">More...</a><br /></td></tr>
<tr class="separator:gac03c8212547da938040fb7418763de20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga793a6ded5c447ffb21d2b091e7b07312"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga793a6ded5c447ffb21d2b091e7b07312">bswap32</a> (const uint32_t &amp;v)</td></tr>
<tr class="memdesc:ga793a6ded5c447ffb21d2b091e7b07312"><td class="mdescLeft">&#160;</td><td class="mdescRight">bswap32 - generic  <a href="group__tlx__math.html#ga793a6ded5c447ffb21d2b091e7b07312">More...</a><br /></td></tr>
<tr class="separator:ga793a6ded5c447ffb21d2b091e7b07312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd47ff29616b4ea732416837f6f3c5d5"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gadd47ff29616b4ea732416837f6f3c5d5">bswap32_generic</a> (const uint32_t &amp;x)</td></tr>
<tr class="memdesc:gadd47ff29616b4ea732416837f6f3c5d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">bswap32 - generic implementation  <a href="group__tlx__math.html#gadd47ff29616b4ea732416837f6f3c5d5">More...</a><br /></td></tr>
<tr class="separator:gadd47ff29616b4ea732416837f6f3c5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffd11e08884e55a4161f9bf5685d24fa"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gaffd11e08884e55a4161f9bf5685d24fa">bswap64</a> (const uint64_t &amp;v)</td></tr>
<tr class="memdesc:gaffd11e08884e55a4161f9bf5685d24fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">bswap64 - generic  <a href="group__tlx__math.html#gaffd11e08884e55a4161f9bf5685d24fa">More...</a><br /></td></tr>
<tr class="separator:gaffd11e08884e55a4161f9bf5685d24fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae10de7cd5d112b7039bee72d3f8deb8"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gaae10de7cd5d112b7039bee72d3f8deb8">bswap64_generic</a> (const uint64_t &amp;x)</td></tr>
<tr class="memdesc:gaae10de7cd5d112b7039bee72d3f8deb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">bswap64 - generic implementation  <a href="group__tlx__math.html#gaae10de7cd5d112b7039bee72d3f8deb8">More...</a><br /></td></tr>
<tr class="separator:gaae10de7cd5d112b7039bee72d3f8deb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabdeef74e74806d7a81fa708ce9828e2"><td class="memTemplParams" colspan="2">template&lt;size_t Size, typename Functor &gt; </td></tr>
<tr class="memitem:gaabdeef74e74806d7a81fa708ce9828e2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__meta.html#gaabdeef74e74806d7a81fa708ce9828e2">call_for_range</a> (Functor &amp;&amp;f)</td></tr>
<tr class="memdesc:gaabdeef74e74806d7a81fa708ce9828e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a generic functor (like a generic lambda) for the integers [0,Size).  <a href="group__tlx__meta.html#gaabdeef74e74806d7a81fa708ce9828e2">More...</a><br /></td></tr>
<tr class="separator:gaabdeef74e74806d7a81fa708ce9828e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2abdae3c630ff66ff635822c14f8c72a"><td class="memTemplParams" colspan="2">template&lt;size_t Begin, size_t End, typename Functor &gt; </td></tr>
<tr class="memitem:ga2abdae3c630ff66ff635822c14f8c72a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__meta.html#ga2abdae3c630ff66ff635822c14f8c72a">call_for_range</a> (Functor &amp;&amp;f)</td></tr>
<tr class="memdesc:ga2abdae3c630ff66ff635822c14f8c72a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Call a generic functor (like a generic lambda) for the integers [Begin,End).  <a href="group__tlx__meta.html#ga2abdae3c630ff66ff635822c14f8c72a">More...</a><br /></td></tr>
<tr class="separator:ga2abdae3c630ff66ff635822c14f8c72a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafdc3a00abab0f113b9c11f1a5561d58b"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:gafdc3a00abab0f113b9c11f1a5561d58b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__meta.html#gafdc3a00abab0f113b9c11f1a5561d58b">call_foreach</a> (Functor &amp;&amp;f, Args &amp;&amp;... args)</td></tr>
<tr class="separator:gafdc3a00abab0f113b9c11f1a5561d58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga592749f0b74d1c116893d4bc880343e3"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename Tuple &gt; </td></tr>
<tr class="memitem:ga592749f0b74d1c116893d4bc880343e3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__meta.html#ga592749f0b74d1c116893d4bc880343e3">call_foreach_tuple</a> (Functor &amp;&amp;f, Tuple &amp;&amp;t)</td></tr>
<tr class="separator:ga592749f0b74d1c116893d4bc880343e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83551ec4ad5da9352345f7178abeb056"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename Tuple &gt; </td></tr>
<tr class="memitem:ga83551ec4ad5da9352345f7178abeb056"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__meta.html#ga83551ec4ad5da9352345f7178abeb056">call_foreach_tuple_with_index</a> (Functor &amp;&amp;f, Tuple &amp;&amp;t)</td></tr>
<tr class="separator:ga83551ec4ad5da9352345f7178abeb056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbd0c811df18af6da777f5eb1434e8db"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:gadbd0c811df18af6da777f5eb1434e8db"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__meta.html#gadbd0c811df18af6da777f5eb1434e8db">call_foreach_with_index</a> (Functor &amp;&amp;f, Args &amp;&amp;... args)</td></tr>
<tr class="separator:gadbd0c811df18af6da777f5eb1434e8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8eebbd26ffd74bb652bdd95bbdf9cff8"><td class="memTemplParams" colspan="2">template&lt;typename Integral &gt; </td></tr>
<tr class="memitem:ga8eebbd26ffd74bb652bdd95bbdf9cff8"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga8eebbd26ffd74bb652bdd95bbdf9cff8">clz</a> (Integral x)</td></tr>
<tr class="separator:ga8eebbd26ffd74bb652bdd95bbdf9cff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09a565e9d3208a46ec2418f3f4af4aec"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ga09a565e9d3208a46ec2418f3f4af4aec"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga09a565e9d3208a46ec2418f3f4af4aec">clz&lt; int &gt;</a> (int i)</td></tr>
<tr class="memdesc:ga09a565e9d3208a46ec2418f3f4af4aec"><td class="mdescLeft">&#160;</td><td class="mdescRight">clz (count leading zeros)  <a href="group__tlx__math.html#ga09a565e9d3208a46ec2418f3f4af4aec">More...</a><br /></td></tr>
<tr class="separator:ga09a565e9d3208a46ec2418f3f4af4aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad963f1305c675db55d4a68c48907ea50"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:gad963f1305c675db55d4a68c48907ea50"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gad963f1305c675db55d4a68c48907ea50">clz&lt; long &gt;</a> (long i)</td></tr>
<tr class="memdesc:gad963f1305c675db55d4a68c48907ea50"><td class="mdescLeft">&#160;</td><td class="mdescRight">clz (count leading zeros)  <a href="group__tlx__math.html#gad963f1305c675db55d4a68c48907ea50">More...</a><br /></td></tr>
<tr class="separator:gad963f1305c675db55d4a68c48907ea50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f1b8534c59b728f99770d9e5fa6f1b1"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ga3f1b8534c59b728f99770d9e5fa6f1b1"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga3f1b8534c59b728f99770d9e5fa6f1b1">clz&lt; long long &gt;</a> (long long i)</td></tr>
<tr class="memdesc:ga3f1b8534c59b728f99770d9e5fa6f1b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">clz (count leading zeros)  <a href="group__tlx__math.html#ga3f1b8534c59b728f99770d9e5fa6f1b1">More...</a><br /></td></tr>
<tr class="separator:ga3f1b8534c59b728f99770d9e5fa6f1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5660978ea3eb7cde5437104e38998cb"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:gaa5660978ea3eb7cde5437104e38998cb"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gaa5660978ea3eb7cde5437104e38998cb">clz&lt; unsigned &gt;</a> (unsigned i)</td></tr>
<tr class="memdesc:gaa5660978ea3eb7cde5437104e38998cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">clz (count leading zeros)  <a href="group__tlx__math.html#gaa5660978ea3eb7cde5437104e38998cb">More...</a><br /></td></tr>
<tr class="separator:gaa5660978ea3eb7cde5437104e38998cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12d5012490e9a781255746b9bfa1973c"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ga12d5012490e9a781255746b9bfa1973c"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga12d5012490e9a781255746b9bfa1973c">clz&lt; unsigned long &gt;</a> (unsigned long i)</td></tr>
<tr class="memdesc:ga12d5012490e9a781255746b9bfa1973c"><td class="mdescLeft">&#160;</td><td class="mdescRight">clz (count leading zeros)  <a href="group__tlx__math.html#ga12d5012490e9a781255746b9bfa1973c">More...</a><br /></td></tr>
<tr class="separator:ga12d5012490e9a781255746b9bfa1973c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5238dcacef0a9e044c65271a676f940a"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ga5238dcacef0a9e044c65271a676f940a"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga5238dcacef0a9e044c65271a676f940a">clz&lt; unsigned long long &gt;</a> (unsigned long long i)</td></tr>
<tr class="memdesc:ga5238dcacef0a9e044c65271a676f940a"><td class="mdescLeft">&#160;</td><td class="mdescRight">clz (count leading zeros)  <a href="group__tlx__math.html#ga5238dcacef0a9e044c65271a676f940a">More...</a><br /></td></tr>
<tr class="separator:ga5238dcacef0a9e044c65271a676f940a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1fdecdbd0923a67672014032e079f16"><td class="memTemplParams" colspan="2">template&lt;typename Integral &gt; </td></tr>
<tr class="memitem:gaf1fdecdbd0923a67672014032e079f16"><td class="memTemplItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gaf1fdecdbd0923a67672014032e079f16">clz_template</a> (Integral x)</td></tr>
<tr class="memdesc:gaf1fdecdbd0923a67672014032e079f16"><td class="mdescLeft">&#160;</td><td class="mdescRight">clz (count leading zeros) - generic implementation  <a href="group__tlx__math.html#gaf1fdecdbd0923a67672014032e079f16">More...</a><br /></td></tr>
<tr class="separator:gaf1fdecdbd0923a67672014032e079f16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a87b7f6120ebcde0c01ad293465f9d7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga7a87b7f6120ebcde0c01ad293465f9d7">compare_icase</a> (const char *a, const char *b)</td></tr>
<tr class="memdesc:ga7a87b7f6120ebcde0c01ad293465f9d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns +1/0/-1 like strcmp(a, b) but without regard for letter case  <a href="group__tlx__string.html#ga7a87b7f6120ebcde0c01ad293465f9d7">More...</a><br /></td></tr>
<tr class="separator:ga7a87b7f6120ebcde0c01ad293465f9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga061e7b66eb332d7621ef99d11b724c16"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga061e7b66eb332d7621ef99d11b724c16">compare_icase</a> (const char *a, const std::string &amp;b)</td></tr>
<tr class="memdesc:ga061e7b66eb332d7621ef99d11b724c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns +1/0/-1 like strcmp(a, b) but without regard for letter case  <a href="group__tlx__string.html#ga061e7b66eb332d7621ef99d11b724c16">More...</a><br /></td></tr>
<tr class="separator:ga061e7b66eb332d7621ef99d11b724c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6b99f43a01b6d2ff8ca49f4518297b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gad6b99f43a01b6d2ff8ca49f4518297b9">compare_icase</a> (const std::string &amp;a, const char *b)</td></tr>
<tr class="memdesc:gad6b99f43a01b6d2ff8ca49f4518297b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns +1/0/-1 like strcmp(a, b) but without regard for letter case  <a href="group__tlx__string.html#gad6b99f43a01b6d2ff8ca49f4518297b9">More...</a><br /></td></tr>
<tr class="separator:gad6b99f43a01b6d2ff8ca49f4518297b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga988bb20efc727413da0a9d9d11f488b0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga988bb20efc727413da0a9d9d11f488b0">compare_icase</a> (const std::string &amp;a, const std::string &amp;b)</td></tr>
<tr class="memdesc:ga988bb20efc727413da0a9d9d11f488b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns +1/0/-1 like strcmp(a, b) but without regard for letter case  <a href="group__tlx__string.html#ga988bb20efc727413da0a9d9d11f488b0">More...</a><br /></td></tr>
<tr class="separator:ga988bb20efc727413da0a9d9d11f488b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ff92619b9a2ae3dbbdd6ef511c1779e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga7ff92619b9a2ae3dbbdd6ef511c1779e">contains</a> (const std::string &amp;str, const std::string &amp;pattern)</td></tr>
<tr class="memdesc:ga7ff92619b9a2ae3dbbdd6ef511c1779e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests of string contains pattern.  <a href="group__tlx__string.html#ga7ff92619b9a2ae3dbbdd6ef511c1779e">More...</a><br /></td></tr>
<tr class="separator:ga7ff92619b9a2ae3dbbdd6ef511c1779e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga399719274798a8a808e8e309ab490f03"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga399719274798a8a808e8e309ab490f03">contains</a> (const std::string &amp;str, const char *pattern)</td></tr>
<tr class="memdesc:ga399719274798a8a808e8e309ab490f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests of string contains pattern.  <a href="group__tlx__string.html#ga399719274798a8a808e8e309ab490f03">More...</a><br /></td></tr>
<tr class="separator:ga399719274798a8a808e8e309ab490f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d6aca56ee9463cd116fc8e065c4c3a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga8d6aca56ee9463cd116fc8e065c4c3a0">contains</a> (const std::string &amp;str, const char ch)</td></tr>
<tr class="memdesc:ga8d6aca56ee9463cd116fc8e065c4c3a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests of string contains character.  <a href="group__tlx__string.html#ga8d6aca56ee9463cd116fc8e065c4c3a0">More...</a><br /></td></tr>
<tr class="separator:ga8d6aca56ee9463cd116fc8e065c4c3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fd07edea7502e13dbc9d2991be95f02"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga2fd07edea7502e13dbc9d2991be95f02">contains_word</a> (const std::string &amp;str, const char *word)</td></tr>
<tr class="memdesc:ga2fd07edea7502e13dbc9d2991be95f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the given string for a whitespace-delimited word.  <a href="group__tlx__string.html#ga2fd07edea7502e13dbc9d2991be95f02">More...</a><br /></td></tr>
<tr class="separator:ga2fd07edea7502e13dbc9d2991be95f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f7b2444597941650e05c1bb96b04f45"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga7f7b2444597941650e05c1bb96b04f45">contains_word</a> (const std::string &amp;str, const std::string &amp;word)</td></tr>
<tr class="memdesc:ga7f7b2444597941650e05c1bb96b04f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the given string for a whitespace-delimited word.  <a href="group__tlx__string.html#ga7f7b2444597941650e05c1bb96b04f45">More...</a><br /></td></tr>
<tr class="separator:ga7f7b2444597941650e05c1bb96b04f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac81c84f20d22b569a0aacb4aef70ca2"><td class="memTemplParams" colspan="2">template&lt;typename Integral &gt; </td></tr>
<tr class="memitem:gaac81c84f20d22b569a0aacb4aef70ca2"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gaac81c84f20d22b569a0aacb4aef70ca2">ctz</a> (Integral x)</td></tr>
<tr class="separator:gaac81c84f20d22b569a0aacb4aef70ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga809c21b7642d2ed9d04532973e5fc980"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ga809c21b7642d2ed9d04532973e5fc980"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga809c21b7642d2ed9d04532973e5fc980">ctz&lt; int &gt;</a> (int i)</td></tr>
<tr class="memdesc:ga809c21b7642d2ed9d04532973e5fc980"><td class="mdescLeft">&#160;</td><td class="mdescRight">ctz (count trailing zeros)  <a href="group__tlx__math.html#ga809c21b7642d2ed9d04532973e5fc980">More...</a><br /></td></tr>
<tr class="separator:ga809c21b7642d2ed9d04532973e5fc980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ef6a0eca2c4ce5f66af407bed3f4864"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ga0ef6a0eca2c4ce5f66af407bed3f4864"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga0ef6a0eca2c4ce5f66af407bed3f4864">ctz&lt; long &gt;</a> (long i)</td></tr>
<tr class="memdesc:ga0ef6a0eca2c4ce5f66af407bed3f4864"><td class="mdescLeft">&#160;</td><td class="mdescRight">ctz (count trailing zeros)  <a href="group__tlx__math.html#ga0ef6a0eca2c4ce5f66af407bed3f4864">More...</a><br /></td></tr>
<tr class="separator:ga0ef6a0eca2c4ce5f66af407bed3f4864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9c01c3e6c3755059300dab2b8365e95"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:gab9c01c3e6c3755059300dab2b8365e95"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gab9c01c3e6c3755059300dab2b8365e95">ctz&lt; long long &gt;</a> (long long i)</td></tr>
<tr class="memdesc:gab9c01c3e6c3755059300dab2b8365e95"><td class="mdescLeft">&#160;</td><td class="mdescRight">ctz (count trailing zeros)  <a href="group__tlx__math.html#gab9c01c3e6c3755059300dab2b8365e95">More...</a><br /></td></tr>
<tr class="separator:gab9c01c3e6c3755059300dab2b8365e95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafef870f8575e12fabf159b89ca336cfc"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:gafef870f8575e12fabf159b89ca336cfc"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gafef870f8575e12fabf159b89ca336cfc">ctz&lt; unsigned &gt;</a> (unsigned i)</td></tr>
<tr class="memdesc:gafef870f8575e12fabf159b89ca336cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">ctz (count trailing zeros)  <a href="group__tlx__math.html#gafef870f8575e12fabf159b89ca336cfc">More...</a><br /></td></tr>
<tr class="separator:gafef870f8575e12fabf159b89ca336cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38724a98ba0a9096bbf889efedfbe9f6"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ga38724a98ba0a9096bbf889efedfbe9f6"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga38724a98ba0a9096bbf889efedfbe9f6">ctz&lt; unsigned long &gt;</a> (unsigned long i)</td></tr>
<tr class="memdesc:ga38724a98ba0a9096bbf889efedfbe9f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">ctz (count trailing zeros)  <a href="group__tlx__math.html#ga38724a98ba0a9096bbf889efedfbe9f6">More...</a><br /></td></tr>
<tr class="separator:ga38724a98ba0a9096bbf889efedfbe9f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga35f5c8746b9dcecd2184c99266fa1fa9"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ga35f5c8746b9dcecd2184c99266fa1fa9"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga35f5c8746b9dcecd2184c99266fa1fa9">ctz&lt; unsigned long long &gt;</a> (unsigned long long i)</td></tr>
<tr class="memdesc:ga35f5c8746b9dcecd2184c99266fa1fa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">ctz (count trailing zeros)  <a href="group__tlx__math.html#ga35f5c8746b9dcecd2184c99266fa1fa9">More...</a><br /></td></tr>
<tr class="separator:ga35f5c8746b9dcecd2184c99266fa1fa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e83c90bffe996d41225466f80f1543c"><td class="memTemplParams" colspan="2">template&lt;typename Integral &gt; </td></tr>
<tr class="memitem:ga3e83c90bffe996d41225466f80f1543c"><td class="memTemplItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga3e83c90bffe996d41225466f80f1543c">ctz_template</a> (Integral x)</td></tr>
<tr class="memdesc:ga3e83c90bffe996d41225466f80f1543c"><td class="mdescLeft">&#160;</td><td class="mdescRight">ctz (count trailing zeros) - generic implementation  <a href="group__tlx__math.html#ga3e83c90bffe996d41225466f80f1543c">More...</a><br /></td></tr>
<tr class="separator:ga3e83c90bffe996d41225466f80f1543c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8179e15f255f7283de043a22560c25"><td class="memTemplParams" colspan="2">template&lt;typename TypeA , typename TypeB &gt; </td></tr>
<tr class="memitem:a9f8179e15f255f7283de043a22560c25"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a9f8179e15f255f7283de043a22560c25">die_equal_compare</a> (TypeA a, TypeB b)</td></tr>
<tr class="memdesc:a9f8179e15f255f7283de043a22560c25"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper method to compare two values in <a class="el" href="die_8hpp.html#a334b021076c0dff0e3964c6819774ceb">die_unequal()</a>  <a href="#a9f8179e15f255f7283de043a22560c25">More...</a><br /></td></tr>
<tr class="separator:a9f8179e15f255f7283de043a22560c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac37c2fc10d396b6a0038eb2d643d1360"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ac37c2fc10d396b6a0038eb2d643d1360"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ac37c2fc10d396b6a0038eb2d643d1360">die_equal_compare</a> (const char *a, const char *b)</td></tr>
<tr class="separator:ac37c2fc10d396b6a0038eb2d643d1360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6834365ccbbe0995d597d91cb16ac05c"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a6834365ccbbe0995d597d91cb16ac05c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a6834365ccbbe0995d597d91cb16ac05c">die_equal_compare</a> (float a, float b)</td></tr>
<tr class="separator:a6834365ccbbe0995d597d91cb16ac05c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac215c9815621e2ebbc07da9be07a622f"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ac215c9815621e2ebbc07da9be07a622f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ac215c9815621e2ebbc07da9be07a622f">die_equal_compare</a> (double a, double b)</td></tr>
<tr class="separator:ac215c9815621e2ebbc07da9be07a622f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc85623f015ff3ce8bf5a365f14770c4"><td class="memTemplParams" colspan="2">template&lt;typename TypeA , typename TypeB &gt; </td></tr>
<tr class="memitem:acc85623f015ff3ce8bf5a365f14770c4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#acc85623f015ff3ce8bf5a365f14770c4">die_equal_eps_compare</a> (TypeA x, TypeB y, double eps)</td></tr>
<tr class="memdesc:acc85623f015ff3ce8bf5a365f14770c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">helper method to compare two values in <a class="el" href="die_8hpp.html#a6b7ce407ec77acd1f6b146c1a6ea65ef">die_unequal_eps()</a>  <a href="#acc85623f015ff3ce8bf5a365f14770c4">More...</a><br /></td></tr>
<tr class="separator:acc85623f015ff3ce8bf5a365f14770c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f3602febd2a4b1979c9846da4ce8d62"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a9f3602febd2a4b1979c9846da4ce8d62"><td class="memTemplItemLeft" align="right" valign="top">Type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a9f3602febd2a4b1979c9846da4ce8d62">die_unequal_eps_abs</a> (const Type &amp;t)</td></tr>
<tr class="memdesc:a9f3602febd2a4b1979c9846da4ce8d62"><td class="mdescLeft">&#160;</td><td class="mdescRight">simple replacement for std::abs  <a href="#a9f3602febd2a4b1979c9846da4ce8d62">More...</a><br /></td></tr>
<tr class="separator:a9f3602febd2a4b1979c9846da4ce8d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4f198a88970a7cb1f5d8d3a0555b79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a1a4f198a88970a7cb1f5d8d3a0555b79">die_with_message</a> (const std::string &amp;msg)</td></tr>
<tr class="memdesc:a1a4f198a88970a7cb1f5d8d3a0555b79"><td class="mdescLeft">&#160;</td><td class="mdescRight">die with message - either throw an exception or die via std::terminate()  <a href="#a1a4f198a88970a7cb1f5d8d3a0555b79">More...</a><br /></td></tr>
<tr class="separator:a1a4f198a88970a7cb1f5d8d3a0555b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1972bdbc5b9ff146cf88d18ec9a12d64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a1972bdbc5b9ff146cf88d18ec9a12d64">die_with_message</a> (const char *msg, const char *file, size_t line)</td></tr>
<tr class="memdesc:a1972bdbc5b9ff146cf88d18ec9a12d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">die with message - either throw an exception or die via std::terminate()  <a href="#a1972bdbc5b9ff146cf88d18ec9a12d64">More...</a><br /></td></tr>
<tr class="separator:a1972bdbc5b9ff146cf88d18ec9a12d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7bff2d67e5ed89bd9dc6bea904e1c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#acf7bff2d67e5ed89bd9dc6bea904e1c1">die_with_message</a> (const std::string &amp;msg, const char *file, size_t line)</td></tr>
<tr class="memdesc:acf7bff2d67e5ed89bd9dc6bea904e1c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">die with message - either throw an exception or die via std::terminate()  <a href="#acf7bff2d67e5ed89bd9dc6bea904e1c1">More...</a><br /></td></tr>
<tr class="separator:acf7bff2d67e5ed89bd9dc6bea904e1c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa901da3e5d75f6e1891f470b1382562e"><td class="memTemplParams" colspan="2">template&lt;typename IntegralN , typename IntegralK &gt; </td></tr>
<tr class="memitem:gaa901da3e5d75f6e1891f470b1382562e"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gaa901da3e5d75f6e1891f470b1382562e">div_ceil</a> (const IntegralN &amp;n, const IntegralK &amp;k) -&gt; decltype(n+k)</td></tr>
<tr class="memdesc:gaa901da3e5d75f6e1891f470b1382562e"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate n div k with rounding up, for n and k positive!  <a href="group__tlx__math.html#gaa901da3e5d75f6e1891f470b1382562e">More...</a><br /></td></tr>
<tr class="separator:gaa901da3e5d75f6e1891f470b1382562e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2395fc6f1f7427bda18323fd38ffa1f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga2395fc6f1f7427bda18323fd38ffa1f7">ends_with</a> (const char *str, const char *match)</td></tr>
<tr class="memdesc:ga2395fc6f1f7427bda18323fd38ffa1f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the end of this string.  <a href="group__tlx__string.html#ga2395fc6f1f7427bda18323fd38ffa1f7">More...</a><br /></td></tr>
<tr class="separator:ga2395fc6f1f7427bda18323fd38ffa1f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60cf87567ef6acda6704064cf994b441"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga60cf87567ef6acda6704064cf994b441">ends_with</a> (const char *str, const std::string &amp;match)</td></tr>
<tr class="memdesc:ga60cf87567ef6acda6704064cf994b441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the end of this string.  <a href="group__tlx__string.html#ga60cf87567ef6acda6704064cf994b441">More...</a><br /></td></tr>
<tr class="separator:ga60cf87567ef6acda6704064cf994b441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacea7b710bca17bae104e7e5eb6137fcf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gacea7b710bca17bae104e7e5eb6137fcf">ends_with</a> (const std::string &amp;str, const char *match)</td></tr>
<tr class="memdesc:gacea7b710bca17bae104e7e5eb6137fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the end of this string.  <a href="group__tlx__string.html#gacea7b710bca17bae104e7e5eb6137fcf">More...</a><br /></td></tr>
<tr class="separator:gacea7b710bca17bae104e7e5eb6137fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6eadd6e031f051ff44c5ab2935cdddfd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga6eadd6e031f051ff44c5ab2935cdddfd">ends_with</a> (const std::string &amp;str, const std::string &amp;match)</td></tr>
<tr class="memdesc:ga6eadd6e031f051ff44c5ab2935cdddfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the end of this string.  <a href="group__tlx__string.html#ga6eadd6e031f051ff44c5ab2935cdddfd">More...</a><br /></td></tr>
<tr class="separator:ga6eadd6e031f051ff44c5ab2935cdddfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5333b917b048207991b63b231a801d25"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a5333b917b048207991b63b231a801d25">ends_with_icase</a> (const char *str, const char *match)</td></tr>
<tr class="separator:a5333b917b048207991b63b231a801d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e44d8109f6044de35699f10aea3f0e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a03e44d8109f6044de35699f10aea3f0e">ends_with_icase</a> (const char *str, const std::string &amp;match)</td></tr>
<tr class="separator:a03e44d8109f6044de35699f10aea3f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7e29572ead3f33c45cd95c8d4b720d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gac7e29572ead3f33c45cd95c8d4b720d0">ends_with_icase</a> (const std::string &amp;str, const char *match)</td></tr>
<tr class="memdesc:gac7e29572ead3f33c45cd95c8d4b720d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the end of this string.  <a href="group__tlx__string.html#gac7e29572ead3f33c45cd95c8d4b720d0">More...</a><br /></td></tr>
<tr class="separator:gac7e29572ead3f33c45cd95c8d4b720d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga849ffa2f657372a30b5cfc53fe1267a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga849ffa2f657372a30b5cfc53fe1267a1">ends_with_icase</a> (const std::string &amp;str, const std::string &amp;match)</td></tr>
<tr class="memdesc:ga849ffa2f657372a30b5cfc53fe1267a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the end of this string.  <a href="group__tlx__string.html#ga849ffa2f657372a30b5cfc53fe1267a1">More...</a><br /></td></tr>
<tr class="separator:ga849ffa2f657372a30b5cfc53fe1267a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42a4d6e9f12943be811bcb6666d53493"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga42a4d6e9f12943be811bcb6666d53493">equal_icase</a> (const char *a, const char *b)</td></tr>
<tr class="memdesc:ga42a4d6e9f12943be811bcb6666d53493"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a == b without regard for letter case  <a href="group__tlx__string.html#ga42a4d6e9f12943be811bcb6666d53493">More...</a><br /></td></tr>
<tr class="separator:ga42a4d6e9f12943be811bcb6666d53493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad15c6b082515414b93a34b7ac0327df9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gad15c6b082515414b93a34b7ac0327df9">equal_icase</a> (const char *a, const std::string &amp;b)</td></tr>
<tr class="memdesc:gad15c6b082515414b93a34b7ac0327df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a == b without regard for letter case  <a href="group__tlx__string.html#gad15c6b082515414b93a34b7ac0327df9">More...</a><br /></td></tr>
<tr class="separator:gad15c6b082515414b93a34b7ac0327df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga118abe0d4d0cd1d90426121b626aeea9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga118abe0d4d0cd1d90426121b626aeea9">equal_icase</a> (const std::string &amp;a, const char *b)</td></tr>
<tr class="memdesc:ga118abe0d4d0cd1d90426121b626aeea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a == b without regard for letter case  <a href="group__tlx__string.html#ga118abe0d4d0cd1d90426121b626aeea9">More...</a><br /></td></tr>
<tr class="separator:ga118abe0d4d0cd1d90426121b626aeea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c9c153df7b49712108276c9a48fe88e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga2c9c153df7b49712108276c9a48fe88e">equal_icase</a> (const std::string &amp;a, const std::string &amp;b)</td></tr>
<tr class="memdesc:ga2c9c153df7b49712108276c9a48fe88e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a == b without regard for letter case  <a href="group__tlx__string.html#ga2c9c153df7b49712108276c9a48fe88e">More...</a><br /></td></tr>
<tr class="separator:ga2c9c153df7b49712108276c9a48fe88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa02a8cee5a6ee9d683fa5a77fda06913"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gaa02a8cee5a6ee9d683fa5a77fda06913">erase_all</a> (std::string *str, char drop=' ')</td></tr>
<tr class="memdesc:gaa02a8cee5a6ee9d683fa5a77fda06913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurrences of the given character in-place.  <a href="group__tlx__string.html#gaa02a8cee5a6ee9d683fa5a77fda06913">More...</a><br /></td></tr>
<tr class="separator:gaa02a8cee5a6ee9d683fa5a77fda06913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga290c6e7261f453c4774a0cf82586bf47"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga290c6e7261f453c4774a0cf82586bf47">erase_all</a> (std::string *str, const char *drop)</td></tr>
<tr class="memdesc:ga290c6e7261f453c4774a0cf82586bf47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurrences of the given characters in-place.  <a href="group__tlx__string.html#ga290c6e7261f453c4774a0cf82586bf47">More...</a><br /></td></tr>
<tr class="separator:ga290c6e7261f453c4774a0cf82586bf47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacefd443f50a3e6123651a031eb1701c4"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gacefd443f50a3e6123651a031eb1701c4">erase_all</a> (std::string *str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:gacefd443f50a3e6123651a031eb1701c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurrences of the given characters in-place.  <a href="group__tlx__string.html#gacefd443f50a3e6123651a031eb1701c4">More...</a><br /></td></tr>
<tr class="separator:gacefd443f50a3e6123651a031eb1701c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cd5bad774df90bb3314592e3e097ad8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga3cd5bad774df90bb3314592e3e097ad8">erase_all</a> (const std::string &amp;str, char drop=' ')</td></tr>
<tr class="memdesc:ga3cd5bad774df90bb3314592e3e097ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurrences of the given character, return copy of string.  <a href="group__tlx__string.html#ga3cd5bad774df90bb3314592e3e097ad8">More...</a><br /></td></tr>
<tr class="separator:ga3cd5bad774df90bb3314592e3e097ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c0aa5a14584e80887d4afc8c34337f8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga7c0aa5a14584e80887d4afc8c34337f8">erase_all</a> (const std::string &amp;str, const char *drop)</td></tr>
<tr class="memdesc:ga7c0aa5a14584e80887d4afc8c34337f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurrences of the given characters, return copy of string.  <a href="group__tlx__string.html#ga7c0aa5a14584e80887d4afc8c34337f8">More...</a><br /></td></tr>
<tr class="separator:ga7c0aa5a14584e80887d4afc8c34337f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09e7dd3f20d8e54c8502c81d540f9916"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga09e7dd3f20d8e54c8502c81d540f9916">erase_all</a> (const std::string &amp;str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:ga09e7dd3f20d8e54c8502c81d540f9916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurrences of the given characters, return copy of string.  <a href="group__tlx__string.html#ga09e7dd3f20d8e54c8502c81d540f9916">More...</a><br /></td></tr>
<tr class="separator:ga09e7dd3f20d8e54c8502c81d540f9916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3ec7c7d258293a6891f016878d22f09"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gaa3ec7c7d258293a6891f016878d22f09">escape_html</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:gaa3ec7c7d258293a6891f016878d22f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escape characters for inclusion in HTML documents: replaces the characters &lt;, &gt;, &amp; and " with HTML entities.  <a href="group__tlx__string.html#gaa3ec7c7d258293a6891f016878d22f09">More...</a><br /></td></tr>
<tr class="separator:gaa3ec7c7d258293a6891f016878d22f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff9bb94ad54dff0e04f12d87ba4ccd0d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gaff9bb94ad54dff0e04f12d87ba4ccd0d">escape_html</a> (const char *str)</td></tr>
<tr class="memdesc:gaff9bb94ad54dff0e04f12d87ba4ccd0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escape characters for inclusion in HTML documents: replaces the characters &lt;, &gt;, &amp; and " with HTML entities.  <a href="group__tlx__string.html#gaff9bb94ad54dff0e04f12d87ba4ccd0d">More...</a><br /></td></tr>
<tr class="separator:gaff9bb94ad54dff0e04f12d87ba4ccd0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78dd9a77d746d167e41eb91022b3bc38"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga78dd9a77d746d167e41eb91022b3bc38">escape_uri</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga78dd9a77d746d167e41eb91022b3bc38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escape a string into a URI-encoding.  <a href="group__tlx__string.html#ga78dd9a77d746d167e41eb91022b3bc38">More...</a><br /></td></tr>
<tr class="separator:ga78dd9a77d746d167e41eb91022b3bc38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga526a45d33d89b2de7c3c4a0734495332"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga526a45d33d89b2de7c3c4a0734495332">escape_uri</a> (const char *str)</td></tr>
<tr class="memdesc:ga526a45d33d89b2de7c3c4a0734495332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escape a string into a URI-encoding.  <a href="group__tlx__string.html#ga526a45d33d89b2de7c3c4a0734495332">More...</a><br /></td></tr>
<tr class="separator:ga526a45d33d89b2de7c3c4a0734495332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0801d65c092619953947c9c5bbeddc7b"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename T , typename BinaryOperation  = std::plus&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga0801d65c092619953947c9c5bbeddc7b"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#ga0801d65c092619953947c9c5bbeddc7b">exclusive_scan</a> (InputIterator first, InputIterator last, OutputIterator result, <a class="el" href="logistic__regression_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> init, BinaryOperation binary_op=BinaryOperation())</td></tr>
<tr class="memdesc:ga0801d65c092619953947c9c5bbeddc7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive prefix sum operation using binary_op the range [first, last), using init as the initial value, and writes the results to the range beginning at result.  <a href="group__tlx__algorithm.html#ga0801d65c092619953947c9c5bbeddc7b">More...</a><br /></td></tr>
<tr class="separator:ga0801d65c092619953947c9c5bbeddc7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3c0e542036a6b3db66c2df1592fdcd4"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gaf3c0e542036a6b3db66c2df1592fdcd4">expand_environment_variables</a> (std::string *s)</td></tr>
<tr class="memdesc:gaf3c0e542036a6b3db66c2df1592fdcd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand substrings $ABC_123 and ${ABC_123} into the corresponding environment variables.  <a href="group__tlx__string.html#gaf3c0e542036a6b3db66c2df1592fdcd4">More...</a><br /></td></tr>
<tr class="separator:gaf3c0e542036a6b3db66c2df1592fdcd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9078e1281843ab0c30230082ee244dd3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga9078e1281843ab0c30230082ee244dd3">expand_environment_variables</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:ga9078e1281843ab0c30230082ee244dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand substrings $ABC_123 and ${ABC_123} into the corresponding environment variables.  <a href="group__tlx__string.html#ga9078e1281843ab0c30230082ee244dd3">More...</a><br /></td></tr>
<tr class="separator:ga9078e1281843ab0c30230082ee244dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59e8b9ac077b7535eccf2dd2469ef792"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga59e8b9ac077b7535eccf2dd2469ef792">expand_environment_variables</a> (const char *s)</td></tr>
<tr class="memdesc:ga59e8b9ac077b7535eccf2dd2469ef792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand substrings $ABC_123 and ${ABC_123} into the corresponding environment variables.  <a href="group__tlx__string.html#ga59e8b9ac077b7535eccf2dd2469ef792">More...</a><br /></td></tr>
<tr class="separator:ga59e8b9ac077b7535eccf2dd2469ef792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga713c5cd2e2209e379c8b79ba2cd3e398"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga713c5cd2e2209e379c8b79ba2cd3e398">extract_between</a> (const std::string &amp;str, const char *sep1, const char *sep2)</td></tr>
<tr class="memdesc:ga713c5cd2e2209e379c8b79ba2cd3e398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the string for given start and end separators and extract all characters between the both, if they are found.  <a href="group__tlx__string.html#ga713c5cd2e2209e379c8b79ba2cd3e398">More...</a><br /></td></tr>
<tr class="separator:ga713c5cd2e2209e379c8b79ba2cd3e398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1ac1e43a5ae269bdbe594c4f4f4a325"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gae1ac1e43a5ae269bdbe594c4f4f4a325">extract_between</a> (const std::string &amp;str, const char *sep1, const std::string &amp;sep2)</td></tr>
<tr class="memdesc:gae1ac1e43a5ae269bdbe594c4f4f4a325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the string for given start and end separators and extract all characters between the both, if they are found.  <a href="group__tlx__string.html#gae1ac1e43a5ae269bdbe594c4f4f4a325">More...</a><br /></td></tr>
<tr class="separator:gae1ac1e43a5ae269bdbe594c4f4f4a325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0c6e73d346e3deda660b2eb24b06c67"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gaf0c6e73d346e3deda660b2eb24b06c67">extract_between</a> (const std::string &amp;str, const std::string &amp;sep1, const char *sep2)</td></tr>
<tr class="memdesc:gaf0c6e73d346e3deda660b2eb24b06c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the string for given start and end separators and extract all characters between the both, if they are found.  <a href="group__tlx__string.html#gaf0c6e73d346e3deda660b2eb24b06c67">More...</a><br /></td></tr>
<tr class="separator:gaf0c6e73d346e3deda660b2eb24b06c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3a44aaf97230d79b6aac046331240d3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gab3a44aaf97230d79b6aac046331240d3">extract_between</a> (const std::string &amp;str, const std::string &amp;sep1, const std::string &amp;sep2)</td></tr>
<tr class="memdesc:gab3a44aaf97230d79b6aac046331240d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the string for given start and end separators and extract all characters between the both, if they are found.  <a href="group__tlx__string.html#gab3a44aaf97230d79b6aac046331240d3">More...</a><br /></td></tr>
<tr class="separator:gab3a44aaf97230d79b6aac046331240d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536ac2439a4b7a17a0e089c443249e67"><td class="memTemplParams" colspan="2">template&lt;typename Separator1 , typename Separator2 &gt; </td></tr>
<tr class="memitem:a536ac2439a4b7a17a0e089c443249e67"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a536ac2439a4b7a17a0e089c443249e67">extract_between_template</a> (const std::string &amp;str, const Separator1 &amp;sep1, size_t sep1_size, const Separator2 &amp;sep2)</td></tr>
<tr class="separator:a536ac2439a4b7a17a0e089c443249e67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8fd16e4ccb887bed3fa8563ca38a61d"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gad8fd16e4ccb887bed3fa8563ca38a61d">ffs</a> (int i)</td></tr>
<tr class="memdesc:gad8fd16e4ccb887bed3fa8563ca38a61d"><td class="mdescLeft">&#160;</td><td class="mdescRight">find first set bit in integer, or zero if none are set.  <a href="group__tlx__math.html#gad8fd16e4ccb887bed3fa8563ca38a61d">More...</a><br /></td></tr>
<tr class="separator:gad8fd16e4ccb887bed3fa8563ca38a61d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d8d646eb127f0285aacdd5c18c45374"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga7d8d646eb127f0285aacdd5c18c45374">ffs</a> (unsigned int i)</td></tr>
<tr class="memdesc:ga7d8d646eb127f0285aacdd5c18c45374"><td class="mdescLeft">&#160;</td><td class="mdescRight">find first set bit in integer, or zero if none are set.  <a href="group__tlx__math.html#ga7d8d646eb127f0285aacdd5c18c45374">More...</a><br /></td></tr>
<tr class="separator:ga7d8d646eb127f0285aacdd5c18c45374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d2ca2e0837990f307ff6f7129c45cb5"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga8d2ca2e0837990f307ff6f7129c45cb5">ffs</a> (long i)</td></tr>
<tr class="memdesc:ga8d2ca2e0837990f307ff6f7129c45cb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">find first set bit in integer, or zero if none are set.  <a href="group__tlx__math.html#ga8d2ca2e0837990f307ff6f7129c45cb5">More...</a><br /></td></tr>
<tr class="separator:ga8d2ca2e0837990f307ff6f7129c45cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf13460ad33c93a724b32cd093ecdb4f9"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gaf13460ad33c93a724b32cd093ecdb4f9">ffs</a> (unsigned long i)</td></tr>
<tr class="memdesc:gaf13460ad33c93a724b32cd093ecdb4f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">find first set bit in integer, or zero if none are set.  <a href="group__tlx__math.html#gaf13460ad33c93a724b32cd093ecdb4f9">More...</a><br /></td></tr>
<tr class="separator:gaf13460ad33c93a724b32cd093ecdb4f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e797816c0711b7a6f99a1544d7a88e2"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga7e797816c0711b7a6f99a1544d7a88e2">ffs</a> (long long i)</td></tr>
<tr class="memdesc:ga7e797816c0711b7a6f99a1544d7a88e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">find first set bit in integer, or zero if none are set.  <a href="group__tlx__math.html#ga7e797816c0711b7a6f99a1544d7a88e2">More...</a><br /></td></tr>
<tr class="separator:ga7e797816c0711b7a6f99a1544d7a88e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0cbdb957bd7c626f6602d1461143357"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gae0cbdb957bd7c626f6602d1461143357">ffs</a> (unsigned long long i)</td></tr>
<tr class="memdesc:gae0cbdb957bd7c626f6602d1461143357"><td class="mdescLeft">&#160;</td><td class="mdescRight">find first set bit in integer, or zero if none are set.  <a href="group__tlx__math.html#gae0cbdb957bd7c626f6602d1461143357">More...</a><br /></td></tr>
<tr class="separator:gae0cbdb957bd7c626f6602d1461143357"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b18ba30be90fbdad29253ee722c6ed1"><td class="memTemplParams" colspan="2">template&lt;typename Integral &gt; </td></tr>
<tr class="memitem:ga6b18ba30be90fbdad29253ee722c6ed1"><td class="memTemplItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga6b18ba30be90fbdad29253ee722c6ed1">ffs_template</a> (Integral x)</td></tr>
<tr class="memdesc:ga6b18ba30be90fbdad29253ee722c6ed1"><td class="mdescLeft">&#160;</td><td class="mdescRight">ffs (find first set bit) - generic implementation  <a href="group__tlx__math.html#ga6b18ba30be90fbdad29253ee722c6ed1">More...</a><br /></td></tr>
<tr class="separator:ga6b18ba30be90fbdad29253ee722c6ed1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b543b9dcbf74a3a06dedaa3ffeae6f8"><td class="memTemplParams" colspan="2">template&lt;typename Reduce , typename Initial , typename... Args&gt; </td></tr>
<tr class="memitem:ga5b543b9dcbf74a3a06dedaa3ffeae6f8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__meta.html#ga5b543b9dcbf74a3a06dedaa3ffeae6f8">fold_left</a> (Reduce &amp;&amp;r, Initial &amp;&amp;init, Args &amp;&amp;... args)</td></tr>
<tr class="separator:ga5b543b9dcbf74a3a06dedaa3ffeae6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81c817d6c9ae0e06f4806fad21d583b8"><td class="memTemplParams" colspan="2">template&lt;typename Reduce , typename Initial , typename Tuple &gt; </td></tr>
<tr class="memitem:ga81c817d6c9ae0e06f4806fad21d583b8"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__meta.html#ga81c817d6c9ae0e06f4806fad21d583b8">fold_left_tuple</a> (Reduce &amp;&amp;r, Initial &amp;&amp;init, Tuple &amp;&amp;t)</td></tr>
<tr class="separator:ga81c817d6c9ae0e06f4806fad21d583b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaedde6c312729dd4e4783ea43b90b791"><td class="memTemplParams" colspan="2">template&lt;typename Reduce , typename Initial , typename... Args&gt; </td></tr>
<tr class="memitem:gaaedde6c312729dd4e4783ea43b90b791"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__meta.html#gaaedde6c312729dd4e4783ea43b90b791">fold_right</a> (Reduce &amp;&amp;r, Initial &amp;&amp;init, Args &amp;&amp;... args)</td></tr>
<tr class="separator:gaaedde6c312729dd4e4783ea43b90b791"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e169ed1c415649bc1cd112cf59f56f4"><td class="memTemplParams" colspan="2">template&lt;typename Reduce , typename Initial , typename Tuple &gt; </td></tr>
<tr class="memitem:ga4e169ed1c415649bc1cd112cf59f56f4"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__meta.html#ga4e169ed1c415649bc1cd112cf59f56f4">fold_right_tuple</a> (Reduce &amp;&amp;r, Initial &amp;&amp;init, Tuple &amp;&amp;t)</td></tr>
<tr class="separator:ga4e169ed1c415649bc1cd112cf59f56f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga937bd46650d317c28df7c7723ae84119"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga937bd46650d317c28df7c7723ae84119">format_iec_units</a> (uint64_t number, int precision)</td></tr>
<tr class="memdesc:ga937bd46650d317c28df7c7723ae84119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format number as something like 1 TiB.  <a href="group__tlx__string.html#ga937bd46650d317c28df7c7723ae84119">More...</a><br /></td></tr>
<tr class="separator:ga937bd46650d317c28df7c7723ae84119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga084c15f3eff7d1eb6018d00779486013"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga084c15f3eff7d1eb6018d00779486013">format_si_units</a> (uint64_t number, int precision)</td></tr>
<tr class="memdesc:ga084c15f3eff7d1eb6018d00779486013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format number as something like 1 TB.  <a href="group__tlx__string.html#ga084c15f3eff7d1eb6018d00779486013">More...</a><br /></td></tr>
<tr class="separator:ga084c15f3eff7d1eb6018d00779486013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d5fe504fb6456b97583d3b22e29ef15"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga7d5fe504fb6456b97583d3b22e29ef15">hash_djb2</a> (const unsigned char *str)</td></tr>
<tr class="memdesc:ga7d5fe504fb6456b97583d3b22e29ef15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple, fast, but "insecure" string hash method by Dan Bernstein from <a href="http://www.cse.yorku.ca/~oz/hash.html">http://www.cse.yorku.ca/~oz/hash.html</a>.  <a href="group__tlx__string.html#ga7d5fe504fb6456b97583d3b22e29ef15">More...</a><br /></td></tr>
<tr class="separator:ga7d5fe504fb6456b97583d3b22e29ef15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6531595513b1c5d45b7bf4a69f692eb8"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga6531595513b1c5d45b7bf4a69f692eb8">hash_djb2</a> (const char *str)</td></tr>
<tr class="memdesc:ga6531595513b1c5d45b7bf4a69f692eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple, fast, but "insecure" string hash method by Dan Bernstein from <a href="http://www.cse.yorku.ca/~oz/hash.html">http://www.cse.yorku.ca/~oz/hash.html</a>.  <a href="group__tlx__string.html#ga6531595513b1c5d45b7bf4a69f692eb8">More...</a><br /></td></tr>
<tr class="separator:ga6531595513b1c5d45b7bf4a69f692eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dc88c91798e233da55d584356208bde"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga5dc88c91798e233da55d584356208bde">hash_djb2</a> (const unsigned char *str, size_t size)</td></tr>
<tr class="memdesc:ga5dc88c91798e233da55d584356208bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple, fast, but "insecure" string hash method by Dan Bernstein from <a href="http://www.cse.yorku.ca/~oz/hash.html">http://www.cse.yorku.ca/~oz/hash.html</a>.  <a href="group__tlx__string.html#ga5dc88c91798e233da55d584356208bde">More...</a><br /></td></tr>
<tr class="separator:ga5dc88c91798e233da55d584356208bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbe3214eb034f80d3b0213e0f9d15d42"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gadbe3214eb034f80d3b0213e0f9d15d42">hash_djb2</a> (const char *str, size_t size)</td></tr>
<tr class="memdesc:gadbe3214eb034f80d3b0213e0f9d15d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple, fast, but "insecure" string hash method by Dan Bernstein from <a href="http://www.cse.yorku.ca/~oz/hash.html">http://www.cse.yorku.ca/~oz/hash.html</a>.  <a href="group__tlx__string.html#gadbe3214eb034f80d3b0213e0f9d15d42">More...</a><br /></td></tr>
<tr class="separator:gadbe3214eb034f80d3b0213e0f9d15d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4496533a4e1ae1eba65ca4ff2aace8b"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gab4496533a4e1ae1eba65ca4ff2aace8b">hash_djb2</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:gab4496533a4e1ae1eba65ca4ff2aace8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple, fast, but "insecure" string hash method by Dan Bernstein from <a href="http://www.cse.yorku.ca/~oz/hash.html">http://www.cse.yorku.ca/~oz/hash.html</a>.  <a href="group__tlx__string.html#gab4496533a4e1ae1eba65ca4ff2aace8b">More...</a><br /></td></tr>
<tr class="separator:gab4496533a4e1ae1eba65ca4ff2aace8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf601eabca113edcea72bd73914f575af"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gaf601eabca113edcea72bd73914f575af">hash_sdbm</a> (const unsigned char *str)</td></tr>
<tr class="memdesc:gaf601eabca113edcea72bd73914f575af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple, fast, but "insecure" string hash method by sdbm database from <a href="http://www.cse.yorku.ca/~oz/hash.html">http://www.cse.yorku.ca/~oz/hash.html</a>.  <a href="group__tlx__string.html#gaf601eabca113edcea72bd73914f575af">More...</a><br /></td></tr>
<tr class="separator:gaf601eabca113edcea72bd73914f575af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa22cee030ea7fd4250a5d62f96f44eec"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gaa22cee030ea7fd4250a5d62f96f44eec">hash_sdbm</a> (const char *str)</td></tr>
<tr class="memdesc:gaa22cee030ea7fd4250a5d62f96f44eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple, fast, but "insecure" string hash method by sdbm database from <a href="http://www.cse.yorku.ca/~oz/hash.html">http://www.cse.yorku.ca/~oz/hash.html</a>.  <a href="group__tlx__string.html#gaa22cee030ea7fd4250a5d62f96f44eec">More...</a><br /></td></tr>
<tr class="separator:gaa22cee030ea7fd4250a5d62f96f44eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2a3262295fb0a81a969021e1ecd92fa"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gab2a3262295fb0a81a969021e1ecd92fa">hash_sdbm</a> (const unsigned char *str, size_t size)</td></tr>
<tr class="memdesc:gab2a3262295fb0a81a969021e1ecd92fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple, fast, but "insecure" string hash method by sdbm database from <a href="http://www.cse.yorku.ca/~oz/hash.html">http://www.cse.yorku.ca/~oz/hash.html</a>.  <a href="group__tlx__string.html#gab2a3262295fb0a81a969021e1ecd92fa">More...</a><br /></td></tr>
<tr class="separator:gab2a3262295fb0a81a969021e1ecd92fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b763e42bb6cd369d77917c383e15bb4"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga2b763e42bb6cd369d77917c383e15bb4">hash_sdbm</a> (const char *str, size_t size)</td></tr>
<tr class="memdesc:ga2b763e42bb6cd369d77917c383e15bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple, fast, but "insecure" string hash method by sdbm database from <a href="http://www.cse.yorku.ca/~oz/hash.html">http://www.cse.yorku.ca/~oz/hash.html</a>.  <a href="group__tlx__string.html#ga2b763e42bb6cd369d77917c383e15bb4">More...</a><br /></td></tr>
<tr class="separator:ga2b763e42bb6cd369d77917c383e15bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbd5b48b17bb3d074f4404bce40b592d"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gadbd5b48b17bb3d074f4404bce40b592d">hash_sdbm</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:gadbd5b48b17bb3d074f4404bce40b592d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple, fast, but "insecure" string hash method by sdbm database from <a href="http://www.cse.yorku.ca/~oz/hash.html">http://www.cse.yorku.ca/~oz/hash.html</a>.  <a href="group__tlx__string.html#gadbd5b48b17bb3d074f4404bce40b592d">More...</a><br /></td></tr>
<tr class="separator:gadbd5b48b17bb3d074f4404bce40b592d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15b290439811d07e8fc0a6134c4faa0b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga15b290439811d07e8fc0a6134c4faa0b">index_of</a> (const std::vector&lt; std::string &gt; &amp;list, const char *str)</td></tr>
<tr class="memdesc:ga15b290439811d07e8fc0a6134c4faa0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to find str in the list and return the index.  <a href="group__tlx__string.html#ga15b290439811d07e8fc0a6134c4faa0b">More...</a><br /></td></tr>
<tr class="separator:ga15b290439811d07e8fc0a6134c4faa0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5156b8029cca4a21cb3e1b14ea6526d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gac5156b8029cca4a21cb3e1b14ea6526d">index_of</a> (const std::vector&lt; std::string &gt; &amp;list, const std::string &amp;str)</td></tr>
<tr class="memdesc:gac5156b8029cca4a21cb3e1b14ea6526d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to find str in the list and return the index.  <a href="group__tlx__string.html#gac5156b8029cca4a21cb3e1b14ea6526d">More...</a><br /></td></tr>
<tr class="separator:gac5156b8029cca4a21cb3e1b14ea6526d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00bece0086ba6a8598e97e93694b713f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga00bece0086ba6a8598e97e93694b713f">index_of_icase</a> (const std::vector&lt; std::string &gt; &amp;list, const char *str)</td></tr>
<tr class="memdesc:ga00bece0086ba6a8598e97e93694b713f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to find str in the list and return the index using case-insensitive comparisons.  <a href="group__tlx__string.html#ga00bece0086ba6a8598e97e93694b713f">More...</a><br /></td></tr>
<tr class="separator:ga00bece0086ba6a8598e97e93694b713f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d3b5b0636e261f97ab3292d78f2201b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga2d3b5b0636e261f97ab3292d78f2201b">index_of_icase</a> (const std::vector&lt; std::string &gt; &amp;list, const std::string &amp;str)</td></tr>
<tr class="memdesc:ga2d3b5b0636e261f97ab3292d78f2201b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to find str in the list and return the index using case-insensitive comparisons.  <a href="group__tlx__string.html#ga2d3b5b0636e261f97ab3292d78f2201b">More...</a><br /></td></tr>
<tr class="separator:ga2d3b5b0636e261f97ab3292d78f2201b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68fdc2904ba0c42014092e1f2aeb1f0d"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga68fdc2904ba0c42014092e1f2aeb1f0d">integer_log2_ceil</a> (int i)</td></tr>
<tr class="memdesc:ga68fdc2904ba0c42014092e1f2aeb1f0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the log2 floor of an integer type  <a href="group__tlx__math.html#ga68fdc2904ba0c42014092e1f2aeb1f0d">More...</a><br /></td></tr>
<tr class="separator:ga68fdc2904ba0c42014092e1f2aeb1f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa6c3b6962d85104a79fea216f565bff8"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gaa6c3b6962d85104a79fea216f565bff8">integer_log2_ceil</a> (unsigned int i)</td></tr>
<tr class="memdesc:gaa6c3b6962d85104a79fea216f565bff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the log2 floor of an integer type  <a href="group__tlx__math.html#gaa6c3b6962d85104a79fea216f565bff8">More...</a><br /></td></tr>
<tr class="separator:gaa6c3b6962d85104a79fea216f565bff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87dd01e935a4d31259cb4044b1abb48d"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga87dd01e935a4d31259cb4044b1abb48d">integer_log2_ceil</a> (long i)</td></tr>
<tr class="memdesc:ga87dd01e935a4d31259cb4044b1abb48d"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the log2 floor of an integer type  <a href="group__tlx__math.html#ga87dd01e935a4d31259cb4044b1abb48d">More...</a><br /></td></tr>
<tr class="separator:ga87dd01e935a4d31259cb4044b1abb48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga530755aca7c62b2f7d43f2e82e086c64"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga530755aca7c62b2f7d43f2e82e086c64">integer_log2_ceil</a> (unsigned long i)</td></tr>
<tr class="memdesc:ga530755aca7c62b2f7d43f2e82e086c64"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the log2 floor of an integer type  <a href="group__tlx__math.html#ga530755aca7c62b2f7d43f2e82e086c64">More...</a><br /></td></tr>
<tr class="separator:ga530755aca7c62b2f7d43f2e82e086c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac082121f5062c6c599d4cc35a7a00a2c"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gac082121f5062c6c599d4cc35a7a00a2c">integer_log2_ceil</a> (long long i)</td></tr>
<tr class="memdesc:gac082121f5062c6c599d4cc35a7a00a2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the log2 floor of an integer type  <a href="group__tlx__math.html#gac082121f5062c6c599d4cc35a7a00a2c">More...</a><br /></td></tr>
<tr class="separator:gac082121f5062c6c599d4cc35a7a00a2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadc4f0400d371977edd0636a52aacc56"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gaadc4f0400d371977edd0636a52aacc56">integer_log2_ceil</a> (unsigned long long i)</td></tr>
<tr class="memdesc:gaadc4f0400d371977edd0636a52aacc56"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the log2 floor of an integer type  <a href="group__tlx__math.html#gaadc4f0400d371977edd0636a52aacc56">More...</a><br /></td></tr>
<tr class="separator:gaadc4f0400d371977edd0636a52aacc56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga421e5b20fe5e88e367cab92800be8b40"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga421e5b20fe5e88e367cab92800be8b40">integer_log2_floor</a> (int i)</td></tr>
<tr class="memdesc:ga421e5b20fe5e88e367cab92800be8b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the log2 floor of an integer type  <a href="group__tlx__math.html#ga421e5b20fe5e88e367cab92800be8b40">More...</a><br /></td></tr>
<tr class="separator:ga421e5b20fe5e88e367cab92800be8b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf5864cb677af9b9547a6c4c1e08089f"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gacf5864cb677af9b9547a6c4c1e08089f">integer_log2_floor</a> (unsigned int i)</td></tr>
<tr class="memdesc:gacf5864cb677af9b9547a6c4c1e08089f"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the log2 floor of an integer type  <a href="group__tlx__math.html#gacf5864cb677af9b9547a6c4c1e08089f">More...</a><br /></td></tr>
<tr class="separator:gacf5864cb677af9b9547a6c4c1e08089f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b609dabb83130f9dbc545bf4fe11e5a"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga8b609dabb83130f9dbc545bf4fe11e5a">integer_log2_floor</a> (long i)</td></tr>
<tr class="memdesc:ga8b609dabb83130f9dbc545bf4fe11e5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the log2 floor of an integer type  <a href="group__tlx__math.html#ga8b609dabb83130f9dbc545bf4fe11e5a">More...</a><br /></td></tr>
<tr class="separator:ga8b609dabb83130f9dbc545bf4fe11e5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74a8ec330f47970ce1f3e5265f913a86"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga74a8ec330f47970ce1f3e5265f913a86">integer_log2_floor</a> (unsigned long i)</td></tr>
<tr class="memdesc:ga74a8ec330f47970ce1f3e5265f913a86"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the log2 floor of an integer type  <a href="group__tlx__math.html#ga74a8ec330f47970ce1f3e5265f913a86">More...</a><br /></td></tr>
<tr class="separator:ga74a8ec330f47970ce1f3e5265f913a86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga036059ffdfd460ae31bcdfed2da21505"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga036059ffdfd460ae31bcdfed2da21505">integer_log2_floor</a> (long long i)</td></tr>
<tr class="memdesc:ga036059ffdfd460ae31bcdfed2da21505"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the log2 floor of an integer type  <a href="group__tlx__math.html#ga036059ffdfd460ae31bcdfed2da21505">More...</a><br /></td></tr>
<tr class="separator:ga036059ffdfd460ae31bcdfed2da21505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e9cd2820fc4f0dcd39002a644b83e2a"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga5e9cd2820fc4f0dcd39002a644b83e2a">integer_log2_floor</a> (unsigned long long i)</td></tr>
<tr class="memdesc:ga5e9cd2820fc4f0dcd39002a644b83e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the log2 floor of an integer type  <a href="group__tlx__math.html#ga5e9cd2820fc4f0dcd39002a644b83e2a">More...</a><br /></td></tr>
<tr class="separator:ga5e9cd2820fc4f0dcd39002a644b83e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga819e2d0d244166deaf699dbd962dfc4c"><td class="memTemplParams" colspan="2">template&lt;typename IntegerType &gt; </td></tr>
<tr class="memitem:ga819e2d0d244166deaf699dbd962dfc4c"><td class="memTemplItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga819e2d0d244166deaf699dbd962dfc4c">integer_log2_floor_template</a> (IntegerType i)</td></tr>
<tr class="memdesc:ga819e2d0d244166deaf699dbd962dfc4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate the log2 floor of an integer type  <a href="group__tlx__math.html#ga819e2d0d244166deaf699dbd962dfc4c">More...</a><br /></td></tr>
<tr class="separator:ga819e2d0d244166deaf699dbd962dfc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06084e6aa5055e2c602add77f1df1967"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga06084e6aa5055e2c602add77f1df1967">is_power_of_two</a> (int i)</td></tr>
<tr class="memdesc:ga06084e6aa5055e2c602add77f1df1967"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: true if i is a power of two  <a href="group__tlx__math.html#ga06084e6aa5055e2c602add77f1df1967">More...</a><br /></td></tr>
<tr class="separator:ga06084e6aa5055e2c602add77f1df1967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa61484a72368630ede42c5ac942b719e"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gaa61484a72368630ede42c5ac942b719e">is_power_of_two</a> (unsigned int i)</td></tr>
<tr class="memdesc:gaa61484a72368630ede42c5ac942b719e"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: true if i is a power of two  <a href="group__tlx__math.html#gaa61484a72368630ede42c5ac942b719e">More...</a><br /></td></tr>
<tr class="separator:gaa61484a72368630ede42c5ac942b719e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9fe5b4251eed0d5e136c1fc987cdb9b"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gae9fe5b4251eed0d5e136c1fc987cdb9b">is_power_of_two</a> (long i)</td></tr>
<tr class="memdesc:gae9fe5b4251eed0d5e136c1fc987cdb9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: true if i is a power of two  <a href="group__tlx__math.html#gae9fe5b4251eed0d5e136c1fc987cdb9b">More...</a><br /></td></tr>
<tr class="separator:gae9fe5b4251eed0d5e136c1fc987cdb9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2ca48dfc557ef6581ab17a1c3e53d0a1"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga2ca48dfc557ef6581ab17a1c3e53d0a1">is_power_of_two</a> (unsigned long i)</td></tr>
<tr class="memdesc:ga2ca48dfc557ef6581ab17a1c3e53d0a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: true if i is a power of two  <a href="group__tlx__math.html#ga2ca48dfc557ef6581ab17a1c3e53d0a1">More...</a><br /></td></tr>
<tr class="separator:ga2ca48dfc557ef6581ab17a1c3e53d0a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6dc34ab52962230ca6f2aaff3a97b3ad"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga6dc34ab52962230ca6f2aaff3a97b3ad">is_power_of_two</a> (long long i)</td></tr>
<tr class="memdesc:ga6dc34ab52962230ca6f2aaff3a97b3ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: true if i is a power of two  <a href="group__tlx__math.html#ga6dc34ab52962230ca6f2aaff3a97b3ad">More...</a><br /></td></tr>
<tr class="separator:ga6dc34ab52962230ca6f2aaff3a97b3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga384054d31c4252ebb7acebc7d5829680"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga384054d31c4252ebb7acebc7d5829680">is_power_of_two</a> (unsigned long long i)</td></tr>
<tr class="memdesc:ga384054d31c4252ebb7acebc7d5829680"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: true if i is a power of two  <a href="group__tlx__math.html#ga384054d31c4252ebb7acebc7d5829680">More...</a><br /></td></tr>
<tr class="separator:ga384054d31c4252ebb7acebc7d5829680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bd0c156caa682f81c584b29f1d62104"><td class="memTemplParams" colspan="2">template&lt;typename Integral &gt; </td></tr>
<tr class="memitem:ga6bd0c156caa682f81c584b29f1d62104"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga6bd0c156caa682f81c584b29f1d62104">is_power_of_two_template</a> (Integral i)</td></tr>
<tr class="separator:ga6bd0c156caa682f81c584b29f1d62104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe360874d7ebb9890f27be61d5b8e599"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename Comparator &gt; </td></tr>
<tr class="memitem:gabe360874d7ebb9890f27be61d5b8e599"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#gabe360874d7ebb9890f27be61d5b8e599">is_sorted_cmp</a> (ForwardIterator first, ForwardIterator last, Comparator cmp)</td></tr>
<tr class="memdesc:gabe360874d7ebb9890f27be61d5b8e599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a range is sorted using a three-way Comparator (with memcmp() semantics).  <a href="group__tlx__algorithm.html#gabe360874d7ebb9890f27be61d5b8e599">More...</a><br /></td></tr>
<tr class="separator:gabe360874d7ebb9890f27be61d5b8e599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f76b0fd536a8ed9216ff7c3e26d2214"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename Comparator &gt; </td></tr>
<tr class="memitem:ga0f76b0fd536a8ed9216ff7c3e26d2214"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#ga0f76b0fd536a8ed9216ff7c3e26d2214">is_sorted_until_cmp</a> (ForwardIterator first, ForwardIterator last, Comparator cmp)</td></tr>
<tr class="memdesc:ga0f76b0fd536a8ed9216ff7c3e26d2214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a range is sorted using a three-way Comparator (with memcmp() semantics).  <a href="group__tlx__algorithm.html#ga0f76b0fd536a8ed9216ff7c3e26d2214">More...</a><br /></td></tr>
<tr class="separator:ga0f76b0fd536a8ed9216ff7c3e26d2214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced5355a13aebabfa68ca4100e507e83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#aced5355a13aebabfa68ca4100e507e83">is_space</a> (char ch)</td></tr>
<tr class="separator:aced5355a13aebabfa68ca4100e507e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aebcd1b9a6ce6667c8bbcab36aeaadb"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a7aebcd1b9a6ce6667c8bbcab36aeaadb">is_white</a> (char c)</td></tr>
<tr class="separator:a7aebcd1b9a6ce6667c8bbcab36aeaadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a73759be8d7ec5778cb6192bc32c4c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga3a73759be8d7ec5778cb6192bc32c4c2">less_icase</a> (const char *a, const char *b)</td></tr>
<tr class="memdesc:ga3a73759be8d7ec5778cb6192bc32c4c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a &lt; b without regard for letter case  <a href="group__tlx__string.html#ga3a73759be8d7ec5778cb6192bc32c4c2">More...</a><br /></td></tr>
<tr class="separator:ga3a73759be8d7ec5778cb6192bc32c4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e53bb43043cc4fdf6fef5a9f017957c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga0e53bb43043cc4fdf6fef5a9f017957c">less_icase</a> (const char *a, const std::string &amp;b)</td></tr>
<tr class="memdesc:ga0e53bb43043cc4fdf6fef5a9f017957c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a &lt; b without regard for letter case  <a href="group__tlx__string.html#ga0e53bb43043cc4fdf6fef5a9f017957c">More...</a><br /></td></tr>
<tr class="separator:ga0e53bb43043cc4fdf6fef5a9f017957c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25e2629353a36fb47c587b4eef89c0d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga25e2629353a36fb47c587b4eef89c0d2">less_icase</a> (const std::string &amp;a, const char *b)</td></tr>
<tr class="memdesc:ga25e2629353a36fb47c587b4eef89c0d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a &lt; b without regard for letter case  <a href="group__tlx__string.html#ga25e2629353a36fb47c587b4eef89c0d2">More...</a><br /></td></tr>
<tr class="separator:ga25e2629353a36fb47c587b4eef89c0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fb49f152c6bf0d96ec46bfb90a38bfc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga9fb49f152c6bf0d96ec46bfb90a38bfc">less_icase</a> (const std::string &amp;a, const std::string &amp;b)</td></tr>
<tr class="memdesc:ga9fb49f152c6bf0d96ec46bfb90a38bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a &lt; b without regard for letter case  <a href="group__tlx__string.html#ga9fb49f152c6bf0d96ec46bfb90a38bfc">More...</a><br /></td></tr>
<tr class="separator:ga9fb49f152c6bf0d96ec46bfb90a38bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5097f3a710847ed15aa3cdc2bbbe857c"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga5097f3a710847ed15aa3cdc2bbbe857c">levenshtein</a> (const char *a, const char *b)</td></tr>
<tr class="memdesc:ga5097f3a710847ed15aa3cdc2bbbe857c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Levenshtein string distance between two strings.  <a href="group__tlx__string.html#ga5097f3a710847ed15aa3cdc2bbbe857c">More...</a><br /></td></tr>
<tr class="separator:ga5097f3a710847ed15aa3cdc2bbbe857c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga643fe1eebc35da109f593cdcf068d3af"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga643fe1eebc35da109f593cdcf068d3af">levenshtein</a> (const std::string &amp;a, const std::string &amp;b)</td></tr>
<tr class="memdesc:ga643fe1eebc35da109f593cdcf068d3af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Levenshtein string distance between two strings.  <a href="group__tlx__string.html#ga643fe1eebc35da109f593cdcf068d3af">More...</a><br /></td></tr>
<tr class="separator:ga643fe1eebc35da109f593cdcf068d3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28296225d021e2ff9a1bedfa711b26fa"><td class="memTemplParams" colspan="2">template&lt;typename Param &gt; </td></tr>
<tr class="memitem:ga28296225d021e2ff9a1bedfa711b26fa"><td class="memTemplItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga28296225d021e2ff9a1bedfa711b26fa">levenshtein_algorithm</a> (const char *a, size_t a_size, const char *b, size_t b_size)</td></tr>
<tr class="memdesc:ga28296225d021e2ff9a1bedfa711b26fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Levenshtein string distance also called edit distance between two strings.  <a href="group__tlx__string.html#ga28296225d021e2ff9a1bedfa711b26fa">More...</a><br /></td></tr>
<tr class="separator:ga28296225d021e2ff9a1bedfa711b26fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01fc1d66b4a6f822509d793576b2cce2"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga01fc1d66b4a6f822509d793576b2cce2">levenshtein_icase</a> (const char *a, const char *b)</td></tr>
<tr class="memdesc:ga01fc1d66b4a6f822509d793576b2cce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Levenshtein string distance between two strings.  <a href="group__tlx__string.html#ga01fc1d66b4a6f822509d793576b2cce2">More...</a><br /></td></tr>
<tr class="separator:ga01fc1d66b4a6f822509d793576b2cce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d20af010f11fab72744484ef67e00b6"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga0d20af010f11fab72744484ef67e00b6">levenshtein_icase</a> (const std::string &amp;a, const std::string &amp;b)</td></tr>
<tr class="memdesc:ga0d20af010f11fab72744484ef67e00b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Levenshtein string distance between two strings.  <a href="group__tlx__string.html#ga0d20af010f11fab72744484ef67e00b6">More...</a><br /></td></tr>
<tr class="separator:ga0d20af010f11fab72744484ef67e00b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e20c59eaf19af62994ddc495412dde4"><td class="memTemplParams" colspan="2">template&lt;typename Type , typename... Args&gt; </td></tr>
<tr class="memitem:a6e20c59eaf19af62994ddc495412dde4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1CountingPtr.html">CountingPtr</a>&lt; Type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a6e20c59eaf19af62994ddc495412dde4">make_counting</a> (Args &amp;&amp;... args)</td></tr>
<tr class="memdesc:a6e20c59eaf19af62994ddc495412dde4"><td class="mdescLeft">&#160;</td><td class="mdescRight">method analogous to std::make_shared and std::make_unique.  <a href="#a6e20c59eaf19af62994ddc495412dde4">More...</a><br /></td></tr>
<tr class="separator:a6e20c59eaf19af62994ddc495412dde4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac208faa35171eb6016cf9730ed83f3"><td class="memTemplParams" colspan="2">template&lt;class C , typename R , typename... A&gt; </td></tr>
<tr class="memitem:abac208faa35171eb6016cf9730ed83f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&lt; R(A...)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#abac208faa35171eb6016cf9730ed83f3">make_delegate</a> (C *const object_ptr, R(C::*const method_ptr)(A...)) noexcept</td></tr>
<tr class="memdesc:abac208faa35171eb6016cf9730ed83f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for wrapping a class::method with object pointer.  <a href="#abac208faa35171eb6016cf9730ed83f3">More...</a><br /></td></tr>
<tr class="separator:abac208faa35171eb6016cf9730ed83f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e57fc132415d92776d9eed01ae3442"><td class="memTemplParams" colspan="2">template&lt;class C , typename R , typename... A&gt; </td></tr>
<tr class="memitem:a36e57fc132415d92776d9eed01ae3442"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&lt; R(A...)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a36e57fc132415d92776d9eed01ae3442">make_delegate</a> (C &amp;object_ptr, R(C::*const method_ptr)(A...)) noexcept</td></tr>
<tr class="memdesc:a36e57fc132415d92776d9eed01ae3442"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for wrapping a class::method with object reference.  <a href="#a36e57fc132415d92776d9eed01ae3442">More...</a><br /></td></tr>
<tr class="separator:a36e57fc132415d92776d9eed01ae3442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf10f085647ba34ff677aeecba994064"><td class="memTemplParams" colspan="2">template&lt;class C , typename R , typename... A&gt; </td></tr>
<tr class="memitem:aaf10f085647ba34ff677aeecba994064"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&lt; R(A...)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#aaf10f085647ba34ff677aeecba994064">make_delegate</a> (C const &amp;object_ptr, R(C::*const method_ptr)(A...) const) noexcept</td></tr>
<tr class="memdesc:aaf10f085647ba34ff677aeecba994064"><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor for wrapping a const class::method with object reference.  <a href="#aaf10f085647ba34ff677aeecba994064">More...</a><br /></td></tr>
<tr class="separator:aaf10f085647ba34ff677aeecba994064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2afc1ff7d0b9ea7a6583d0573e36ef7"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:gab2afc1ff7d0b9ea7a6583d0573e36ef7"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__meta.html#gab2afc1ff7d0b9ea7a6583d0573e36ef7">make_function_chain</a> (const Functor &amp;functor)</td></tr>
<tr class="memdesc:gab2afc1ff7d0b9ea7a6583d0573e36ef7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor chain maker. Can also be called with a lambda function.  <a href="group__tlx__meta.html#gab2afc1ff7d0b9ea7a6583d0573e36ef7">More...</a><br /></td></tr>
<tr class="separator:gab2afc1ff7d0b9ea7a6583d0573e36ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd2b32ffd2415899c6a69ccac4d7138f"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__meta.html#gadd2b32ffd2415899c6a69ccac4d7138f">make_function_chain</a> ()</td></tr>
<tr class="memdesc:gadd2b32ffd2415899c6a69ccac4d7138f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct and empty function chain.  <a href="group__tlx__meta.html#gadd2b32ffd2415899c6a69ccac4d7138f">More...</a><br /></td></tr>
<tr class="separator:gadd2b32ffd2415899c6a69ccac4d7138f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4f5461dca9e4be26479c56a5500357e"><td class="memTemplParams" colspan="2">template&lt;typename Input , typename Functor &gt; </td></tr>
<tr class="memitem:gaf4f5461dca9e4be26479c56a5500357e"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__meta.html#gaf4f5461dca9e4be26479c56a5500357e">make_function_stack</a> (const Functor &amp;functor)</td></tr>
<tr class="memdesc:gaf4f5461dca9e4be26479c56a5500357e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function-style construction of a <a class="el" href="classtlx_1_1FunctionStack.html" title="A FunctionStack is a chain of functor that can be folded to a single functor (which is usually optimi...">FunctionStack</a>.  <a href="group__tlx__meta.html#gaf4f5461dca9e4be26479c56a5500357e">More...</a><br /></td></tr>
<tr class="separator:gaf4f5461dca9e4be26479c56a5500357e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a349f9b8b3e8deeeb18e6428bc89777"><td class="memTemplParams" colspan="2">template&lt;typename DataType , unsigned Radix = 8, typename KeyExtract  = void&gt; </td></tr>
<tr class="memitem:ga5a349f9b8b3e8deeeb18e6428bc89777"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__container.html#ga5a349f9b8b3e8deeeb18e6428bc89777">make_radix_heap</a> (KeyExtract &amp;&amp;key_extract) -&gt; <a class="el" href="classtlx_1_1RadixHeap.html">RadixHeap</a>&lt; DataType, KeyExtract, decltype(key_extract(std::declval&lt; DataType &gt;())), Radix &gt;</td></tr>
<tr class="memdesc:ga5a349f9b8b3e8deeeb18e6428bc89777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to easily derive type of <a class="el" href="classtlx_1_1RadixHeap.html" title="This class implements a monotonic integer min priority queue, more specific a multi-level radix heap...">RadixHeap</a> for a pre-C++17 compiler.  <a href="group__tlx__container.html#ga5a349f9b8b3e8deeeb18e6428bc89777">More...</a><br /></td></tr>
<tr class="separator:ga5a349f9b8b3e8deeeb18e6428bc89777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7900e84fe15ce302ebbec731976f974"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__digest.html#gae7900e84fe15ce302ebbec731976f974">md5_hex</a> (const void *data, uint32_t size)</td></tr>
<tr class="memdesc:gae7900e84fe15ce302ebbec731976f974"><td class="mdescLeft">&#160;</td><td class="mdescRight">process data and return 16 byte (128 bit) digest hex encoded  <a href="group__tlx__digest.html#gae7900e84fe15ce302ebbec731976f974">More...</a><br /></td></tr>
<tr class="separator:gae7900e84fe15ce302ebbec731976f974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacaa5b4c9220cfcda36b5b4c76fb4a510"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__digest.html#gacaa5b4c9220cfcda36b5b4c76fb4a510">md5_hex</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:gacaa5b4c9220cfcda36b5b4c76fb4a510"><td class="mdescLeft">&#160;</td><td class="mdescRight">process data and return 16 byte (128 bit) digest hex encoded  <a href="group__tlx__digest.html#gacaa5b4c9220cfcda36b5b4c76fb4a510">More...</a><br /></td></tr>
<tr class="separator:gacaa5b4c9220cfcda36b5b4c76fb4a510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40a301b6099ec705f9e296ac99233c36"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__digest.html#ga40a301b6099ec705f9e296ac99233c36">md5_hex_uc</a> (const void *data, uint32_t size)</td></tr>
<tr class="memdesc:ga40a301b6099ec705f9e296ac99233c36"><td class="mdescLeft">&#160;</td><td class="mdescRight">process data and return 16 byte (128 bit) digest upper-case hex encoded  <a href="group__tlx__digest.html#ga40a301b6099ec705f9e296ac99233c36">More...</a><br /></td></tr>
<tr class="separator:ga40a301b6099ec705f9e296ac99233c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07f759ccedff246da9020d050d5e2153"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__digest.html#ga07f759ccedff246da9020d050d5e2153">md5_hex_uc</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga07f759ccedff246da9020d050d5e2153"><td class="mdescLeft">&#160;</td><td class="mdescRight">process data and return 16 byte (128 bit) digest upper-case hex encoded  <a href="group__tlx__digest.html#ga07f759ccedff246da9020d050d5e2153">More...</a><br /></td></tr>
<tr class="separator:ga07f759ccedff246da9020d050d5e2153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea5cc8f7ba44822560e49eb74ae83794"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator1 , typename RandomAccessIterator2 , typename OutputIterator , typename DiffType , typename Comparator &gt; </td></tr>
<tr class="memitem:gaea5cc8f7ba44822560e49eb74ae83794"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#gaea5cc8f7ba44822560e49eb74ae83794">merge_advance</a> (RandomAccessIterator1 &amp;begin1, RandomAccessIterator1 end1, RandomAccessIterator2 &amp;begin2, RandomAccessIterator2 end2, OutputIterator target, DiffType max_size, Comparator comp)</td></tr>
<tr class="memdesc:gaea5cc8f7ba44822560e49eb74ae83794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge routine being able to merge only the <code>max_size</code> smallest elements.  <a href="group__tlx__algorithm.html#gaea5cc8f7ba44822560e49eb74ae83794">More...</a><br /></td></tr>
<tr class="separator:gaea5cc8f7ba44822560e49eb74ae83794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae146e022866f8e3e983cfc46b2287555"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator1 , typename RandomAccessIterator2 , typename OutputIterator , typename DiffType , typename Comparator &gt; </td></tr>
<tr class="memitem:gae146e022866f8e3e983cfc46b2287555"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#gae146e022866f8e3e983cfc46b2287555">merge_advance_movc</a> (RandomAccessIterator1 &amp;begin1, RandomAccessIterator1 end1, RandomAccessIterator2 &amp;begin2, RandomAccessIterator2 end2, OutputIterator target, DiffType max_size, Comparator comp)</td></tr>
<tr class="memdesc:gae146e022866f8e3e983cfc46b2287555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge routine being able to merge only the <code>max_size</code> smallest elements.  <a href="group__tlx__algorithm.html#gae146e022866f8e3e983cfc46b2287555">More...</a><br /></td></tr>
<tr class="separator:gae146e022866f8e3e983cfc46b2287555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad57c4ceef5354d1657467303fe06bebf"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator1 , typename RandomAccessIterator2 , typename OutputIterator , typename DiffType , typename Comparator &gt; </td></tr>
<tr class="memitem:gad57c4ceef5354d1657467303fe06bebf"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#gad57c4ceef5354d1657467303fe06bebf">merge_advance_usual</a> (RandomAccessIterator1 &amp;begin1, RandomAccessIterator1 end1, RandomAccessIterator2 &amp;begin2, RandomAccessIterator2 end2, OutputIterator target, DiffType max_size, Comparator comp)</td></tr>
<tr class="memdesc:gad57c4ceef5354d1657467303fe06bebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge routine being able to merge only the <code>max_size</code> smallest elements.  <a href="group__tlx__algorithm.html#gad57c4ceef5354d1657467303fe06bebf">More...</a><br /></td></tr>
<tr class="separator:gad57c4ceef5354d1657467303fe06bebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac328961b3d340e0963ca02b7703fafcd"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename Comparator , typename Combine  = std::plus&lt;              typename std::iterator_traits&lt;InputIterator1&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:gac328961b3d340e0963ca02b7703fafcd"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#gac328961b3d340e0963ca02b7703fafcd">merge_combine</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, Comparator cmp=Comparator(), Combine combine=Combine())</td></tr>
<tr class="memdesc:gac328961b3d340e0963ca02b7703fafcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge two sorted ranges and add all items comparing equal.  <a href="group__tlx__algorithm.html#gac328961b3d340e0963ca02b7703fafcd">More...</a><br /></td></tr>
<tr class="separator:gac328961b3d340e0963ca02b7703fafcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54b64d7db3fbcd0e966d8e4105f52626"><td class="memTemplParams" colspan="2">template&lt;typename RanSeqs , typename RankType , typename RankIterator , typename Comparator  = std::less&lt;              typename std::iterator_traits&lt;                  typename std::iterator_traits&lt;RanSeqs&gt;                  ::value_type::first_type&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:ga54b64d7db3fbcd0e966d8e4105f52626"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#ga54b64d7db3fbcd0e966d8e4105f52626">multisequence_partition</a> (const RanSeqs &amp;begin_seqs, const RanSeqs &amp;end_seqs, const RankType &amp;rank, RankIterator begin_offsets, Comparator comp=Comparator())</td></tr>
<tr class="memdesc:ga54b64d7db3fbcd0e966d8e4105f52626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits several sorted sequences at a certain global rank, resulting in a splitting point for each sequence.  <a href="group__tlx__algorithm.html#ga54b64d7db3fbcd0e966d8e4105f52626">More...</a><br /></td></tr>
<tr class="separator:ga54b64d7db3fbcd0e966d8e4105f52626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73373d32a6a9d4e92c432d38bef8d908"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename RanSeqs , typename RankType , typename Comparator  = std::less&lt;ValueType&gt;&gt; </td></tr>
<tr class="memitem:ga73373d32a6a9d4e92c432d38bef8d908"><td class="memTemplItemLeft" align="right" valign="top">ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#ga73373d32a6a9d4e92c432d38bef8d908">multisequence_selection</a> (const RanSeqs &amp;begin_seqs, const RanSeqs &amp;end_seqs, const RankType &amp;rank, RankType &amp;offset, Comparator comp=Comparator())</td></tr>
<tr class="memdesc:ga73373d32a6a9d4e92c432d38bef8d908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects the element at a certain global rank from several sorted sequences.  <a href="group__tlx__algorithm.html#ga73373d32a6a9d4e92c432d38bef8d908">More...</a><br /></td></tr>
<tr class="separator:ga73373d32a6a9d4e92c432d38bef8d908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfbaa27bf2f95ce5806e19e6fc4980e9"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename Comparator  = std::less&lt;        typename std::iterator_traits&lt;            typename std::iterator_traits&lt;RandomAccessIteratorIterator&gt;            ::value_type::first_type&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:gabfbaa27bf2f95ce5806e19e6fc4980e9"><td class="memTemplItemLeft" align="right" valign="top">RandomAccessIterator3&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#gabfbaa27bf2f95ce5806e19e6fc4980e9">multiway_merge</a> (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type size, Comparator comp=Comparator(), <a class="el" href="group__tlx__algorithm.html#ga98e900a348b28aa3709eb5e6d897ffbb">MultiwayMergeAlgorithm</a> mwma=<a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbba332bba921707cc62f6a682b8ac2c9013">MWMA_ALGORITHM_DEFAULT</a>)</td></tr>
<tr class="memdesc:gabfbaa27bf2f95ce5806e19e6fc4980e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequential multi-way merge.  <a href="group__tlx__algorithm.html#gabfbaa27bf2f95ce5806e19e6fc4980e9">More...</a><br /></td></tr>
<tr class="separator:gabfbaa27bf2f95ce5806e19e6fc4980e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d2560e55c9bda04200cc2dfceda4d94"><td class="memTemplParams" colspan="2">template&lt;bool Stable, bool Sentinels, typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename Comparator  = std::less&lt;        typename std::iterator_traits&lt;            typename std::iterator_traits&lt;RandomAccessIteratorIterator&gt;            ::value_type::first_type&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:ga1d2560e55c9bda04200cc2dfceda4d94"><td class="memTemplItemLeft" align="right" valign="top">RandomAccessIterator3&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#ga1d2560e55c9bda04200cc2dfceda4d94">multiway_merge_base</a> (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type size, Comparator comp=Comparator(), <a class="el" href="group__tlx__algorithm.html#ga98e900a348b28aa3709eb5e6d897ffbb">MultiwayMergeAlgorithm</a> mwma=<a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbba332bba921707cc62f6a682b8ac2c9013">MWMA_ALGORITHM_DEFAULT</a>)</td></tr>
<tr class="memdesc:ga1d2560e55c9bda04200cc2dfceda4d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequential multi-way merging switch.  <a href="group__tlx__algorithm.html#ga1d2560e55c9bda04200cc2dfceda4d94">More...</a><br /></td></tr>
<tr class="separator:ga1d2560e55c9bda04200cc2dfceda4d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6211397a04bfb4f213fceb2ae79f3ba1"><td class="memTemplParams" colspan="2">template&lt;bool Stable, typename RandomAccessIteratorIterator , typename Comparator &gt; </td></tr>
<tr class="memitem:ga6211397a04bfb4f213fceb2ae79f3ba1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#ga6211397a04bfb4f213fceb2ae79f3ba1">multiway_merge_exact_splitting</a> (const RandomAccessIteratorIterator &amp;seqs_begin, const RandomAccessIteratorIterator &amp;seqs_end, typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type size, typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type total_size, Comparator comp, std::vector&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type &gt; *chunks, const size_t num_threads)</td></tr>
<tr class="memdesc:ga6211397a04bfb4f213fceb2ae79f3ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splitting method for parallel multi-way merge routine: use multisequence selection for exact splitting.  <a href="group__tlx__algorithm.html#ga6211397a04bfb4f213fceb2ae79f3ba1">More...</a><br /></td></tr>
<tr class="separator:ga6211397a04bfb4f213fceb2ae79f3ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc54aa6bde4767b7ccf503674494494b"><td class="memTemplParams" colspan="2">template&lt;bool Stable, typename RandomAccessIteratorIterator , typename Comparator &gt; </td></tr>
<tr class="memitem:gacc54aa6bde4767b7ccf503674494494b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#gacc54aa6bde4767b7ccf503674494494b">multiway_merge_sampling_splitting</a> (const RandomAccessIteratorIterator &amp;seqs_begin, const RandomAccessIteratorIterator &amp;seqs_end, typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type size, typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type total_size, Comparator comp, std::vector&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type &gt; *chunks, const size_t num_threads, const size_t merge_oversampling)</td></tr>
<tr class="memdesc:gacc54aa6bde4767b7ccf503674494494b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splitting method for parallel multi-way merge routine: use sampling and binary search for in-exact splitting.  <a href="group__tlx__algorithm.html#gacc54aa6bde4767b7ccf503674494494b">More...</a><br /></td></tr>
<tr class="separator:gacc54aa6bde4767b7ccf503674494494b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36d2d7a6f5b247579d7e863c82323ed6"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename Comparator  = std::less&lt;        typename std::iterator_traits&lt;            typename std::iterator_traits&lt;RandomAccessIteratorIterator&gt;            ::value_type::first_type&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:ga36d2d7a6f5b247579d7e863c82323ed6"><td class="memTemplItemLeft" align="right" valign="top">RandomAccessIterator3&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#ga36d2d7a6f5b247579d7e863c82323ed6">multiway_merge_sentinels</a> (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type size, Comparator comp=Comparator(), <a class="el" href="group__tlx__algorithm.html#ga98e900a348b28aa3709eb5e6d897ffbb">MultiwayMergeAlgorithm</a> mwma=<a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbba332bba921707cc62f6a682b8ac2c9013">MWMA_ALGORITHM_DEFAULT</a>)</td></tr>
<tr class="memdesc:ga36d2d7a6f5b247579d7e863c82323ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequential multi-way merge with sentinels in sequences.  <a href="group__tlx__algorithm.html#ga36d2d7a6f5b247579d7e863c82323ed6">More...</a><br /></td></tr>
<tr class="separator:ga36d2d7a6f5b247579d7e863c82323ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga054ee2cfd2bd32928806134be36ae33c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__container.html#ga054ee2cfd2bd32928806134be36ae33c">operator!=</a> (const std::string &amp;a, const <a class="el" href="classtlx_1_1StringView.html">StringView</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:ga054ee2cfd2bd32928806134be36ae33c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality operator to compare a std::string with a <a class="el" href="classtlx_1_1StringView.html" title="StringView is a reference to a part of a string, consisting of only a char pointer and a length...">StringView</a>.  <a href="group__tlx__container.html#ga054ee2cfd2bd32928806134be36ae33c">More...</a><br /></td></tr>
<tr class="separator:ga054ee2cfd2bd32928806134be36ae33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d08f6faf8bede3dfb9d75ac1f731d48"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__container.html#ga0d08f6faf8bede3dfb9d75ac1f731d48">operator&lt;</a> (const std::string &amp;a, const <a class="el" href="classtlx_1_1StringView.html">StringView</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:ga0d08f6faf8bede3dfb9d75ac1f731d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less operator to compare a std::string with a <a class="el" href="classtlx_1_1StringView.html" title="StringView is a reference to a part of a string, consisting of only a char pointer and a length...">StringView</a> lexicographically.  <a href="group__tlx__container.html#ga0d08f6faf8bede3dfb9d75ac1f731d48">More...</a><br /></td></tr>
<tr class="separator:ga0d08f6faf8bede3dfb9d75ac1f731d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571b1c19ce4d530c4aaa3cd797c8ccae"><td class="memTemplParams" colspan="2">template&lt;typename A , typename D &gt; </td></tr>
<tr class="memitem:a571b1c19ce4d530c4aaa3cd797c8ccae"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a571b1c19ce4d530c4aaa3cd797c8ccae">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classtlx_1_1CountingPtr.html">CountingPtr</a>&lt; A, D &gt; &amp;c)</td></tr>
<tr class="memdesc:a571b1c19ce4d530c4aaa3cd797c8ccae"><td class="mdescLeft">&#160;</td><td class="mdescRight">print pointer  <a href="#a571b1c19ce4d530c4aaa3cd797c8ccae">More...</a><br /></td></tr>
<tr class="separator:a571b1c19ce4d530c4aaa3cd797c8ccae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9a9af0024876a54443f35667e7f620bd"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__container.html#ga9a9af0024876a54443f35667e7f620bd">operator==</a> (const std::string &amp;a, const <a class="el" href="classtlx_1_1StringView.html">StringView</a> &amp;b) noexcept</td></tr>
<tr class="memdesc:ga9a9af0024876a54443f35667e7f620bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator to compare a std::string with a <a class="el" href="classtlx_1_1StringView.html" title="StringView is a reference to a part of a string, consisting of only a char pointer and a length...">StringView</a>.  <a href="group__tlx__container.html#ga9a9af0024876a54443f35667e7f620bd">More...</a><br /></td></tr>
<tr class="separator:ga9a9af0024876a54443f35667e7f620bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60ca8653250ad56e209887e5e7183328"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga60ca8653250ad56e209887e5e7183328">pad</a> (const std::string &amp;s, size_t len, char pad_char=' ')</td></tr>
<tr class="memdesc:ga60ca8653250ad56e209887e5e7183328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate or pad string to exactly len characters.  <a href="group__tlx__string.html#ga60ca8653250ad56e209887e5e7183328">More...</a><br /></td></tr>
<tr class="separator:ga60ca8653250ad56e209887e5e7183328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3580dd876ff80d088499292a12d2fbe"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename Comparator  = std::less&lt;        typename std::iterator_traits&lt;            typename std::iterator_traits&lt;RandomAccessIteratorIterator&gt;            ::value_type::first_type&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:gac3580dd876ff80d088499292a12d2fbe"><td class="memTemplItemLeft" align="right" valign="top">RandomAccessIterator3&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#gac3580dd876ff80d088499292a12d2fbe">parallel_multiway_merge</a> (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, const typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type size, Comparator comp=Comparator(), <a class="el" href="group__tlx__algorithm.html#ga98e900a348b28aa3709eb5e6d897ffbb">MultiwayMergeAlgorithm</a> mwma=<a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbba332bba921707cc62f6a682b8ac2c9013">MWMA_ALGORITHM_DEFAULT</a>, <a class="el" href="group__tlx__algorithm.html#ga8a7342a22bda2a80ef56d779ceae36c0">MultiwayMergeSplittingAlgorithm</a> mwmsa=<a class="el" href="group__tlx__algorithm.html#gga8a7342a22bda2a80ef56d779ceae36c0acfb06584091121c62050c13c54e0e298">MWMSA_DEFAULT</a>, size_t num_threads=std::thread::hardware_concurrency())</td></tr>
<tr class="memdesc:gac3580dd876ff80d088499292a12d2fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel multi-way merge routine.  <a href="group__tlx__algorithm.html#gac3580dd876ff80d088499292a12d2fbe">More...</a><br /></td></tr>
<tr class="separator:gac3580dd876ff80d088499292a12d2fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga267435a66c9b4a25471ea4233318e3cb"><td class="memTemplParams" colspan="2">template&lt;bool Stable, typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename Comparator  = std::less&lt;        typename std::iterator_traits&lt;            typename std::iterator_traits&lt;RandomAccessIteratorIterator&gt;            ::value_type::first_type&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:ga267435a66c9b4a25471ea4233318e3cb"><td class="memTemplItemLeft" align="right" valign="top">RandomAccessIterator3&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#ga267435a66c9b4a25471ea4233318e3cb">parallel_multiway_merge_base</a> (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, const typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type size, Comparator comp=Comparator(), <a class="el" href="group__tlx__algorithm.html#ga98e900a348b28aa3709eb5e6d897ffbb">MultiwayMergeAlgorithm</a> mwma=<a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbba332bba921707cc62f6a682b8ac2c9013">MWMA_ALGORITHM_DEFAULT</a>, <a class="el" href="group__tlx__algorithm.html#ga8a7342a22bda2a80ef56d779ceae36c0">MultiwayMergeSplittingAlgorithm</a> mwmsa=<a class="el" href="group__tlx__algorithm.html#gga8a7342a22bda2a80ef56d779ceae36c0acfb06584091121c62050c13c54e0e298">MWMSA_DEFAULT</a>, size_t num_threads=std::thread::hardware_concurrency())</td></tr>
<tr class="memdesc:ga267435a66c9b4a25471ea4233318e3cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel multi-way merge routine.  <a href="group__tlx__algorithm.html#ga267435a66c9b4a25471ea4233318e3cb">More...</a><br /></td></tr>
<tr class="separator:ga267435a66c9b4a25471ea4233318e3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf080f97856fc44ecf724cb8693a0e62e"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename Comparator  = std::less&lt;        typename std::iterator_traits&lt;            typename std::iterator_traits&lt;RandomAccessIteratorIterator&gt;            ::value_type::first_type&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:gaf080f97856fc44ecf724cb8693a0e62e"><td class="memTemplItemLeft" align="right" valign="top">RandomAccessIterator3&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#gaf080f97856fc44ecf724cb8693a0e62e">parallel_multiway_merge_sentinels</a> (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, const typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type size, Comparator comp=Comparator(), <a class="el" href="group__tlx__algorithm.html#ga98e900a348b28aa3709eb5e6d897ffbb">MultiwayMergeAlgorithm</a> mwma=<a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbba332bba921707cc62f6a682b8ac2c9013">MWMA_ALGORITHM_DEFAULT</a>, <a class="el" href="group__tlx__algorithm.html#ga8a7342a22bda2a80ef56d779ceae36c0">MultiwayMergeSplittingAlgorithm</a> mwmsa=<a class="el" href="group__tlx__algorithm.html#gga8a7342a22bda2a80ef56d779ceae36c0acfb06584091121c62050c13c54e0e298">MWMSA_DEFAULT</a>, size_t num_threads=std::thread::hardware_concurrency())</td></tr>
<tr class="memdesc:gaf080f97856fc44ecf724cb8693a0e62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel multi-way merge routine with sentinels.  <a href="group__tlx__algorithm.html#gaf080f97856fc44ecf724cb8693a0e62e">More...</a><br /></td></tr>
<tr class="separator:gaf080f97856fc44ecf724cb8693a0e62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58be0557b1b38913b28d947c935aed42"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga58be0557b1b38913b28d947c935aed42">parse_si_iec_units</a> (const char *str, uint64_t *out_size, char default_unit=0)</td></tr>
<tr class="memdesc:ga58be0557b1b38913b28d947c935aed42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a string like "343KB" or "44 GiB" into the corresponding size in bytes.  <a href="group__tlx__string.html#ga58be0557b1b38913b28d947c935aed42">More...</a><br /></td></tr>
<tr class="separator:ga58be0557b1b38913b28d947c935aed42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42a656ed3586b515140cb71b312f0f9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga42a656ed3586b515140cb71b312f0f9b">parse_si_iec_units</a> (const std::string &amp;str, uint64_t *out_size, char default_unit=0)</td></tr>
<tr class="memdesc:ga42a656ed3586b515140cb71b312f0f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a string like "343KB" or "44 GiB" into the corresponding size in bytes.  <a href="group__tlx__string.html#ga42a656ed3586b515140cb71b312f0f9b">More...</a><br /></td></tr>
<tr class="separator:ga42a656ed3586b515140cb71b312f0f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae864e24c9d78a352064ad8fceb697e55"><td class="memTemplParams" colspan="2">template&lt;typename Integral &gt; </td></tr>
<tr class="memitem:gae864e24c9d78a352064ad8fceb697e55"><td class="memTemplItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gae864e24c9d78a352064ad8fceb697e55">popcount</a> (Integral i)</td></tr>
<tr class="memdesc:gae864e24c9d78a352064ad8fceb697e55"><td class="mdescLeft">&#160;</td><td class="mdescRight">popcount (count one bits)  <a href="group__tlx__math.html#gae864e24c9d78a352064ad8fceb697e55">More...</a><br /></td></tr>
<tr class="separator:gae864e24c9d78a352064ad8fceb697e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3f89a64cdf1d3898582f0df35f5e2a8"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gaf3f89a64cdf1d3898582f0df35f5e2a8">popcount</a> (const void *data, size_t size)</td></tr>
<tr class="separator:gaf3f89a64cdf1d3898582f0df35f5e2a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1cee3526742e5893696078ba3d1c0b7"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gaf1cee3526742e5893696078ba3d1c0b7">popcount_generic16</a> (uint16_t x)</td></tr>
<tr class="memdesc:gaf1cee3526742e5893696078ba3d1c0b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">popcount (count one bits) - generic SWAR implementation  <a href="group__tlx__math.html#gaf1cee3526742e5893696078ba3d1c0b7">More...</a><br /></td></tr>
<tr class="separator:gaf1cee3526742e5893696078ba3d1c0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76093e52ae7ebbc456337cecf6be1f49"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga76093e52ae7ebbc456337cecf6be1f49">popcount_generic32</a> (uint32_t x)</td></tr>
<tr class="separator:ga76093e52ae7ebbc456337cecf6be1f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c47ec108a261f9665d1d078a82ae620"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga4c47ec108a261f9665d1d078a82ae620">popcount_generic64</a> (uint64_t x)</td></tr>
<tr class="memdesc:ga4c47ec108a261f9665d1d078a82ae620"><td class="mdescLeft">&#160;</td><td class="mdescRight">popcount (count one bits) - generic SWAR implementation  <a href="group__tlx__math.html#ga4c47ec108a261f9665d1d078a82ae620">More...</a><br /></td></tr>
<tr class="separator:ga4c47ec108a261f9665d1d078a82ae620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe8cb953b2abbc624cfb1b3736a8e8ae"><td class="memItemLeft" align="right" valign="top">static unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gafe8cb953b2abbc624cfb1b3736a8e8ae">popcount_generic8</a> (uint8_t x)</td></tr>
<tr class="memdesc:gafe8cb953b2abbc624cfb1b3736a8e8ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">popcount (count one bits) - generic SWAR implementation  <a href="group__tlx__math.html#gafe8cb953b2abbc624cfb1b3736a8e8ae">More...</a><br /></td></tr>
<tr class="separator:gafe8cb953b2abbc624cfb1b3736a8e8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa229c79302101383f000b3b473009c85"><td class="memTemplParams" colspan="2">template&lt;unsigned D, typename T &gt; </td></tr>
<tr class="memitem:gaa229c79302101383f000b3b473009c85"><td class="memTemplItemLeft" align="right" valign="top">static constexpr <a class="el" href="logistic__regression_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gaa229c79302101383f000b3b473009c85">power_to_the</a> (<a class="el" href="logistic__regression_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> x)</td></tr>
<tr class="memdesc:gaa229c79302101383f000b3b473009c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">power_to_the&lt;D&gt;(x)  <a href="group__tlx__math.html#gaa229c79302101383f000b3b473009c85">More...</a><br /></td></tr>
<tr class="separator:gaa229c79302101383f000b3b473009c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga635866c58aa0826d8c8ea7097f913935"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIt , typename RandomBits &gt; </td></tr>
<tr class="memitem:ga635866c58aa0826d8c8ea7097f913935"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#ga635866c58aa0826d8c8ea7097f913935">random_bipartition_shuffle</a> (RandomAccessIt begin, RandomAccessIt end, size_t size_left_partition, RandomBits &amp;urng)</td></tr>
<tr class="memdesc:ga635866c58aa0826d8c8ea7097f913935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to std::shuffle, but only generates a random bi-partition.  <a href="group__tlx__algorithm.html#ga635866c58aa0826d8c8ea7097f913935">More...</a><br /></td></tr>
<tr class="separator:ga635866c58aa0826d8c8ea7097f913935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7415c322c6257a35cfe0d6929c45407"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gac7415c322c6257a35cfe0d6929c45407">rol32</a> (const uint32_t &amp;x, int i)</td></tr>
<tr class="memdesc:gac7415c322c6257a35cfe0d6929c45407"><td class="mdescLeft">&#160;</td><td class="mdescRight">rol32 - generic  <a href="group__tlx__math.html#gac7415c322c6257a35cfe0d6929c45407">More...</a><br /></td></tr>
<tr class="separator:gac7415c322c6257a35cfe0d6929c45407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6516bdadfc6166cfb0a117d6091fb727"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga6516bdadfc6166cfb0a117d6091fb727">rol32_generic</a> (const uint32_t &amp;x, int i)</td></tr>
<tr class="memdesc:ga6516bdadfc6166cfb0a117d6091fb727"><td class="mdescLeft">&#160;</td><td class="mdescRight">rol32 - generic implementation  <a href="group__tlx__math.html#ga6516bdadfc6166cfb0a117d6091fb727">More...</a><br /></td></tr>
<tr class="separator:ga6516bdadfc6166cfb0a117d6091fb727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae43c4e90fb93555810dc0a04364a6796"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gae43c4e90fb93555810dc0a04364a6796">rol64</a> (const uint64_t &amp;x, int i)</td></tr>
<tr class="memdesc:gae43c4e90fb93555810dc0a04364a6796"><td class="mdescLeft">&#160;</td><td class="mdescRight">rol64 - generic  <a href="group__tlx__math.html#gae43c4e90fb93555810dc0a04364a6796">More...</a><br /></td></tr>
<tr class="separator:gae43c4e90fb93555810dc0a04364a6796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d4a226ca1fa55b6e4b5921ca3f492b5"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga1d4a226ca1fa55b6e4b5921ca3f492b5">rol64_generic</a> (const uint64_t &amp;x, int i)</td></tr>
<tr class="memdesc:ga1d4a226ca1fa55b6e4b5921ca3f492b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">rol64 - generic implementation  <a href="group__tlx__math.html#ga1d4a226ca1fa55b6e4b5921ca3f492b5">More...</a><br /></td></tr>
<tr class="separator:ga1d4a226ca1fa55b6e4b5921ca3f492b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga719bbc1834b484884e10ac303a00ec5f"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga719bbc1834b484884e10ac303a00ec5f">ror32</a> (const uint32_t &amp;x, int i)</td></tr>
<tr class="memdesc:ga719bbc1834b484884e10ac303a00ec5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">ror32 - generic  <a href="group__tlx__math.html#ga719bbc1834b484884e10ac303a00ec5f">More...</a><br /></td></tr>
<tr class="separator:ga719bbc1834b484884e10ac303a00ec5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga771f50ed60fe713a5beab0da4647cfb5"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga771f50ed60fe713a5beab0da4647cfb5">ror32_generic</a> (const uint32_t &amp;x, int i)</td></tr>
<tr class="memdesc:ga771f50ed60fe713a5beab0da4647cfb5"><td class="mdescLeft">&#160;</td><td class="mdescRight">ror32 - generic implementation  <a href="group__tlx__math.html#ga771f50ed60fe713a5beab0da4647cfb5">More...</a><br /></td></tr>
<tr class="separator:ga771f50ed60fe713a5beab0da4647cfb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1719724a19036752c629c8195f732d3"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gaa1719724a19036752c629c8195f732d3">ror64</a> (const uint64_t &amp;x, int i)</td></tr>
<tr class="memdesc:gaa1719724a19036752c629c8195f732d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">ror64 - generic  <a href="group__tlx__math.html#gaa1719724a19036752c629c8195f732d3">More...</a><br /></td></tr>
<tr class="separator:gaa1719724a19036752c629c8195f732d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd2e7233a05f4964ad832a285e7d3b48"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gacd2e7233a05f4964ad832a285e7d3b48">ror64_generic</a> (const uint64_t &amp;x, int i)</td></tr>
<tr class="memdesc:gacd2e7233a05f4964ad832a285e7d3b48"><td class="mdescLeft">&#160;</td><td class="mdescRight">ror64 - generic implementation  <a href="group__tlx__math.html#gacd2e7233a05f4964ad832a285e7d3b48">More...</a><br /></td></tr>
<tr class="separator:gacd2e7233a05f4964ad832a285e7d3b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e1503ff2006eab64f6a702bb4965b35"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga8e1503ff2006eab64f6a702bb4965b35">round_down_to_power_of_two</a> (int i)</td></tr>
<tr class="memdesc:ga8e1503ff2006eab64f6a702bb4965b35"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: round down to next power of two  <a href="group__tlx__math.html#ga8e1503ff2006eab64f6a702bb4965b35">More...</a><br /></td></tr>
<tr class="separator:ga8e1503ff2006eab64f6a702bb4965b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad62c547eed2088bf2e338952977c2696"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gad62c547eed2088bf2e338952977c2696">round_down_to_power_of_two</a> (unsigned int i)</td></tr>
<tr class="memdesc:gad62c547eed2088bf2e338952977c2696"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: round down to next power of two  <a href="group__tlx__math.html#gad62c547eed2088bf2e338952977c2696">More...</a><br /></td></tr>
<tr class="separator:gad62c547eed2088bf2e338952977c2696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83557872685572d2bab35dacf6940240"><td class="memItemLeft" align="right" valign="top">static long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga83557872685572d2bab35dacf6940240">round_down_to_power_of_two</a> (long i)</td></tr>
<tr class="memdesc:ga83557872685572d2bab35dacf6940240"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: round down to next power of two  <a href="group__tlx__math.html#ga83557872685572d2bab35dacf6940240">More...</a><br /></td></tr>
<tr class="separator:ga83557872685572d2bab35dacf6940240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fc146aedd8d10a8572d7523b890c65f"><td class="memItemLeft" align="right" valign="top">static unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga0fc146aedd8d10a8572d7523b890c65f">round_down_to_power_of_two</a> (unsigned long i)</td></tr>
<tr class="memdesc:ga0fc146aedd8d10a8572d7523b890c65f"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: round down to next power of two  <a href="group__tlx__math.html#ga0fc146aedd8d10a8572d7523b890c65f">More...</a><br /></td></tr>
<tr class="separator:ga0fc146aedd8d10a8572d7523b890c65f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99a4ae2fc070fbdd749f0678cacd7cd5"><td class="memItemLeft" align="right" valign="top">static long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga99a4ae2fc070fbdd749f0678cacd7cd5">round_down_to_power_of_two</a> (long long i)</td></tr>
<tr class="memdesc:ga99a4ae2fc070fbdd749f0678cacd7cd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: round down to next power of two  <a href="group__tlx__math.html#ga99a4ae2fc070fbdd749f0678cacd7cd5">More...</a><br /></td></tr>
<tr class="separator:ga99a4ae2fc070fbdd749f0678cacd7cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14aac3576b27b2d819ca2de74865930b"><td class="memItemLeft" align="right" valign="top">static unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga14aac3576b27b2d819ca2de74865930b">round_down_to_power_of_two</a> (unsigned long long i)</td></tr>
<tr class="memdesc:ga14aac3576b27b2d819ca2de74865930b"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: round down to next power of two  <a href="group__tlx__math.html#ga14aac3576b27b2d819ca2de74865930b">More...</a><br /></td></tr>
<tr class="separator:ga14aac3576b27b2d819ca2de74865930b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefac500d32be52ed8c10ce60e75396f8"><td class="memTemplParams" colspan="2">template&lt;typename IntegralN , typename IntegralK &gt; </td></tr>
<tr class="memitem:gaefac500d32be52ed8c10ce60e75396f8"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gaefac500d32be52ed8c10ce60e75396f8">round_up</a> (const IntegralN &amp;n, const IntegralK &amp;k) -&gt; decltype(n+k)</td></tr>
<tr class="memdesc:gaefac500d32be52ed8c10ce60e75396f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">round n up to the next multiple of k, for n and k positive!  <a href="group__tlx__math.html#gaefac500d32be52ed8c10ce60e75396f8">More...</a><br /></td></tr>
<tr class="separator:gaefac500d32be52ed8c10ce60e75396f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga615a4ea8e2e4afc7a4458665fa2c7f3e"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga615a4ea8e2e4afc7a4458665fa2c7f3e">round_up_to_power_of_two</a> (int i)</td></tr>
<tr class="memdesc:ga615a4ea8e2e4afc7a4458665fa2c7f3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: round up to next power of two  <a href="group__tlx__math.html#ga615a4ea8e2e4afc7a4458665fa2c7f3e">More...</a><br /></td></tr>
<tr class="separator:ga615a4ea8e2e4afc7a4458665fa2c7f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e08db92d8bd0a2bf0125128f1e60f67"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga8e08db92d8bd0a2bf0125128f1e60f67">round_up_to_power_of_two</a> (unsigned int i)</td></tr>
<tr class="memdesc:ga8e08db92d8bd0a2bf0125128f1e60f67"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: round up to next power of two  <a href="group__tlx__math.html#ga8e08db92d8bd0a2bf0125128f1e60f67">More...</a><br /></td></tr>
<tr class="separator:ga8e08db92d8bd0a2bf0125128f1e60f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga949a8d8a48175dda1fde458fbf6441b7"><td class="memItemLeft" align="right" valign="top">static long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga949a8d8a48175dda1fde458fbf6441b7">round_up_to_power_of_two</a> (long i)</td></tr>
<tr class="memdesc:ga949a8d8a48175dda1fde458fbf6441b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: round up to next power of two  <a href="group__tlx__math.html#ga949a8d8a48175dda1fde458fbf6441b7">More...</a><br /></td></tr>
<tr class="separator:ga949a8d8a48175dda1fde458fbf6441b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga444256634f36f74fed26ddb2994fb39b"><td class="memItemLeft" align="right" valign="top">static unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga444256634f36f74fed26ddb2994fb39b">round_up_to_power_of_two</a> (unsigned long i)</td></tr>
<tr class="memdesc:ga444256634f36f74fed26ddb2994fb39b"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: round up to next power of two  <a href="group__tlx__math.html#ga444256634f36f74fed26ddb2994fb39b">More...</a><br /></td></tr>
<tr class="separator:ga444256634f36f74fed26ddb2994fb39b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab826ccef9deef2a0b9a88f318de84b3c"><td class="memItemLeft" align="right" valign="top">static long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gab826ccef9deef2a0b9a88f318de84b3c">round_up_to_power_of_two</a> (long long i)</td></tr>
<tr class="memdesc:gab826ccef9deef2a0b9a88f318de84b3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: round up to next power of two  <a href="group__tlx__math.html#gab826ccef9deef2a0b9a88f318de84b3c">More...</a><br /></td></tr>
<tr class="separator:gab826ccef9deef2a0b9a88f318de84b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae376e5cd1611f929c26fd0691c47e00e"><td class="memItemLeft" align="right" valign="top">static unsigned long long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gae376e5cd1611f929c26fd0691c47e00e">round_up_to_power_of_two</a> (unsigned long long i)</td></tr>
<tr class="memdesc:gae376e5cd1611f929c26fd0691c47e00e"><td class="mdescLeft">&#160;</td><td class="mdescRight">does what it says: round up to next power of two  <a href="group__tlx__math.html#gae376e5cd1611f929c26fd0691c47e00e">More...</a><br /></td></tr>
<tr class="separator:gae376e5cd1611f929c26fd0691c47e00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga165140a3f756701491e3958c9858ea2c"><td class="memTemplParams" colspan="2">template&lt;typename Integral &gt; </td></tr>
<tr class="memitem:ga165140a3f756701491e3958c9858ea2c"><td class="memTemplItemLeft" align="right" valign="top">static Integral&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#ga165140a3f756701491e3958c9858ea2c">round_up_to_power_of_two_template</a> (Integral n)</td></tr>
<tr class="separator:ga165140a3f756701491e3958c9858ea2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17989dc1fbbf1047c8f238aaafe7092"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#aa17989dc1fbbf1047c8f238aaafe7092">set_die_with_exception</a> (bool b)</td></tr>
<tr class="separator:aa17989dc1fbbf1047c8f238aaafe7092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a369d24d80d405a29502266c3c3742b42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1LoggerOutputHook.html">LoggerOutputHook</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a369d24d80d405a29502266c3c3742b42">set_logger_output_hook</a> (<a class="el" href="classtlx_1_1LoggerOutputHook.html">LoggerOutputHook</a> *hook)</td></tr>
<tr class="separator:a369d24d80d405a29502266c3c3742b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f6fd6485b3c32e7706d585634e012d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1LoggerPrefixHook.html">LoggerPrefixHook</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a6f6fd6485b3c32e7706d585634e012d0">set_logger_prefix_hook</a> (<a class="el" href="classtlx_1_1LoggerPrefixHook.html">LoggerPrefixHook</a> *hook)</td></tr>
<tr class="separator:a6f6fd6485b3c32e7706d585634e012d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafcbf5e112757758add1662cf66498d0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1LoggerOutputHook.html">LoggerOutputHook</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#aafcbf5e112757758add1662cf66498d0">set_logger_to_stderr</a> ()</td></tr>
<tr class="separator:aafcbf5e112757758add1662cf66498d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c8b16a3abcb4dc450a0a62b42c554dd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__port.html#ga1c8b16a3abcb4dc450a0a62b42c554dd">setenv</a> (const char *name, const char *value, int overwrite)</td></tr>
<tr class="memdesc:ga1c8b16a3abcb4dc450a0a62b42c554dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">setenv - change or add an environment variable Windows porting madness because <a class="el" href="group__tlx__port.html#ga1c8b16a3abcb4dc450a0a62b42c554dd" title="setenv - change or add an environment variable Windows porting madness because setenv() is apparently...">setenv()</a> is apparently dangerous  <a href="group__tlx__port.html#ga1c8b16a3abcb4dc450a0a62b42c554dd">More...</a><br /></td></tr>
<tr class="separator:ga1c8b16a3abcb4dc450a0a62b42c554dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9910d02bd636f05e8abe338e1a40e70"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae9910d02bd636f05e8abe338e1a40e70"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__math.html#gae9910d02bd636f05e8abe338e1a40e70">sgn</a> (const <a class="el" href="logistic__regression_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> &amp;val)</td></tr>
<tr class="memdesc:gae9910d02bd636f05e8abe338e1a40e70"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="group__tlx__math.html#gae9910d02bd636f05e8abe338e1a40e70" title="sgn() - signum ">sgn()</a> - signum  <a href="group__tlx__math.html#gae9910d02bd636f05e8abe338e1a40e70">More...</a><br /></td></tr>
<tr class="separator:gae9910d02bd636f05e8abe338e1a40e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e9766edc39a64fab5be44d202d7d34c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__digest.html#ga3e9766edc39a64fab5be44d202d7d34c">sha1_hex</a> (const void *data, uint32_t size)</td></tr>
<tr class="memdesc:ga3e9766edc39a64fab5be44d202d7d34c"><td class="mdescLeft">&#160;</td><td class="mdescRight">process data and return 20 byte (160 bit) digest hex encoded  <a href="group__tlx__digest.html#ga3e9766edc39a64fab5be44d202d7d34c">More...</a><br /></td></tr>
<tr class="separator:ga3e9766edc39a64fab5be44d202d7d34c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0d2b96d1009d969add4fed13446c65d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__digest.html#gae0d2b96d1009d969add4fed13446c65d">sha1_hex</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:gae0d2b96d1009d969add4fed13446c65d"><td class="mdescLeft">&#160;</td><td class="mdescRight">process data and return 20 byte (160 bit) digest hex encoded  <a href="group__tlx__digest.html#gae0d2b96d1009d969add4fed13446c65d">More...</a><br /></td></tr>
<tr class="separator:gae0d2b96d1009d969add4fed13446c65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab71383f80da55d26496c1bc6b48bab12"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__digest.html#gab71383f80da55d26496c1bc6b48bab12">sha1_hex_uc</a> (const void *data, uint32_t size)</td></tr>
<tr class="memdesc:gab71383f80da55d26496c1bc6b48bab12"><td class="mdescLeft">&#160;</td><td class="mdescRight">process data and return 20 byte (160 bit) digest upper-case hex encoded  <a href="group__tlx__digest.html#gab71383f80da55d26496c1bc6b48bab12">More...</a><br /></td></tr>
<tr class="separator:gab71383f80da55d26496c1bc6b48bab12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15daa9d133058039c094baaddc6cf3db"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__digest.html#ga15daa9d133058039c094baaddc6cf3db">sha1_hex_uc</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga15daa9d133058039c094baaddc6cf3db"><td class="mdescLeft">&#160;</td><td class="mdescRight">process data and return 20 byte (160 bit) digest upper-case hex encoded  <a href="group__tlx__digest.html#ga15daa9d133058039c094baaddc6cf3db">More...</a><br /></td></tr>
<tr class="separator:ga15daa9d133058039c094baaddc6cf3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c04418e1c7a4c39382a4a3a1c8f9390"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__digest.html#ga6c04418e1c7a4c39382a4a3a1c8f9390">sha256_hex</a> (const void *data, uint32_t size)</td></tr>
<tr class="memdesc:ga6c04418e1c7a4c39382a4a3a1c8f9390"><td class="mdescLeft">&#160;</td><td class="mdescRight">process data and return 32 byte (256 bit) digest hex encoded  <a href="group__tlx__digest.html#ga6c04418e1c7a4c39382a4a3a1c8f9390">More...</a><br /></td></tr>
<tr class="separator:ga6c04418e1c7a4c39382a4a3a1c8f9390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga690a14d912e56fae0b09769749152902"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__digest.html#ga690a14d912e56fae0b09769749152902">sha256_hex</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga690a14d912e56fae0b09769749152902"><td class="mdescLeft">&#160;</td><td class="mdescRight">process data and return 32 byte (256 bit) digest hex encoded  <a href="group__tlx__digest.html#ga690a14d912e56fae0b09769749152902">More...</a><br /></td></tr>
<tr class="separator:ga690a14d912e56fae0b09769749152902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9eb05c3cd2b1509b710fe7c9c710015d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__digest.html#ga9eb05c3cd2b1509b710fe7c9c710015d">sha256_hex_uc</a> (const void *data, uint32_t size)</td></tr>
<tr class="memdesc:ga9eb05c3cd2b1509b710fe7c9c710015d"><td class="mdescLeft">&#160;</td><td class="mdescRight">process data and return 32 byte (256 bit) digest upper-case hex encoded  <a href="group__tlx__digest.html#ga9eb05c3cd2b1509b710fe7c9c710015d">More...</a><br /></td></tr>
<tr class="separator:ga9eb05c3cd2b1509b710fe7c9c710015d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga571e2c64128b6f6ffade57368a1208e1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__digest.html#ga571e2c64128b6f6ffade57368a1208e1">sha256_hex_uc</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga571e2c64128b6f6ffade57368a1208e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">process data and return 32 byte (256 bit) digest upper-case hex encoded  <a href="group__tlx__digest.html#ga571e2c64128b6f6ffade57368a1208e1">More...</a><br /></td></tr>
<tr class="separator:ga571e2c64128b6f6ffade57368a1208e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf708f5c7d1dc3811189bdfb7c514475b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__digest.html#gaf708f5c7d1dc3811189bdfb7c514475b">sha512_hex</a> (const void *data, uint32_t size)</td></tr>
<tr class="memdesc:gaf708f5c7d1dc3811189bdfb7c514475b"><td class="mdescLeft">&#160;</td><td class="mdescRight">process data and return 64 byte (512 bit) digest hex encoded  <a href="group__tlx__digest.html#gaf708f5c7d1dc3811189bdfb7c514475b">More...</a><br /></td></tr>
<tr class="separator:gaf708f5c7d1dc3811189bdfb7c514475b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae316a9dc1dd8f7632b69b1038e3fe46"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__digest.html#gaae316a9dc1dd8f7632b69b1038e3fe46">sha512_hex</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:gaae316a9dc1dd8f7632b69b1038e3fe46"><td class="mdescLeft">&#160;</td><td class="mdescRight">process data and return 64 byte (512 bit) digest hex encoded  <a href="group__tlx__digest.html#gaae316a9dc1dd8f7632b69b1038e3fe46">More...</a><br /></td></tr>
<tr class="separator:gaae316a9dc1dd8f7632b69b1038e3fe46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7520cfaab5fa32dce14570c3ab3bd374"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__digest.html#ga7520cfaab5fa32dce14570c3ab3bd374">sha512_hex_uc</a> (const void *data, uint32_t size)</td></tr>
<tr class="memdesc:ga7520cfaab5fa32dce14570c3ab3bd374"><td class="mdescLeft">&#160;</td><td class="mdescRight">process data and return 64 byte (512 bit) digest upper-case hex encoded  <a href="group__tlx__digest.html#ga7520cfaab5fa32dce14570c3ab3bd374">More...</a><br /></td></tr>
<tr class="separator:ga7520cfaab5fa32dce14570c3ab3bd374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadff7a13fb05332384ae53656f9f43c0e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__digest.html#gadff7a13fb05332384ae53656f9f43c0e">sha512_hex_uc</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:gadff7a13fb05332384ae53656f9f43c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">process data and return 64 byte (512 bit) digest upper-case hex encoded  <a href="group__tlx__digest.html#gadff7a13fb05332384ae53656f9f43c0e">More...</a><br /></td></tr>
<tr class="separator:gadff7a13fb05332384ae53656f9f43c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac377d7abe96391a306d74f49c1f92ab0"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ac377d7abe96391a306d74f49c1f92ab0">siphash</a> (const uint8_t key[16], const uint8_t *msg, size_t size)</td></tr>
<tr class="separator:ac377d7abe96391a306d74f49c1f92ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5b74a8ec4e849ee19578715c65836ab"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ab5b74a8ec4e849ee19578715c65836ab">siphash</a> (const uint8_t *msg, size_t size)</td></tr>
<tr class="separator:ab5b74a8ec4e849ee19578715c65836ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3b1c56cc81840ced52f695ee4bcfdd"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a9a3b1c56cc81840ced52f695ee4bcfdd">siphash</a> (const char *msg, size_t size)</td></tr>
<tr class="separator:a9a3b1c56cc81840ced52f695ee4bcfdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8194cb6726acefe4fd4f7993c1b1fdfd"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a8194cb6726acefe4fd4f7993c1b1fdfd">siphash</a> (const std::string &amp;str)</td></tr>
<tr class="separator:a8194cb6726acefe4fd4f7993c1b1fdfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e52665aa49af074f344396ad6264f8"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a36e52665aa49af074f344396ad6264f8"><td class="memTemplItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a36e52665aa49af074f344396ad6264f8">siphash</a> (const Type &amp;value)</td></tr>
<tr class="separator:a36e52665aa49af074f344396ad6264f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbb7e10c5e866474d0a516ba06388f8"><td class="memItemLeft" align="right" valign="top">static uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a1dbb7e10c5e866474d0a516ba06388f8">siphash_plain</a> (const uint8_t key[16], const uint8_t *m, size_t len)</td></tr>
<tr class="separator:a1dbb7e10c5e866474d0a516ba06388f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a2095ef4e565c914bbbab9b8ddeb5fe"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename Tree , typename Compare &gt; </td></tr>
<tr class="memitem:ga4a2095ef4e565c914bbbab9b8ddeb5fe"><td class="memTemplItemLeft" align="right" valign="top">Tree *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__container.html#ga4a2095ef4e565c914bbbab9b8ddeb5fe">splay</a> (const Key &amp;k, Tree *t, const Compare &amp;cmp)</td></tr>
<tr class="separator:ga4a2095ef4e565c914bbbab9b8ddeb5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d9d3030d15353337ec87bb84cbd0d4b"><td class="memTemplParams" colspan="2">template&lt;typename Tree , typename Compare &gt; </td></tr>
<tr class="memitem:ga0d9d3030d15353337ec87bb84cbd0d4b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__container.html#ga0d9d3030d15353337ec87bb84cbd0d4b">splay_check</a> (const Tree *t, const Tree *&amp;out_tmin, const Tree *&amp;out_tmax, const Compare &amp;cmp)</td></tr>
<tr class="memdesc:ga0d9d3030d15353337ec87bb84cbd0d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">check the tree order, recursively calculate min and max elements  <a href="group__tlx__container.html#ga0d9d3030d15353337ec87bb84cbd0d4b">More...</a><br /></td></tr>
<tr class="separator:ga0d9d3030d15353337ec87bb84cbd0d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefd27b9686bc2139cc43490f13c16315"><td class="memTemplParams" colspan="2">template&lt;typename Tree , typename Compare &gt; </td></tr>
<tr class="memitem:gaefd27b9686bc2139cc43490f13c16315"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__container.html#gaefd27b9686bc2139cc43490f13c16315">splay_check</a> (const Tree *t, const Compare &amp;cmp)</td></tr>
<tr class="memdesc:gaefd27b9686bc2139cc43490f13c16315"><td class="mdescLeft">&#160;</td><td class="mdescRight">check the tree order  <a href="group__tlx__container.html#gaefd27b9686bc2139cc43490f13c16315">More...</a><br /></td></tr>
<tr class="separator:gaefd27b9686bc2139cc43490f13c16315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae768c3fbbdebb44b09b92637c285b8f7"><td class="memTemplParams" colspan="2">template&lt;typename Key , typename Tree , typename Compare &gt; </td></tr>
<tr class="memitem:gae768c3fbbdebb44b09b92637c285b8f7"><td class="memTemplItemLeft" align="right" valign="top">Tree *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__container.html#gae768c3fbbdebb44b09b92637c285b8f7">splay_erase</a> (const Key &amp;k, Tree *&amp;t, const Compare &amp;cmp)</td></tr>
<tr class="separator:gae768c3fbbdebb44b09b92637c285b8f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad3cc3fe23b6946ec8147fd163c167f3e"><td class="memTemplParams" colspan="2">template&lt;typename Tree , typename Compare &gt; </td></tr>
<tr class="memitem:gad3cc3fe23b6946ec8147fd163c167f3e"><td class="memTemplItemLeft" align="right" valign="top">Tree *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__container.html#gad3cc3fe23b6946ec8147fd163c167f3e">splay_insert</a> (Tree *nn, Tree *t, const Compare &amp;cmp)</td></tr>
<tr class="separator:gad3cc3fe23b6946ec8147fd163c167f3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8f0e0a9f2fa6150b5c8c5270a31ad89"><td class="memTemplParams" colspan="2">template&lt;typename Tree , typename Functor &gt; </td></tr>
<tr class="memitem:gad8f0e0a9f2fa6150b5c8c5270a31ad89"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__container.html#gad8f0e0a9f2fa6150b5c8c5270a31ad89">splay_traverse_postorder</a> (const Functor &amp;f, Tree *t)</td></tr>
<tr class="memdesc:gad8f0e0a9f2fa6150b5c8c5270a31ad89"><td class="mdescLeft">&#160;</td><td class="mdescRight">traverse the tree in postorder (left, right, node)  <a href="group__tlx__container.html#gad8f0e0a9f2fa6150b5c8c5270a31ad89">More...</a><br /></td></tr>
<tr class="separator:gad8f0e0a9f2fa6150b5c8c5270a31ad89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac719dadccd01dfa9a38fee2943f08134"><td class="memTemplParams" colspan="2">template&lt;typename Tree , typename Functor &gt; </td></tr>
<tr class="memitem:gac719dadccd01dfa9a38fee2943f08134"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__container.html#gac719dadccd01dfa9a38fee2943f08134">splay_traverse_preorder</a> (const Functor &amp;f, const Tree *t)</td></tr>
<tr class="memdesc:gac719dadccd01dfa9a38fee2943f08134"><td class="mdescLeft">&#160;</td><td class="mdescRight">traverse the tree in preorder (left, node, right)  <a href="group__tlx__container.html#gac719dadccd01dfa9a38fee2943f08134">More...</a><br /></td></tr>
<tr class="separator:gac719dadccd01dfa9a38fee2943f08134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae88597e53210df27ef4d5db668a02fa7"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ae88597e53210df27ef4d5db668a02fa7">split</a> (std::vector&lt; std::string &gt; *into, const char *sep, size_t sep_size, const std::string &amp;str, std::string::size_type limit)</td></tr>
<tr class="separator:ae88597e53210df27ef4d5db668a02fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92d58b1e8b06cbb57400b5959281a4a1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga92d58b1e8b06cbb57400b5959281a4a1">split_words</a> (const std::string &amp;str, std::string::size_type limit=std::string::npos)</td></tr>
<tr class="memdesc:ga92d58b1e8b06cbb57400b5959281a4a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string by whitespaces into distinct words.  <a href="group__tlx__string.html#ga92d58b1e8b06cbb57400b5959281a4a1">More...</a><br /></td></tr>
<tr class="separator:ga92d58b1e8b06cbb57400b5959281a4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafc9efa79c49c462b0ee723e4f9b384d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gaafc9efa79c49c462b0ee723e4f9b384d">ssnprintf</a> (size_t max_size, const char *fmt,...) <a class="el" href="group__tlx__define.html#ga246a72d6938b4e4a40f11571a676b472">TLX_ATTRIBUTE_FORMAT_PRINTF</a>(2</td></tr>
<tr class="memdesc:gaafc9efa79c49c462b0ee723e4f9b384d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for return the result of a snprintf() call inside a std::string.  <a href="group__tlx__string.html#gaafc9efa79c49c462b0ee723e4f9b384d">More...</a><br /></td></tr>
<tr class="separator:gaafc9efa79c49c462b0ee723e4f9b384d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cc4f715331a96631370a8a25d6e9526"><td class="memTemplParams" colspan="2">template&lt;typename String  = std::string&gt; </td></tr>
<tr class="memitem:ga1cc4f715331a96631370a8a25d6e9526"><td class="memTemplItemLeft" align="right" valign="top">String&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga1cc4f715331a96631370a8a25d6e9526">ssnprintf_generic</a> (size_t max_size, const char *fmt,...) <a class="el" href="group__tlx__define.html#ga246a72d6938b4e4a40f11571a676b472">TLX_ATTRIBUTE_FORMAT_PRINTF</a>(2</td></tr>
<tr class="memdesc:ga1cc4f715331a96631370a8a25d6e9526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for return the result of a snprintf() call inside a string object.  <a href="group__tlx__string.html#ga1cc4f715331a96631370a8a25d6e9526">More...</a><br /></td></tr>
<tr class="separator:ga1cc4f715331a96631370a8a25d6e9526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cc4f715331a96631370a8a25d6e9526"><td class="memTemplParams" colspan="2">template&lt;typename String &gt; </td></tr>
<tr class="memitem:ga1cc4f715331a96631370a8a25d6e9526"><td class="memTemplItemLeft" align="right" valign="top">String String&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ga1cc4f715331a96631370a8a25d6e9526">ssnprintf_generic</a> (size_t max_size, const char *fmt,...)</td></tr>
<tr class="separator:ga1cc4f715331a96631370a8a25d6e9526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5a94b0f02730f1df3009eb5ce67eb17"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gae5a94b0f02730f1df3009eb5ce67eb17">ssprintf</a> (const char *fmt,...) <a class="el" href="group__tlx__define.html#ga246a72d6938b4e4a40f11571a676b472">TLX_ATTRIBUTE_FORMAT_PRINTF</a>(1</td></tr>
<tr class="memdesc:gae5a94b0f02730f1df3009eb5ce67eb17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for return the result of a sprintf() call inside a std::string.  <a href="group__tlx__string.html#gae5a94b0f02730f1df3009eb5ce67eb17">More...</a><br /></td></tr>
<tr class="separator:gae5a94b0f02730f1df3009eb5ce67eb17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa45e4c8639177f5deb682313a572c32b"><td class="memTemplParams" colspan="2">template&lt;typename String  = std::string&gt; </td></tr>
<tr class="memitem:gaa45e4c8639177f5deb682313a572c32b"><td class="memTemplItemLeft" align="right" valign="top">String&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gaa45e4c8639177f5deb682313a572c32b">ssprintf_generic</a> (const char *fmt,...) <a class="el" href="group__tlx__define.html#ga246a72d6938b4e4a40f11571a676b472">TLX_ATTRIBUTE_FORMAT_PRINTF</a>(1</td></tr>
<tr class="memdesc:gaa45e4c8639177f5deb682313a572c32b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for return the result of a sprintf() call inside a string object.  <a href="group__tlx__string.html#gaa45e4c8639177f5deb682313a572c32b">More...</a><br /></td></tr>
<tr class="separator:gaa45e4c8639177f5deb682313a572c32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa45e4c8639177f5deb682313a572c32b"><td class="memTemplParams" colspan="2">template&lt;typename String &gt; </td></tr>
<tr class="memitem:gaa45e4c8639177f5deb682313a572c32b"><td class="memTemplItemLeft" align="right" valign="top">String String&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#gaa45e4c8639177f5deb682313a572c32b">ssprintf_generic</a> (const char *fmt,...)</td></tr>
<tr class="separator:gaa45e4c8639177f5deb682313a572c32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5a6467af7f10ab6f206eb3f9b3e0e4e"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename Comparator  = std::less&lt;        typename std::iterator_traits&lt;            typename std::iterator_traits&lt;RandomAccessIteratorIterator&gt;            ::value_type::first_type&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:gab5a6467af7f10ab6f206eb3f9b3e0e4e"><td class="memTemplItemLeft" align="right" valign="top">RandomAccessIterator3&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#gab5a6467af7f10ab6f206eb3f9b3e0e4e">stable_multiway_merge</a> (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type size, Comparator comp=Comparator(), <a class="el" href="group__tlx__algorithm.html#ga98e900a348b28aa3709eb5e6d897ffbb">MultiwayMergeAlgorithm</a> mwma=<a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbba332bba921707cc62f6a682b8ac2c9013">MWMA_ALGORITHM_DEFAULT</a>)</td></tr>
<tr class="memdesc:gab5a6467af7f10ab6f206eb3f9b3e0e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stable sequential multi-way merge.  <a href="group__tlx__algorithm.html#gab5a6467af7f10ab6f206eb3f9b3e0e4e">More...</a><br /></td></tr>
<tr class="separator:gab5a6467af7f10ab6f206eb3f9b3e0e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2db163874c1c8e389c2736a72decb5f"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename Comparator  = std::less&lt;        typename std::iterator_traits&lt;            typename std::iterator_traits&lt;RandomAccessIteratorIterator&gt;            ::value_type::first_type&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:gac2db163874c1c8e389c2736a72decb5f"><td class="memTemplItemLeft" align="right" valign="top">RandomAccessIterator3&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#gac2db163874c1c8e389c2736a72decb5f">stable_multiway_merge_sentinels</a> (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type size, Comparator comp=Comparator(), <a class="el" href="group__tlx__algorithm.html#ga98e900a348b28aa3709eb5e6d897ffbb">MultiwayMergeAlgorithm</a> mwma=<a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbba332bba921707cc62f6a682b8ac2c9013">MWMA_ALGORITHM_DEFAULT</a>)</td></tr>
<tr class="memdesc:gac2db163874c1c8e389c2736a72decb5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stable sequential multi-way merge with sentinels in sequences.  <a href="group__tlx__algorithm.html#gac2db163874c1c8e389c2736a72decb5f">More...</a><br /></td></tr>
<tr class="separator:gac2db163874c1c8e389c2736a72decb5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6f27252c44641af08a7297588ab1e6b"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename Comparator  = std::less&lt;        typename std::iterator_traits&lt;            typename std::iterator_traits&lt;RandomAccessIteratorIterator&gt;            ::value_type::first_type&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:gae6f27252c44641af08a7297588ab1e6b"><td class="memTemplItemLeft" align="right" valign="top">RandomAccessIterator3&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#gae6f27252c44641af08a7297588ab1e6b">stable_parallel_multiway_merge</a> (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, const typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type size, Comparator comp=Comparator(), <a class="el" href="group__tlx__algorithm.html#ga98e900a348b28aa3709eb5e6d897ffbb">MultiwayMergeAlgorithm</a> mwma=<a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbba332bba921707cc62f6a682b8ac2c9013">MWMA_ALGORITHM_DEFAULT</a>, <a class="el" href="group__tlx__algorithm.html#ga8a7342a22bda2a80ef56d779ceae36c0">MultiwayMergeSplittingAlgorithm</a> mwmsa=<a class="el" href="group__tlx__algorithm.html#gga8a7342a22bda2a80ef56d779ceae36c0acfb06584091121c62050c13c54e0e298">MWMSA_DEFAULT</a>, size_t num_threads=std::thread::hardware_concurrency())</td></tr>
<tr class="memdesc:gae6f27252c44641af08a7297588ab1e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stable parallel multi-way merge routine.  <a href="group__tlx__algorithm.html#gae6f27252c44641af08a7297588ab1e6b">More...</a><br /></td></tr>
<tr class="separator:gae6f27252c44641af08a7297588ab1e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1bcd8deadd96750e476982b2d572fcf"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename Comparator  = std::less&lt;        typename std::iterator_traits&lt;            typename std::iterator_traits&lt;RandomAccessIteratorIterator&gt;            ::value_type::first_type&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:gae1bcd8deadd96750e476982b2d572fcf"><td class="memTemplItemLeft" align="right" valign="top">RandomAccessIterator3&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#gae1bcd8deadd96750e476982b2d572fcf">stable_parallel_multiway_merge_sentinels</a> (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, const typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type size, Comparator comp=Comparator(), <a class="el" href="group__tlx__algorithm.html#ga98e900a348b28aa3709eb5e6d897ffbb">MultiwayMergeAlgorithm</a> mwma=<a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbba332bba921707cc62f6a682b8ac2c9013">MWMA_ALGORITHM_DEFAULT</a>, <a class="el" href="group__tlx__algorithm.html#ga8a7342a22bda2a80ef56d779ceae36c0">MultiwayMergeSplittingAlgorithm</a> mwmsa=<a class="el" href="group__tlx__algorithm.html#gga8a7342a22bda2a80ef56d779ceae36c0acfb06584091121c62050c13c54e0e298">MWMSA_DEFAULT</a>, size_t num_threads=std::thread::hardware_concurrency())</td></tr>
<tr class="memdesc:gae1bcd8deadd96750e476982b2d572fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stable parallel multi-way merge routine with sentinels.  <a href="group__tlx__algorithm.html#gae1bcd8deadd96750e476982b2d572fcf">More...</a><br /></td></tr>
<tr class="separator:gae1bcd8deadd96750e476982b2d572fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77af8ef839dcd6f90d26bcb68413df1b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga77af8ef839dcd6f90d26bcb68413df1b">starts_with</a> (const char *str, const char *match)</td></tr>
<tr class="memdesc:ga77af8ef839dcd6f90d26bcb68413df1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the start of this string.  <a href="group__tlx__string.html#ga77af8ef839dcd6f90d26bcb68413df1b">More...</a><br /></td></tr>
<tr class="separator:ga77af8ef839dcd6f90d26bcb68413df1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabdd7c8689c583acd1e58e5b87b18ae4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gaabdd7c8689c583acd1e58e5b87b18ae4">starts_with</a> (const char *str, const std::string &amp;match)</td></tr>
<tr class="memdesc:gaabdd7c8689c583acd1e58e5b87b18ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the start of this string.  <a href="group__tlx__string.html#gaabdd7c8689c583acd1e58e5b87b18ae4">More...</a><br /></td></tr>
<tr class="separator:gaabdd7c8689c583acd1e58e5b87b18ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga125efbe989d08402389613766af825b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga125efbe989d08402389613766af825b5">starts_with</a> (const std::string &amp;str, const char *match)</td></tr>
<tr class="memdesc:ga125efbe989d08402389613766af825b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the start of this string.  <a href="group__tlx__string.html#ga125efbe989d08402389613766af825b5">More...</a><br /></td></tr>
<tr class="separator:ga125efbe989d08402389613766af825b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc5cce7e8c7fd30078b9129a7ae1d74b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gadc5cce7e8c7fd30078b9129a7ae1d74b">starts_with</a> (const std::string &amp;str, const std::string &amp;match)</td></tr>
<tr class="memdesc:gadc5cce7e8c7fd30078b9129a7ae1d74b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the start of this string.  <a href="group__tlx__string.html#gadc5cce7e8c7fd30078b9129a7ae1d74b">More...</a><br /></td></tr>
<tr class="separator:gadc5cce7e8c7fd30078b9129a7ae1d74b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ca04814cbc556649adfd9fa2dbb40e6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga9ca04814cbc556649adfd9fa2dbb40e6">starts_with_icase</a> (const char *str, const char *match)</td></tr>
<tr class="memdesc:ga9ca04814cbc556649adfd9fa2dbb40e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the start of this string.  <a href="group__tlx__string.html#ga9ca04814cbc556649adfd9fa2dbb40e6">More...</a><br /></td></tr>
<tr class="separator:ga9ca04814cbc556649adfd9fa2dbb40e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f3acf713798426fde1285f5ccab8922"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga9f3acf713798426fde1285f5ccab8922">starts_with_icase</a> (const char *str, const std::string &amp;match)</td></tr>
<tr class="memdesc:ga9f3acf713798426fde1285f5ccab8922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the start of this string.  <a href="group__tlx__string.html#ga9f3acf713798426fde1285f5ccab8922">More...</a><br /></td></tr>
<tr class="separator:ga9f3acf713798426fde1285f5ccab8922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6d169441d65d96bceb7c936e88afc67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gab6d169441d65d96bceb7c936e88afc67">starts_with_icase</a> (const std::string &amp;str, const char *match)</td></tr>
<tr class="memdesc:gab6d169441d65d96bceb7c936e88afc67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the start of this string.  <a href="group__tlx__string.html#gab6d169441d65d96bceb7c936e88afc67">More...</a><br /></td></tr>
<tr class="separator:gab6d169441d65d96bceb7c936e88afc67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbcdc1f2a056e954b197ce9c1d236522"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gadbcdc1f2a056e954b197ce9c1d236522">starts_with_icase</a> (const std::string &amp;str, const std::string &amp;match)</td></tr>
<tr class="memdesc:gadbcdc1f2a056e954b197ce9c1d236522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the start of this string.  <a href="group__tlx__string.html#gadbcdc1f2a056e954b197ce9c1d236522">More...</a><br /></td></tr>
<tr class="separator:gadbcdc1f2a056e954b197ce9c1d236522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1320658af9846df1831480a96e7a38"><td class="memTemplParams" colspan="2">template&lt;typename A , typename D &gt; </td></tr>
<tr class="memitem:ade1320658af9846df1831480a96e7a38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ade1320658af9846df1831480a96e7a38">swap</a> (<a class="el" href="classtlx_1_1CountingPtr.html">CountingPtr</a>&lt; A, D &gt; &amp;a1, <a class="el" href="classtlx_1_1CountingPtr.html">CountingPtr</a>&lt; A, D &gt; &amp;a2) noexcept</td></tr>
<tr class="separator:ade1320658af9846df1831480a96e7a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae9556f2da6820a4e4b5f85c4ab229e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a5ae9556f2da6820a4e4b5f85c4ab229e">timestamp</a> ()</td></tr>
<tr class="memdesc:a5ae9556f2da6820a4e4b5f85c4ab229e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of seconds since the epoch, currently microsecond resolution.  <a href="#a5ae9556f2da6820a4e4b5f85c4ab229e">More...</a><br /></td></tr>
<tr class="separator:a5ae9556f2da6820a4e4b5f85c4ab229e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga355a332620f8220ecbb0dc5a0aa67350"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga355a332620f8220ecbb0dc5a0aa67350">to_lower</a> (char ch)</td></tr>
<tr class="memdesc:ga355a332620f8220ecbb0dc5a0aa67350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform the given character to lower case without any localization.  <a href="group__tlx__string.html#ga355a332620f8220ecbb0dc5a0aa67350">More...</a><br /></td></tr>
<tr class="separator:ga355a332620f8220ecbb0dc5a0aa67350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ec240b74b77e3ce42f8d67079dea430"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga4ec240b74b77e3ce42f8d67079dea430">to_lower</a> (std::string *str)</td></tr>
<tr class="memdesc:ga4ec240b74b77e3ce42f8d67079dea430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the given string to lowercase and returns a reference to it.  <a href="group__tlx__string.html#ga4ec240b74b77e3ce42f8d67079dea430">More...</a><br /></td></tr>
<tr class="separator:ga4ec240b74b77e3ce42f8d67079dea430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga647f5157d00473cf9bf37c92044bd9a8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga647f5157d00473cf9bf37c92044bd9a8">to_lower</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga647f5157d00473cf9bf37c92044bd9a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the given string converted to lowercase.  <a href="group__tlx__string.html#ga647f5157d00473cf9bf37c92044bd9a8">More...</a><br /></td></tr>
<tr class="separator:ga647f5157d00473cf9bf37c92044bd9a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa00b5d705507da8f74f1ba3874174d8d"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gaa00b5d705507da8f74f1ba3874174d8d">to_upper</a> (char ch)</td></tr>
<tr class="memdesc:gaa00b5d705507da8f74f1ba3874174d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform the given character to upper case without any localization.  <a href="group__tlx__string.html#gaa00b5d705507da8f74f1ba3874174d8d">More...</a><br /></td></tr>
<tr class="separator:gaa00b5d705507da8f74f1ba3874174d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d9edcc3303203825126d7d422e8ab75"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga7d9edcc3303203825126d7d422e8ab75">to_upper</a> (std::string *str)</td></tr>
<tr class="memdesc:ga7d9edcc3303203825126d7d422e8ab75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the given string to uppercase and returns a reference to it.  <a href="group__tlx__string.html#ga7d9edcc3303203825126d7d422e8ab75">More...</a><br /></td></tr>
<tr class="separator:ga7d9edcc3303203825126d7d422e8ab75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2be559f6e498862bec070f122feb6e14"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga2be559f6e498862bec070f122feb6e14">to_upper</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga2be559f6e498862bec070f122feb6e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the given string converted to uppercase.  <a href="group__tlx__string.html#ga2be559f6e498862bec070f122feb6e14">More...</a><br /></td></tr>
<tr class="separator:ga2be559f6e498862bec070f122feb6e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39619db78c7e916bff3544fb07cbe462"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga39619db78c7e916bff3544fb07cbe462">union_words</a> (const std::string &amp;wordsA, const std::string &amp;wordsB)</td></tr>
<tr class="memdesc:ga39619db78c7e916bff3544fb07cbe462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return union of two keyword sets.  <a href="group__tlx__string.html#ga39619db78c7e916bff3544fb07cbe462">More...</a><br /></td></tr>
<tr class="separator:ga39619db78c7e916bff3544fb07cbe462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a63b398e6678264958fb8590e9332bf"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:a5a63b398e6678264958fb8590e9332bf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a5a63b398e6678264958fb8590e9332bf">unused</a> (Types &amp;&amp;...)</td></tr>
<tr class="separator:a5a63b398e6678264958fb8590e9332bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e74e205a0ec4b2d823fd7baf42dcd82"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a3e74e205a0ec4b2d823fd7baf42dcd82"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a3e74e205a0ec4b2d823fd7baf42dcd82">vector_free</a> (std::vector&lt; Type &gt; &amp;v)</td></tr>
<tr class="separator:a3e74e205a0ec4b2d823fd7baf42dcd82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga44a90b0de44f0e1aa17ae215db35f458"><td class="memTemplParams" colspan="2">template&lt;typename... Types&gt; </td></tr>
<tr class="memitem:ga44a90b0de44f0e1aa17ae215db35f458"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__meta.html#ga44a90b0de44f0e1aa17ae215db35f458">vexpand</a> (Types &amp;&amp;...)</td></tr>
<tr class="separator:ga44a90b0de44f0e1aa17ae215db35f458"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a1c233e7ab713b8f8f77f7149f2bc4b"><td class="memTemplParams" colspan="2">template&lt;size_t Size, typename Functor &gt; </td></tr>
<tr class="memitem:ga4a1c233e7ab713b8f8f77f7149f2bc4b"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__meta.html#ga4a1c233e7ab713b8f8f77f7149f2bc4b">vmap_for_range</a> (Functor &amp;&amp;f)</td></tr>
<tr class="memdesc:ga4a1c233e7ab713b8f8f77f7149f2bc4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vmap a generic functor (like a generic lambda) for the integers [0,Size).  <a href="group__tlx__meta.html#ga4a1c233e7ab713b8f8f77f7149f2bc4b">More...</a><br /></td></tr>
<tr class="separator:ga4a1c233e7ab713b8f8f77f7149f2bc4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36807642146dd614b63d26ed6bba9c19"><td class="memTemplParams" colspan="2">template&lt;size_t Begin, size_t End, typename Functor &gt; </td></tr>
<tr class="memitem:ga36807642146dd614b63d26ed6bba9c19"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__meta.html#ga36807642146dd614b63d26ed6bba9c19">vmap_for_range</a> (Functor &amp;&amp;f)</td></tr>
<tr class="memdesc:ga36807642146dd614b63d26ed6bba9c19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vmap a generic functor (like a generic lambda) for the integers [Begin,End).  <a href="group__tlx__meta.html#ga36807642146dd614b63d26ed6bba9c19">More...</a><br /></td></tr>
<tr class="separator:ga36807642146dd614b63d26ed6bba9c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ce911b2bcb8fbc0ea881194265f7f5a"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:ga0ce911b2bcb8fbc0ea881194265f7f5a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__meta.html#ga0ce911b2bcb8fbc0ea881194265f7f5a">vmap_foreach</a> (Functor &amp;&amp;f, Args &amp;&amp;... args)</td></tr>
<tr class="separator:ga0ce911b2bcb8fbc0ea881194265f7f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d427a6295fdc8b9b037794a785e9926"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename Tuple &gt; </td></tr>
<tr class="memitem:ga3d427a6295fdc8b9b037794a785e9926"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__meta.html#ga3d427a6295fdc8b9b037794a785e9926">vmap_foreach_tuple</a> (Functor &amp;&amp;f, Tuple &amp;&amp;t)</td></tr>
<tr class="separator:ga3d427a6295fdc8b9b037794a785e9926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac60978f8100125dbfddf607bdf0cf412"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename Tuple &gt; </td></tr>
<tr class="memitem:gac60978f8100125dbfddf607bdf0cf412"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__meta.html#gac60978f8100125dbfddf607bdf0cf412">vmap_foreach_tuple_with_index</a> (Functor &amp;&amp;f, Tuple &amp;&amp;t)</td></tr>
<tr class="separator:gac60978f8100125dbfddf607bdf0cf412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c22687c38478a6d11053bc19f140a16"><td class="memTemplParams" colspan="2">template&lt;typename Functor , typename... Args&gt; </td></tr>
<tr class="memitem:ga5c22687c38478a6d11053bc19f140a16"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__meta.html#ga5c22687c38478a6d11053bc19f140a16">vmap_foreach_with_index</a> (Functor &amp;&amp;f, Args &amp;&amp;... args)</td></tr>
<tr class="separator:ga5c22687c38478a6d11053bc19f140a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d0ada76ddce7fc09d770fa512780839"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga2d0ada76ddce7fc09d770fa512780839">word_wrap</a> (const std::string &amp;str, unsigned int wrap=80)</td></tr>
<tr class="memdesc:ga2d0ada76ddce7fc09d770fa512780839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to wrap a string to 80 columns without split words.  <a href="group__tlx__string.html#ga2d0ada76ddce7fc09d770fa512780839">More...</a><br /></td></tr>
<tr class="separator:ga2d0ada76ddce7fc09d770fa512780839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2667d7bf97ece107dd08b61ef3a64c82"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a2667d7bf97ece107dd08b61ef3a64c82"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtlx_1_1enable__if.html">enable_if</a>&lt;!<a class="el" href="structtlx_1_1has__ostream__operator.html">has_ostream_operator</a>&lt; Type &gt;::value, const char * &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a2667d7bf97ece107dd08b61ef3a64c82">wrap_unp</a> (Type, const char *instead=&quot;&lt;unprintable&gt;&quot;)</td></tr>
<tr class="separator:a2667d7bf97ece107dd08b61ef3a64c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0ffad4740d8fa55e8ad74591b592083"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ad0ffad4740d8fa55e8ad74591b592083"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtlx_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structtlx_1_1has__ostream__operator.html">has_ostream_operator</a>&lt; Type &gt;::value, Type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ad0ffad4740d8fa55e8ad74591b592083">wrap_unp</a> (Type value, const char *=nullptr)</td></tr>
<tr class="separator:ad0ffad4740d8fa55e8ad74591b592083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4685dbcbe251d930c560b5071ece8049"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:a4685dbcbe251d930c560b5071ece8049"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtlx_1_1enable__if.html">enable_if</a>&lt;!<a class="el" href="structtlx_1_1has__ostream__operator.html">has_ostream_operator</a>&lt; Type &gt;::value, const char * &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a4685dbcbe251d930c560b5071ece8049">wrap_unprintable</a> (Type, const char *instead=&quot;&lt;unprintable&gt;&quot;)</td></tr>
<tr class="separator:a4685dbcbe251d930c560b5071ece8049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3a0f19b5c1679cfe2f825709428dbf"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ace3a0f19b5c1679cfe2f825709428dbf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtlx_1_1enable__if.html">enable_if</a>&lt; <a class="el" href="structtlx_1_1has__ostream__operator.html">has_ostream_operator</a>&lt; Type &gt;::value, Type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ace3a0f19b5c1679cfe2f825709428dbf">wrap_unprintable</a> (Type value, const char *=nullptr)</td></tr>
<tr class="separator:ace3a0f19b5c1679cfe2f825709428dbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Stack Backtrace Printing</div></td></tr>
<tr class="memitem:a5e964500195bf49264036402214d61ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a5e964500195bf49264036402214d61ed">print_raw_backtrace</a> (FILE *out, unsigned int max_frames, const char *fmt,...) <a class="el" href="group__tlx__define.html#ga246a72d6938b4e4a40f11571a676b472">TLX_ATTRIBUTE_FORMAT_PRINTF</a>(3</td></tr>
<tr class="memdesc:a5e964500195bf49264036402214d61ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a plain hex stack backtrace of the called function to FILE* out, prefixed with the given printf formatted output.  <a href="#a5e964500195bf49264036402214d61ed">More...</a><br /></td></tr>
<tr class="separator:a5e964500195bf49264036402214d61ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2bac4967f005d9dd31c0c300eef091"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a1d2bac4967f005d9dd31c0c300eef091">print_raw_backtrace</a> (FILE *out=stderr, unsigned int max_frames=63)</td></tr>
<tr class="memdesc:a1d2bac4967f005d9dd31c0c300eef091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a plain hex stack backtrace of the called function to FILE* out.  <a href="#a1d2bac4967f005d9dd31c0c300eef091">More...</a><br /></td></tr>
<tr class="separator:a1d2bac4967f005d9dd31c0c300eef091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adad32b2f09919dea0ffb70cecfa4ee70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#adad32b2f09919dea0ffb70cecfa4ee70">print_cxx_backtrace</a> (FILE *out=stderr, unsigned int max_frames=63)</td></tr>
<tr class="memdesc:adad32b2f09919dea0ffb70cecfa4ee70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a demangled stack backtrace of the caller function to FILE* out.  <a href="#adad32b2f09919dea0ffb70cecfa4ee70">More...</a><br /></td></tr>
<tr class="separator:adad32b2f09919dea0ffb70cecfa4ee70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393c17d312eb726b7e5631ecef50abee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a393c17d312eb726b7e5631ecef50abee">enable_segv_backtrace</a> ()</td></tr>
<tr class="memdesc:a393c17d312eb726b7e5631ecef50abee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install SIGSEGV signal handler and output backtrace on segmentation fault.  <a href="#a393c17d312eb726b7e5631ecef50abee">More...</a><br /></td></tr>
<tr class="separator:a393c17d312eb726b7e5631ecef50abee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Parallel Sorting Algorithms</div></td></tr>
<tr class="memitem:ga81fdf70add19aa5134ecee16dba0925d"><td class="memTemplParams" colspan="2">template&lt;bool Stable, typename RandomAccessIterator , typename Comparator &gt; </td></tr>
<tr class="memitem:ga81fdf70add19aa5134ecee16dba0925d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#ga81fdf70add19aa5134ecee16dba0925d">parallel_mergesort_base</a> (RandomAccessIterator begin, RandomAccessIterator end, Comparator comp, size_t num_threads=std::thread::hardware_concurrency(), <a class="el" href="group__tlx__algorithm.html#ga8a7342a22bda2a80ef56d779ceae36c0">MultiwayMergeSplittingAlgorithm</a> mwmsa=<a class="el" href="group__tlx__algorithm.html#gga8a7342a22bda2a80ef56d779ceae36c0acfb06584091121c62050c13c54e0e298">MWMSA_DEFAULT</a>)</td></tr>
<tr class="memdesc:ga81fdf70add19aa5134ecee16dba0925d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel multiway mergesort main call.  <a href="group__tlx__sort.html#ga81fdf70add19aa5134ecee16dba0925d">More...</a><br /></td></tr>
<tr class="separator:ga81fdf70add19aa5134ecee16dba0925d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga400ae7e170366e84a4bdb9b6ed1592e7"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator , typename Comparator  = std::less&lt;              typename std::iterator_traits&lt;RandomAccessIterator&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:ga400ae7e170366e84a4bdb9b6ed1592e7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#ga400ae7e170366e84a4bdb9b6ed1592e7">parallel_mergesort</a> (RandomAccessIterator begin, RandomAccessIterator end, Comparator comp=Comparator(), size_t num_threads=std::thread::hardware_concurrency(), <a class="el" href="group__tlx__algorithm.html#ga8a7342a22bda2a80ef56d779ceae36c0">MultiwayMergeSplittingAlgorithm</a> mwmsa=<a class="el" href="group__tlx__algorithm.html#gga8a7342a22bda2a80ef56d779ceae36c0acfb06584091121c62050c13c54e0e298">MWMSA_DEFAULT</a>)</td></tr>
<tr class="memdesc:ga400ae7e170366e84a4bdb9b6ed1592e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel multiway mergesort.  <a href="group__tlx__sort.html#ga400ae7e170366e84a4bdb9b6ed1592e7">More...</a><br /></td></tr>
<tr class="separator:ga400ae7e170366e84a4bdb9b6ed1592e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4aa384ccbe79fdd32a7eec193142781a"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator , typename Comparator  = std::less&lt;              typename std::iterator_traits&lt;RandomAccessIterator&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:ga4aa384ccbe79fdd32a7eec193142781a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#ga4aa384ccbe79fdd32a7eec193142781a">stable_parallel_mergesort</a> (RandomAccessIterator begin, RandomAccessIterator end, Comparator comp=Comparator(), size_t num_threads=std::thread::hardware_concurrency(), <a class="el" href="group__tlx__algorithm.html#ga8a7342a22bda2a80ef56d779ceae36c0">MultiwayMergeSplittingAlgorithm</a> mwmsa=<a class="el" href="group__tlx__algorithm.html#gga8a7342a22bda2a80ef56d779ceae36c0acfb06584091121c62050c13c54e0e298">MWMSA_DEFAULT</a>)</td></tr>
<tr class="memdesc:ga4aa384ccbe79fdd32a7eec193142781a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stable parallel multiway mergesort.  <a href="group__tlx__sort.html#ga4aa384ccbe79fdd32a7eec193142781a">More...</a><br /></td></tr>
<tr class="separator:ga4aa384ccbe79fdd32a7eec193142781a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">String Sorting Algorithms</div></td></tr>
<tr class="memitem:ga8e7fda09de57c231e74a748fe3dfa61c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#ga8e7fda09de57c231e74a748fe3dfa61c">sort_strings</a> (unsigned char **strings, size_t size, size_t memory=0)</td></tr>
<tr class="memdesc:ga8e7fda09de57c231e74a748fe3dfa61c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a set of strings represented by C-style uint8_t* in place.  <a href="group__tlx__sort.html#ga8e7fda09de57c231e74a748fe3dfa61c">More...</a><br /></td></tr>
<tr class="separator:ga8e7fda09de57c231e74a748fe3dfa61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59cb049031e299dda057c08cfc37ad12"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#ga59cb049031e299dda057c08cfc37ad12">sort_strings</a> (char **strings, size_t size, size_t memory=0)</td></tr>
<tr class="memdesc:ga59cb049031e299dda057c08cfc37ad12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a set of strings represented by C-style char* in place.  <a href="group__tlx__sort.html#ga59cb049031e299dda057c08cfc37ad12">More...</a><br /></td></tr>
<tr class="separator:ga59cb049031e299dda057c08cfc37ad12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5923dd19ad5b5ae6912ea324b862d413"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#ga5923dd19ad5b5ae6912ea324b862d413">sort_strings</a> (const unsigned char **strings, size_t size, size_t memory=0)</td></tr>
<tr class="memdesc:ga5923dd19ad5b5ae6912ea324b862d413"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a set of strings represented by C-style uint8_t* in place.  <a href="group__tlx__sort.html#ga5923dd19ad5b5ae6912ea324b862d413">More...</a><br /></td></tr>
<tr class="separator:ga5923dd19ad5b5ae6912ea324b862d413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga877d440e4b1716620e265835f25f8bac"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#ga877d440e4b1716620e265835f25f8bac">sort_strings</a> (const char **strings, size_t size, size_t memory=0)</td></tr>
<tr class="memdesc:ga877d440e4b1716620e265835f25f8bac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a set of strings represented by C-style char* in place.  <a href="group__tlx__sort.html#ga877d440e4b1716620e265835f25f8bac">More...</a><br /></td></tr>
<tr class="separator:ga877d440e4b1716620e265835f25f8bac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29ac55c92effb7152eddc2b30f0faa9a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#ga29ac55c92effb7152eddc2b30f0faa9a">sort_strings</a> (std::vector&lt; char *&gt; &amp;strings, size_t memory=0)</td></tr>
<tr class="memdesc:ga29ac55c92effb7152eddc2b30f0faa9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a set of strings represented by C-style char* in place.  <a href="group__tlx__sort.html#ga29ac55c92effb7152eddc2b30f0faa9a">More...</a><br /></td></tr>
<tr class="separator:ga29ac55c92effb7152eddc2b30f0faa9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf40017beffbe737b6f2ae22d0a0b5f04"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#gaf40017beffbe737b6f2ae22d0a0b5f04">sort_strings</a> (std::vector&lt; unsigned char *&gt; &amp;strings, size_t memory=0)</td></tr>
<tr class="memdesc:gaf40017beffbe737b6f2ae22d0a0b5f04"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a set of strings represented by C-style uint8_t* in place.  <a href="group__tlx__sort.html#gaf40017beffbe737b6f2ae22d0a0b5f04">More...</a><br /></td></tr>
<tr class="separator:gaf40017beffbe737b6f2ae22d0a0b5f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac955a4255c030d6b8f14863e504c1994"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#gac955a4255c030d6b8f14863e504c1994">sort_strings</a> (std::vector&lt; const char *&gt; &amp;strings, size_t memory=0)</td></tr>
<tr class="memdesc:gac955a4255c030d6b8f14863e504c1994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a set of strings represented by C-style char* in place.  <a href="group__tlx__sort.html#gac955a4255c030d6b8f14863e504c1994">More...</a><br /></td></tr>
<tr class="separator:gac955a4255c030d6b8f14863e504c1994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga924f2a1472d92b656212f46431d27bda"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#ga924f2a1472d92b656212f46431d27bda">sort_strings</a> (std::vector&lt; const unsigned char *&gt; &amp;strings, size_t memory=0)</td></tr>
<tr class="memdesc:ga924f2a1472d92b656212f46431d27bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a set of strings represented by C-style uint8_t* in place.  <a href="group__tlx__sort.html#ga924f2a1472d92b656212f46431d27bda">More...</a><br /></td></tr>
<tr class="separator:ga924f2a1472d92b656212f46431d27bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6094e9fc6c7fc7e97ffcb228368fc78b"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#ga6094e9fc6c7fc7e97ffcb228368fc78b">sort_strings</a> (std::string *strings, size_t size, size_t memory=0)</td></tr>
<tr class="memdesc:ga6094e9fc6c7fc7e97ffcb228368fc78b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a set of std::strings in place.  <a href="group__tlx__sort.html#ga6094e9fc6c7fc7e97ffcb228368fc78b">More...</a><br /></td></tr>
<tr class="separator:ga6094e9fc6c7fc7e97ffcb228368fc78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6778267a0a949f16b89401a1a098327c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#ga6778267a0a949f16b89401a1a098327c">sort_strings</a> (std::vector&lt; std::string &gt; &amp;strings, size_t memory=0)</td></tr>
<tr class="memdesc:ga6778267a0a949f16b89401a1a098327c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a vector of std::strings in place.  <a href="group__tlx__sort.html#ga6778267a0a949f16b89401a1a098327c">More...</a><br /></td></tr>
<tr class="separator:ga6778267a0a949f16b89401a1a098327c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9abef83de5b82892c19b1db0dd8435b7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#ga9abef83de5b82892c19b1db0dd8435b7">sort_strings_lcp</a> (unsigned char **strings, size_t size, uint32_t *lcp, size_t memory=0)</td></tr>
<tr class="memdesc:ga9abef83de5b82892c19b1db0dd8435b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a set of strings represented by C-style uint8_t* in place.  <a href="group__tlx__sort.html#ga9abef83de5b82892c19b1db0dd8435b7">More...</a><br /></td></tr>
<tr class="separator:ga9abef83de5b82892c19b1db0dd8435b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8d988c92bbd0175da1f22ba751cf703"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#gae8d988c92bbd0175da1f22ba751cf703">sort_strings_lcp</a> (char **strings, size_t size, uint32_t *lcp, size_t memory=0)</td></tr>
<tr class="memdesc:gae8d988c92bbd0175da1f22ba751cf703"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a set of strings represented by C-style char* in place.  <a href="group__tlx__sort.html#gae8d988c92bbd0175da1f22ba751cf703">More...</a><br /></td></tr>
<tr class="separator:gae8d988c92bbd0175da1f22ba751cf703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c317d68938dcda3909ad844418946ff"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#ga5c317d68938dcda3909ad844418946ff">sort_strings_lcp</a> (const unsigned char **strings, size_t size, uint32_t *lcp, size_t memory=0)</td></tr>
<tr class="memdesc:ga5c317d68938dcda3909ad844418946ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a set of strings represented by C-style uint8_t* in place.  <a href="group__tlx__sort.html#ga5c317d68938dcda3909ad844418946ff">More...</a><br /></td></tr>
<tr class="separator:ga5c317d68938dcda3909ad844418946ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40b8f9a52bf035dad46bf6c51612ed10"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#ga40b8f9a52bf035dad46bf6c51612ed10">sort_strings_lcp</a> (const char **strings, size_t size, uint32_t *lcp, size_t memory=0)</td></tr>
<tr class="memdesc:ga40b8f9a52bf035dad46bf6c51612ed10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a set of strings represented by C-style char* in place.  <a href="group__tlx__sort.html#ga40b8f9a52bf035dad46bf6c51612ed10">More...</a><br /></td></tr>
<tr class="separator:ga40b8f9a52bf035dad46bf6c51612ed10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64dbf577a44e6e19dfd3270410a9b049"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#ga64dbf577a44e6e19dfd3270410a9b049">sort_strings_lcp</a> (std::vector&lt; char *&gt; &amp;strings, uint32_t *lcp, size_t memory=0)</td></tr>
<tr class="memdesc:ga64dbf577a44e6e19dfd3270410a9b049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a set of strings represented by C-style char* in place.  <a href="group__tlx__sort.html#ga64dbf577a44e6e19dfd3270410a9b049">More...</a><br /></td></tr>
<tr class="separator:ga64dbf577a44e6e19dfd3270410a9b049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4bac69d828f901a63c2f429919128380"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#ga4bac69d828f901a63c2f429919128380">sort_strings_lcp</a> (std::vector&lt; unsigned char *&gt; &amp;strings, uint32_t *lcp, size_t memory=0)</td></tr>
<tr class="memdesc:ga4bac69d828f901a63c2f429919128380"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a set of strings represented by C-style uint8_t* in place.  <a href="group__tlx__sort.html#ga4bac69d828f901a63c2f429919128380">More...</a><br /></td></tr>
<tr class="separator:ga4bac69d828f901a63c2f429919128380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb2c23a9c875c81f74795b8318ce670c"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#gaeb2c23a9c875c81f74795b8318ce670c">sort_strings_lcp</a> (std::vector&lt; const char *&gt; &amp;strings, uint32_t *lcp, size_t memory=0)</td></tr>
<tr class="memdesc:gaeb2c23a9c875c81f74795b8318ce670c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a set of strings represented by C-style char* in place.  <a href="group__tlx__sort.html#gaeb2c23a9c875c81f74795b8318ce670c">More...</a><br /></td></tr>
<tr class="separator:gaeb2c23a9c875c81f74795b8318ce670c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3329d3eea256f3a7bc4ed54ec53e4ba6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#ga3329d3eea256f3a7bc4ed54ec53e4ba6">sort_strings_lcp</a> (std::vector&lt; const unsigned char *&gt; &amp;strings, uint32_t *lcp, size_t memory=0)</td></tr>
<tr class="memdesc:ga3329d3eea256f3a7bc4ed54ec53e4ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a set of strings represented by C-style uint8_t* in place.  <a href="group__tlx__sort.html#ga3329d3eea256f3a7bc4ed54ec53e4ba6">More...</a><br /></td></tr>
<tr class="separator:ga3329d3eea256f3a7bc4ed54ec53e4ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaad1b4b054b20f4b88dd0b91248468f58"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#gaad1b4b054b20f4b88dd0b91248468f58">sort_strings_lcp</a> (std::string *strings, size_t size, uint32_t *lcp, size_t memory=0)</td></tr>
<tr class="memdesc:gaad1b4b054b20f4b88dd0b91248468f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a set of std::strings in place.  <a href="group__tlx__sort.html#gaad1b4b054b20f4b88dd0b91248468f58">More...</a><br /></td></tr>
<tr class="separator:gaad1b4b054b20f4b88dd0b91248468f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d4425aaa806ea6ce44e09b6b15b4d12"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#ga3d4425aaa806ea6ce44e09b6b15b4d12">sort_strings_lcp</a> (std::vector&lt; std::string &gt; &amp;strings, uint32_t *lcp, size_t memory=0)</td></tr>
<tr class="memdesc:ga3d4425aaa806ea6ce44e09b6b15b4d12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a vector of std::strings in place.  <a href="group__tlx__sort.html#ga3d4425aaa806ea6ce44e09b6b15b4d12">More...</a><br /></td></tr>
<tr class="separator:ga3d4425aaa806ea6ce44e09b6b15b4d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01d8c1d0d8ebd1260b4b74d81d3e4f4e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#ga01d8c1d0d8ebd1260b4b74d81d3e4f4e">sort_strings_parallel</a> (unsigned char **strings, size_t size, size_t memory=0)</td></tr>
<tr class="memdesc:ga01d8c1d0d8ebd1260b4b74d81d3e4f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a set of strings in parallel represented by C-style uint8_t* in place.  <a href="group__tlx__sort.html#ga01d8c1d0d8ebd1260b4b74d81d3e4f4e">More...</a><br /></td></tr>
<tr class="separator:ga01d8c1d0d8ebd1260b4b74d81d3e4f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9dc6116f75a9ceaf36af593ba9bac288"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#ga9dc6116f75a9ceaf36af593ba9bac288">sort_strings_parallel</a> (char **strings, size_t size, size_t memory=0)</td></tr>
<tr class="memdesc:ga9dc6116f75a9ceaf36af593ba9bac288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a set of strings in parallel represented by C-style char* in place.  <a href="group__tlx__sort.html#ga9dc6116f75a9ceaf36af593ba9bac288">More...</a><br /></td></tr>
<tr class="separator:ga9dc6116f75a9ceaf36af593ba9bac288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga257ebf3fa7b3fc7a301c6ee88d8cd914"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#ga257ebf3fa7b3fc7a301c6ee88d8cd914">sort_strings_parallel</a> (const unsigned char **strings, size_t size, size_t memory=0)</td></tr>
<tr class="memdesc:ga257ebf3fa7b3fc7a301c6ee88d8cd914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a set of strings in parallel represented by C-style uint8_t* in place.  <a href="group__tlx__sort.html#ga257ebf3fa7b3fc7a301c6ee88d8cd914">More...</a><br /></td></tr>
<tr class="separator:ga257ebf3fa7b3fc7a301c6ee88d8cd914"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaa842d824076845984fbb47196f6eb3a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#gaaa842d824076845984fbb47196f6eb3a">sort_strings_parallel</a> (const char **strings, size_t size, size_t memory=0)</td></tr>
<tr class="memdesc:gaaa842d824076845984fbb47196f6eb3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a set of strings in parallel represented by C-style char* in place.  <a href="group__tlx__sort.html#gaaa842d824076845984fbb47196f6eb3a">More...</a><br /></td></tr>
<tr class="separator:gaaa842d824076845984fbb47196f6eb3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a2dc9f2497ccc8405a882d4b47a0944"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#ga7a2dc9f2497ccc8405a882d4b47a0944">sort_strings_parallel</a> (std::vector&lt; char *&gt; &amp;strings, size_t memory=0)</td></tr>
<tr class="memdesc:ga7a2dc9f2497ccc8405a882d4b47a0944"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a set of strings in parallel represented by C-style char* in place.  <a href="group__tlx__sort.html#ga7a2dc9f2497ccc8405a882d4b47a0944">More...</a><br /></td></tr>
<tr class="separator:ga7a2dc9f2497ccc8405a882d4b47a0944"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8d75e0b6e356ac7d1f699a7e327e490"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#gac8d75e0b6e356ac7d1f699a7e327e490">sort_strings_parallel</a> (std::vector&lt; unsigned char *&gt; &amp;strings, size_t memory=0)</td></tr>
<tr class="memdesc:gac8d75e0b6e356ac7d1f699a7e327e490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a set of strings in parallel represented by C-style uint8_t* in place.  <a href="group__tlx__sort.html#gac8d75e0b6e356ac7d1f699a7e327e490">More...</a><br /></td></tr>
<tr class="separator:gac8d75e0b6e356ac7d1f699a7e327e490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae22c7c0ce9080a88a4c7741f8d2a230d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#gae22c7c0ce9080a88a4c7741f8d2a230d">sort_strings_parallel</a> (std::vector&lt; const char *&gt; &amp;strings, size_t memory=0)</td></tr>
<tr class="memdesc:gae22c7c0ce9080a88a4c7741f8d2a230d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a set of strings in parallel represented by C-style char* in place.  <a href="group__tlx__sort.html#gae22c7c0ce9080a88a4c7741f8d2a230d">More...</a><br /></td></tr>
<tr class="separator:gae22c7c0ce9080a88a4c7741f8d2a230d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c695eb54d41188980690c6ebcf1e4cd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#ga9c695eb54d41188980690c6ebcf1e4cd">sort_strings_parallel</a> (std::vector&lt; const unsigned char *&gt; &amp;strings, size_t memory=0)</td></tr>
<tr class="memdesc:ga9c695eb54d41188980690c6ebcf1e4cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a set of strings in parallel represented by C-style uint8_t* in place.  <a href="group__tlx__sort.html#ga9c695eb54d41188980690c6ebcf1e4cd">More...</a><br /></td></tr>
<tr class="separator:ga9c695eb54d41188980690c6ebcf1e4cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e1d512a5f7fa852f4bfd8f3cf0a16dc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#ga2e1d512a5f7fa852f4bfd8f3cf0a16dc">sort_strings_parallel</a> (std::string *strings, size_t size, size_t memory=0)</td></tr>
<tr class="memdesc:ga2e1d512a5f7fa852f4bfd8f3cf0a16dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a set of std::strings in place in parallel.  <a href="group__tlx__sort.html#ga2e1d512a5f7fa852f4bfd8f3cf0a16dc">More...</a><br /></td></tr>
<tr class="separator:ga2e1d512a5f7fa852f4bfd8f3cf0a16dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf103cae75f148a84cec9321975db69cc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#gaf103cae75f148a84cec9321975db69cc">sort_strings_parallel</a> (std::vector&lt; std::string &gt; &amp;strings, size_t memory=0)</td></tr>
<tr class="memdesc:gaf103cae75f148a84cec9321975db69cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a vector of std::strings in place in parallel.  <a href="group__tlx__sort.html#gaf103cae75f148a84cec9321975db69cc">More...</a><br /></td></tr>
<tr class="separator:gaf103cae75f148a84cec9321975db69cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2a4a118fe5614e217845fb9203c1faa"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#gaa2a4a118fe5614e217845fb9203c1faa">sort_strings_parallel_lcp</a> (unsigned char **strings, size_t size, uint32_t *lcp, size_t memory=0)</td></tr>
<tr class="memdesc:gaa2a4a118fe5614e217845fb9203c1faa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a set of strings in parallel represented by C-style uint8_t* in place.  <a href="group__tlx__sort.html#gaa2a4a118fe5614e217845fb9203c1faa">More...</a><br /></td></tr>
<tr class="separator:gaa2a4a118fe5614e217845fb9203c1faa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf10a31cd2dc0012c30aee6d9d36d9b67"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#gaf10a31cd2dc0012c30aee6d9d36d9b67">sort_strings_parallel_lcp</a> (char **strings, size_t size, uint32_t *lcp, size_t memory=0)</td></tr>
<tr class="memdesc:gaf10a31cd2dc0012c30aee6d9d36d9b67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a set of strings in parallel represented by C-style char* in place.  <a href="group__tlx__sort.html#gaf10a31cd2dc0012c30aee6d9d36d9b67">More...</a><br /></td></tr>
<tr class="separator:gaf10a31cd2dc0012c30aee6d9d36d9b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f6fdf8dca03ad872def0f4b83c5df22"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#ga8f6fdf8dca03ad872def0f4b83c5df22">sort_strings_parallel_lcp</a> (const unsigned char **strings, size_t size, uint32_t *lcp, size_t memory=0)</td></tr>
<tr class="memdesc:ga8f6fdf8dca03ad872def0f4b83c5df22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a set of strings in parallel represented by C-style uint8_t* in place.  <a href="group__tlx__sort.html#ga8f6fdf8dca03ad872def0f4b83c5df22">More...</a><br /></td></tr>
<tr class="separator:ga8f6fdf8dca03ad872def0f4b83c5df22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01316949c178bf30efc6e0f299a1042d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#ga01316949c178bf30efc6e0f299a1042d">sort_strings_parallel_lcp</a> (const char **strings, size_t size, uint32_t *lcp, size_t memory=0)</td></tr>
<tr class="memdesc:ga01316949c178bf30efc6e0f299a1042d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a set of strings in parallel represented by C-style char* in place.  <a href="group__tlx__sort.html#ga01316949c178bf30efc6e0f299a1042d">More...</a><br /></td></tr>
<tr class="separator:ga01316949c178bf30efc6e0f299a1042d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00b0441eceeae51298b9c958316c94b6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#ga00b0441eceeae51298b9c958316c94b6">sort_strings_parallel_lcp</a> (std::vector&lt; char *&gt; &amp;strings, uint32_t *lcp, size_t memory=0)</td></tr>
<tr class="memdesc:ga00b0441eceeae51298b9c958316c94b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a set of strings in parallel represented by C-style char* in place.  <a href="group__tlx__sort.html#ga00b0441eceeae51298b9c958316c94b6">More...</a><br /></td></tr>
<tr class="separator:ga00b0441eceeae51298b9c958316c94b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga009bc868254ec42fe37ae1317c28d5ca"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#ga009bc868254ec42fe37ae1317c28d5ca">sort_strings_parallel_lcp</a> (std::vector&lt; unsigned char *&gt; &amp;strings, uint32_t *lcp, size_t memory=0)</td></tr>
<tr class="memdesc:ga009bc868254ec42fe37ae1317c28d5ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a set of strings in parallel represented by C-style uint8_t* in place.  <a href="group__tlx__sort.html#ga009bc868254ec42fe37ae1317c28d5ca">More...</a><br /></td></tr>
<tr class="separator:ga009bc868254ec42fe37ae1317c28d5ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c5b40193b0418ad88a0d6c5d681786e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#ga1c5b40193b0418ad88a0d6c5d681786e">sort_strings_parallel_lcp</a> (std::vector&lt; const char *&gt; &amp;strings, uint32_t *lcp, size_t memory=0)</td></tr>
<tr class="memdesc:ga1c5b40193b0418ad88a0d6c5d681786e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a set of strings in parallel represented by C-style char* in place.  <a href="group__tlx__sort.html#ga1c5b40193b0418ad88a0d6c5d681786e">More...</a><br /></td></tr>
<tr class="separator:ga1c5b40193b0418ad88a0d6c5d681786e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8b0b363f890d166bfdf06e882227148"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#gad8b0b363f890d166bfdf06e882227148">sort_strings_parallel_lcp</a> (std::vector&lt; const unsigned char *&gt; &amp;strings, uint32_t *lcp, size_t memory=0)</td></tr>
<tr class="memdesc:gad8b0b363f890d166bfdf06e882227148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a set of strings in parallel represented by C-style uint8_t* in place.  <a href="group__tlx__sort.html#gad8b0b363f890d166bfdf06e882227148">More...</a><br /></td></tr>
<tr class="separator:gad8b0b363f890d166bfdf06e882227148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab49ea4abd1127021cdeba45947b193a2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#gab49ea4abd1127021cdeba45947b193a2">sort_strings_parallel_lcp</a> (std::string *strings, size_t size, uint32_t *lcp, size_t memory=0)</td></tr>
<tr class="memdesc:gab49ea4abd1127021cdeba45947b193a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a set of std::strings in place in parallel.  <a href="group__tlx__sort.html#gab49ea4abd1127021cdeba45947b193a2">More...</a><br /></td></tr>
<tr class="separator:gab49ea4abd1127021cdeba45947b193a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e5a45bfc49abbacd812407d604c65c7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__sort.html#ga0e5a45bfc49abbacd812407d604c65c7">sort_strings_parallel_lcp</a> (std::vector&lt; std::string &gt; &amp;strings, uint32_t *lcp, size_t memory=0)</td></tr>
<tr class="memdesc:ga0e5a45bfc49abbacd812407d604c65c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort a vector of std::strings in place in parallel.  <a href="group__tlx__sort.html#ga0e5a45bfc49abbacd812407d604c65c7">More...</a><br /></td></tr>
<tr class="separator:ga0e5a45bfc49abbacd812407d604c65c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Base64 Encoding and Decoding</div></td></tr>
<tr class="memitem:ga691477f59c8496eec65e994ce3f6e6e5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga691477f59c8496eec65e994ce3f6e6e5">base64_encode</a> (const void *data, size_t size, size_t line_break=0)</td></tr>
<tr class="memdesc:ga691477f59c8496eec65e994ce3f6e6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode the given binary data into base64 representation as described in RFC 2045 or RFC 3548.  <a href="group__tlx__string.html#ga691477f59c8496eec65e994ce3f6e6e5">More...</a><br /></td></tr>
<tr class="separator:ga691477f59c8496eec65e994ce3f6e6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16a12f591febaeddffd2ffca031c8bf4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga16a12f591febaeddffd2ffca031c8bf4">base64_encode</a> (const std::string &amp;str, size_t line_break=0)</td></tr>
<tr class="memdesc:ga16a12f591febaeddffd2ffca031c8bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode the given binary string into base64 representation as described in RFC 2045 or RFC 3548.  <a href="group__tlx__string.html#ga16a12f591febaeddffd2ffca031c8bf4">More...</a><br /></td></tr>
<tr class="separator:ga16a12f591febaeddffd2ffca031c8bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2775fbea220f27325aba0f8af1cc9a8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gac2775fbea220f27325aba0f8af1cc9a8">base64_decode</a> (const void *data, size_t size, bool strict=true)</td></tr>
<tr class="memdesc:gac2775fbea220f27325aba0f8af1cc9a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a string in base64 representation as described in RFC 2045 or RFC 3548 and return the original data.  <a href="group__tlx__string.html#gac2775fbea220f27325aba0f8af1cc9a8">More...</a><br /></td></tr>
<tr class="separator:gac2775fbea220f27325aba0f8af1cc9a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe1e973cd3a2d5b7e55544d4c616da49"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gabe1e973cd3a2d5b7e55544d4c616da49">base64_decode</a> (const std::string &amp;str, bool strict=true)</td></tr>
<tr class="memdesc:gabe1e973cd3a2d5b7e55544d4c616da49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a string in base64 representation as described in RFC 2045 or RFC 3548 and return the original data.  <a href="group__tlx__string.html#gabe1e973cd3a2d5b7e55544d4c616da49">More...</a><br /></td></tr>
<tr class="separator:gabe1e973cd3a2d5b7e55544d4c616da49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Bitdump Methods</div></td></tr>
<tr class="memitem:ga00c0a01f04e50e69dadc483dee4b7b08"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga00c0a01f04e50e69dadc483dee4b7b08">bitdump_le8</a> (const void *const data, size_t size)</td></tr>
<tr class="memdesc:ga00c0a01f04e50e69dadc483dee4b7b08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) string as a sequence of 8-bit little-endian bytes.  <a href="group__tlx__string.html#ga00c0a01f04e50e69dadc483dee4b7b08">More...</a><br /></td></tr>
<tr class="separator:ga00c0a01f04e50e69dadc483dee4b7b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6d05a55439476040242e61a1474b9b9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gae6d05a55439476040242e61a1474b9b9">bitdump_le8</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:gae6d05a55439476040242e61a1474b9b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) string as a sequence of 8-bit little-endian bytes.  <a href="group__tlx__string.html#gae6d05a55439476040242e61a1474b9b9">More...</a><br /></td></tr>
<tr class="separator:gae6d05a55439476040242e61a1474b9b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfad4094f21f5a7ee748330d56764c13"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gacfad4094f21f5a7ee748330d56764c13">bitdump_be8</a> (const void *const data, size_t size)</td></tr>
<tr class="memdesc:gacfad4094f21f5a7ee748330d56764c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) string as a sequence of 8-bit big-endian bytes.  <a href="group__tlx__string.html#gacfad4094f21f5a7ee748330d56764c13">More...</a><br /></td></tr>
<tr class="separator:gacfad4094f21f5a7ee748330d56764c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05d04f64b0d1ec8b2277b2236106e3b4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga05d04f64b0d1ec8b2277b2236106e3b4">bitdump_be8</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga05d04f64b0d1ec8b2277b2236106e3b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) string as a sequence of 8-bit big-endian bytes.  <a href="group__tlx__string.html#ga05d04f64b0d1ec8b2277b2236106e3b4">More...</a><br /></td></tr>
<tr class="separator:ga05d04f64b0d1ec8b2277b2236106e3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfc711557532d311aa3ced8de036f623"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:gacfc711557532d311aa3ced8de036f623"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gacfc711557532d311aa3ced8de036f623">bitdump_le8_type</a> (const Type &amp;t)</td></tr>
<tr class="memdesc:gacfc711557532d311aa3ced8de036f623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) item as a sequence of 8-bit little-endian bytes.  <a href="group__tlx__string.html#gacfc711557532d311aa3ced8de036f623">More...</a><br /></td></tr>
<tr class="separator:gacfc711557532d311aa3ced8de036f623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0fea123d8861a6d2c11c746741dd524"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:gae0fea123d8861a6d2c11c746741dd524"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gae0fea123d8861a6d2c11c746741dd524">bitdump_be8_type</a> (const Type &amp;t)</td></tr>
<tr class="memdesc:gae0fea123d8861a6d2c11c746741dd524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) item as a sequence of 8-bit big-endian bytes.  <a href="group__tlx__string.html#gae0fea123d8861a6d2c11c746741dd524">More...</a><br /></td></tr>
<tr class="separator:gae0fea123d8861a6d2c11c746741dd524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Hexdump Methods</div></td></tr>
<tr class="memitem:gab4c0ada9ff7b0d905361e60050316899"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gab4c0ada9ff7b0d905361e60050316899">hexdump</a> (const void *const data, size_t size)</td></tr>
<tr class="memdesc:gab4c0ada9ff7b0d905361e60050316899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) string as a sequence of uppercase hexadecimal pairs.  <a href="group__tlx__string.html#gab4c0ada9ff7b0d905361e60050316899">More...</a><br /></td></tr>
<tr class="separator:gab4c0ada9ff7b0d905361e60050316899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0757bf9871dc4e2526ab48e4cde28e1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gaa0757bf9871dc4e2526ab48e4cde28e1">hexdump</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:gaa0757bf9871dc4e2526ab48e4cde28e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) string as a sequence of uppercase hexadecimal pairs.  <a href="group__tlx__string.html#gaa0757bf9871dc4e2526ab48e4cde28e1">More...</a><br /></td></tr>
<tr class="separator:gaa0757bf9871dc4e2526ab48e4cde28e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15c83e3e2055412b0440758c98b3f148"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga15c83e3e2055412b0440758c98b3f148">hexdump</a> (const std::vector&lt; char &gt; &amp;data)</td></tr>
<tr class="memdesc:ga15c83e3e2055412b0440758c98b3f148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a char vector as a sequence of uppercase hexadecimal pairs.  <a href="group__tlx__string.html#ga15c83e3e2055412b0440758c98b3f148">More...</a><br /></td></tr>
<tr class="separator:ga15c83e3e2055412b0440758c98b3f148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c6446ce9a61a434b3a10345cbf3ebed"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga6c6446ce9a61a434b3a10345cbf3ebed">hexdump</a> (const std::vector&lt; uint8_t &gt; &amp;data)</td></tr>
<tr class="memdesc:ga6c6446ce9a61a434b3a10345cbf3ebed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a uint8_t vector as a sequence of uppercase hexadecimal pairs.  <a href="group__tlx__string.html#ga6c6446ce9a61a434b3a10345cbf3ebed">More...</a><br /></td></tr>
<tr class="separator:ga6c6446ce9a61a434b3a10345cbf3ebed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab10f91fa3b24c787e4e0d88c009ac298"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gab10f91fa3b24c787e4e0d88c009ac298">hexdump_sourcecode</a> (const std::string &amp;str, const std::string &amp;var_name=&quot;name&quot;)</td></tr>
<tr class="memdesc:gab10f91fa3b24c787e4e0d88c009ac298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) string into a C source code snippet.  <a href="group__tlx__string.html#gab10f91fa3b24c787e4e0d88c009ac298">More...</a><br /></td></tr>
<tr class="separator:gab10f91fa3b24c787e4e0d88c009ac298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c47a216e0abcdf9a88fc50bb79c98ba"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga0c47a216e0abcdf9a88fc50bb79c98ba">hexdump_lc</a> (const void *const data, size_t size)</td></tr>
<tr class="memdesc:ga0c47a216e0abcdf9a88fc50bb79c98ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) string as a sequence of lowercase hexadecimal pairs.  <a href="group__tlx__string.html#ga0c47a216e0abcdf9a88fc50bb79c98ba">More...</a><br /></td></tr>
<tr class="separator:ga0c47a216e0abcdf9a88fc50bb79c98ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60e8912db4511738cfdbf3e97ff6dbbf"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga60e8912db4511738cfdbf3e97ff6dbbf">hexdump_lc</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga60e8912db4511738cfdbf3e97ff6dbbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) string as a sequence of lowercase hexadecimal pairs.  <a href="group__tlx__string.html#ga60e8912db4511738cfdbf3e97ff6dbbf">More...</a><br /></td></tr>
<tr class="separator:ga60e8912db4511738cfdbf3e97ff6dbbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae749cedcfc25af4f829d70e8febba7a1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gae749cedcfc25af4f829d70e8febba7a1">hexdump_lc</a> (const std::vector&lt; char &gt; &amp;data)</td></tr>
<tr class="memdesc:gae749cedcfc25af4f829d70e8febba7a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a char vector as a sequence of lowercase hexadecimal pairs.  <a href="group__tlx__string.html#gae749cedcfc25af4f829d70e8febba7a1">More...</a><br /></td></tr>
<tr class="separator:gae749cedcfc25af4f829d70e8febba7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b35bd68e5974e78327fce13e0e2eaf6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga0b35bd68e5974e78327fce13e0e2eaf6">hexdump_lc</a> (const std::vector&lt; uint8_t &gt; &amp;data)</td></tr>
<tr class="memdesc:ga0b35bd68e5974e78327fce13e0e2eaf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a uint8_t vector as a sequence of lowercase hexadecimal pairs.  <a href="group__tlx__string.html#ga0b35bd68e5974e78327fce13e0e2eaf6">More...</a><br /></td></tr>
<tr class="separator:ga0b35bd68e5974e78327fce13e0e2eaf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81809bc5e0b69034f39659303baa4bf9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga81809bc5e0b69034f39659303baa4bf9">parse_hexdump</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga81809bc5e0b69034f39659303baa4bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a string as a sequence of hexadecimal pairs.  <a href="group__tlx__string.html#ga81809bc5e0b69034f39659303baa4bf9">More...</a><br /></td></tr>
<tr class="separator:ga81809bc5e0b69034f39659303baa4bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2a485134f5e618b846abb630d44ec6f"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:gae2a485134f5e618b846abb630d44ec6f"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gae2a485134f5e618b846abb630d44ec6f">hexdump_type</a> (const Type &amp;t)</td></tr>
<tr class="memdesc:gae2a485134f5e618b846abb630d44ec6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) item as a sequence of uppercase hexadecimal pairs.  <a href="group__tlx__string.html#gae2a485134f5e618b846abb630d44ec6f">More...</a><br /></td></tr>
<tr class="separator:gae2a485134f5e618b846abb630d44ec6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b2f444830d8f7b1b0eaf93b5f514bf7"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ga0b2f444830d8f7b1b0eaf93b5f514bf7"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga0b2f444830d8f7b1b0eaf93b5f514bf7">hexdump_lc_type</a> (const Type &amp;t)</td></tr>
<tr class="memdesc:ga0b2f444830d8f7b1b0eaf93b5f514bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) item as a sequence of lowercase hexadecimal pairs.  <a href="group__tlx__string.html#ga0b2f444830d8f7b1b0eaf93b5f514bf7">More...</a><br /></td></tr>
<tr class="separator:ga0b2f444830d8f7b1b0eaf93b5f514bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Split and Join</div></td></tr>
<tr class="memitem:gad383d32ace209b51abe936d256d0bb1e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gad383d32ace209b51abe936d256d0bb1e">join</a> (char glue, const std::vector&lt; std::string &gt; &amp;parts)</td></tr>
<tr class="memdesc:gad383d32ace209b51abe936d256d0bb1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a vector of strings by some glue character between each pair from the sequence.  <a href="group__tlx__string.html#gad383d32ace209b51abe936d256d0bb1e">More...</a><br /></td></tr>
<tr class="separator:gad383d32ace209b51abe936d256d0bb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cb20ee53f25c37880faf1b5e5ac3619"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga0cb20ee53f25c37880faf1b5e5ac3619">join</a> (const char *glue, const std::vector&lt; std::string &gt; &amp;parts)</td></tr>
<tr class="memdesc:ga0cb20ee53f25c37880faf1b5e5ac3619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a vector of strings by some glue string between each pair from the sequence.  <a href="group__tlx__string.html#ga0cb20ee53f25c37880faf1b5e5ac3619">More...</a><br /></td></tr>
<tr class="separator:ga0cb20ee53f25c37880faf1b5e5ac3619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga206c170915b483387448714300d311c1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga206c170915b483387448714300d311c1">join</a> (const std::string &amp;glue, const std::vector&lt; std::string &gt; &amp;parts)</td></tr>
<tr class="memdesc:ga206c170915b483387448714300d311c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a vector of strings by some glue string between each pair from the sequence.  <a href="group__tlx__string.html#ga206c170915b483387448714300d311c1">More...</a><br /></td></tr>
<tr class="separator:ga206c170915b483387448714300d311c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1af0448079469f224ea8905c34dc1868"><td class="memTemplParams" colspan="2">template&lt;typename Glue , typename Iterator &gt; </td></tr>
<tr class="memitem:ga1af0448079469f224ea8905c34dc1868"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga1af0448079469f224ea8905c34dc1868">join</a> (Glue glue, Iterator first, Iterator last)</td></tr>
<tr class="memdesc:ga1af0448079469f224ea8905c34dc1868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a sequence of strings by some glue string between each pair from the sequence.  <a href="group__tlx__string.html#ga1af0448079469f224ea8905c34dc1868">More...</a><br /></td></tr>
<tr class="separator:ga1af0448079469f224ea8905c34dc1868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a96227b0edd6c65800124ba1dac82cf"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:ga4a96227b0edd6c65800124ba1dac82cf"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga4a96227b0edd6c65800124ba1dac82cf">join</a> (char glue, const Container &amp;parts)</td></tr>
<tr class="memdesc:ga4a96227b0edd6c65800124ba1dac82cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a Container of strings by some glue character between each pair from the sequence.  <a href="group__tlx__string.html#ga4a96227b0edd6c65800124ba1dac82cf">More...</a><br /></td></tr>
<tr class="separator:ga4a96227b0edd6c65800124ba1dac82cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffea57c0c1e61aa8c9bc50e1ec2f9fe2"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:gaffea57c0c1e61aa8c9bc50e1ec2f9fe2"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gaffea57c0c1e61aa8c9bc50e1ec2f9fe2">join</a> (const char *glue, const Container &amp;parts)</td></tr>
<tr class="memdesc:gaffea57c0c1e61aa8c9bc50e1ec2f9fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a Container of strings by some glue string between each pair from the sequence.  <a href="group__tlx__string.html#gaffea57c0c1e61aa8c9bc50e1ec2f9fe2">More...</a><br /></td></tr>
<tr class="separator:gaffea57c0c1e61aa8c9bc50e1ec2f9fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e35ca12bd4564ba470e3bf4f6a91798"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:ga2e35ca12bd4564ba470e3bf4f6a91798"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga2e35ca12bd4564ba470e3bf4f6a91798">join</a> (const std::string &amp;glue, const Container &amp;parts)</td></tr>
<tr class="memdesc:ga2e35ca12bd4564ba470e3bf4f6a91798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a Container of strings by some glue string between each pair from the sequence.  <a href="group__tlx__string.html#ga2e35ca12bd4564ba470e3bf4f6a91798">More...</a><br /></td></tr>
<tr class="separator:ga2e35ca12bd4564ba470e3bf4f6a91798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabceb162540e1d7f3f6bef9304fdd6ef9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gabceb162540e1d7f3f6bef9304fdd6ef9">join_quoted</a> (const std::vector&lt; std::string &gt; &amp;str, char sep, char quote, char escape)</td></tr>
<tr class="memdesc:gabceb162540e1d7f3f6bef9304fdd6ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a vector of strings using a separator character.  <a href="group__tlx__string.html#gabceb162540e1d7f3f6bef9304fdd6ef9">More...</a><br /></td></tr>
<tr class="separator:gabceb162540e1d7f3f6bef9304fdd6ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71e61af2f5c2aea97806490bc4e89b17"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga71e61af2f5c2aea97806490bc4e89b17">join_quoted</a> (const std::vector&lt; std::string &gt; &amp;str)</td></tr>
<tr class="memdesc:ga71e61af2f5c2aea97806490bc4e89b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a vector of strings using spaces as separator character.  <a href="group__tlx__string.html#ga71e61af2f5c2aea97806490bc4e89b17">More...</a><br /></td></tr>
<tr class="separator:ga71e61af2f5c2aea97806490bc4e89b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fb56b145f00428be03f74257c61f1cc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga4fb56b145f00428be03f74257c61f1cc">split</a> (char sep, const std::string &amp;str, std::string::size_type limit=std::string::npos)</td></tr>
<tr class="memdesc:ga4fb56b145f00428be03f74257c61f1cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator character into distinct substrings.  <a href="group__tlx__string.html#ga4fb56b145f00428be03f74257c61f1cc">More...</a><br /></td></tr>
<tr class="separator:ga4fb56b145f00428be03f74257c61f1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad838882b8fc992742b09450925758b32"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gad838882b8fc992742b09450925758b32">split</a> (const char *sep, const std::string &amp;str, std::string::size_type limit=std::string::npos)</td></tr>
<tr class="memdesc:gad838882b8fc992742b09450925758b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator string into distinct substrings.  <a href="group__tlx__string.html#gad838882b8fc992742b09450925758b32">More...</a><br /></td></tr>
<tr class="separator:gad838882b8fc992742b09450925758b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d57e8e6ac19e94787bf3cd44a79c1fe"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga0d57e8e6ac19e94787bf3cd44a79c1fe">split</a> (const std::string &amp;sep, const std::string &amp;str, std::string::size_type limit=std::string::npos)</td></tr>
<tr class="memdesc:ga0d57e8e6ac19e94787bf3cd44a79c1fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator string into distinct substrings.  <a href="group__tlx__string.html#ga0d57e8e6ac19e94787bf3cd44a79c1fe">More...</a><br /></td></tr>
<tr class="separator:ga0d57e8e6ac19e94787bf3cd44a79c1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00c921a6a793d9c4e59e380b2bb32fca"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga00c921a6a793d9c4e59e380b2bb32fca">split</a> (char sep, const std::string &amp;str, std::string::size_type min_fields, std::string::size_type limit)</td></tr>
<tr class="memdesc:ga00c921a6a793d9c4e59e380b2bb32fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator character into distinct substrings.  <a href="group__tlx__string.html#ga00c921a6a793d9c4e59e380b2bb32fca">More...</a><br /></td></tr>
<tr class="separator:ga00c921a6a793d9c4e59e380b2bb32fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5fb737c26e5fa4d63467b0ded2a1b90"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gac5fb737c26e5fa4d63467b0ded2a1b90">split</a> (const char *sep, const std::string &amp;str, std::string::size_type min_fields, std::string::size_type limit)</td></tr>
<tr class="memdesc:gac5fb737c26e5fa4d63467b0ded2a1b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator string into distinct substrings.  <a href="group__tlx__string.html#gac5fb737c26e5fa4d63467b0ded2a1b90">More...</a><br /></td></tr>
<tr class="separator:gac5fb737c26e5fa4d63467b0ded2a1b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a0a5d581ecd362eaae43bdee50b3896"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga7a0a5d581ecd362eaae43bdee50b3896">split</a> (const std::string &amp;sep, const std::string &amp;str, std::string::size_type min_fields, std::string::size_type limit)</td></tr>
<tr class="memdesc:ga7a0a5d581ecd362eaae43bdee50b3896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator string into distinct substrings.  <a href="group__tlx__string.html#ga7a0a5d581ecd362eaae43bdee50b3896">More...</a><br /></td></tr>
<tr class="separator:ga7a0a5d581ecd362eaae43bdee50b3896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17fd4a3698ca54702b30dddc232bf903"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga17fd4a3698ca54702b30dddc232bf903">split</a> (std::vector&lt; std::string &gt; *into, char sep, const std::string &amp;str, std::string::size_type limit=std::string::npos)</td></tr>
<tr class="memdesc:ga17fd4a3698ca54702b30dddc232bf903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator character into distinct substrings.  <a href="group__tlx__string.html#ga17fd4a3698ca54702b30dddc232bf903">More...</a><br /></td></tr>
<tr class="separator:ga17fd4a3698ca54702b30dddc232bf903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga177a8fd78d5cc4e0fd8dc50810967d89"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga177a8fd78d5cc4e0fd8dc50810967d89">split</a> (std::vector&lt; std::string &gt; *into, const char *sep, const std::string &amp;str, std::string::size_type limit=std::string::npos)</td></tr>
<tr class="memdesc:ga177a8fd78d5cc4e0fd8dc50810967d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator string into distinct substrings.  <a href="group__tlx__string.html#ga177a8fd78d5cc4e0fd8dc50810967d89">More...</a><br /></td></tr>
<tr class="separator:ga177a8fd78d5cc4e0fd8dc50810967d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga431c048d40a30f531e2e419e26582e4c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga431c048d40a30f531e2e419e26582e4c">split</a> (std::vector&lt; std::string &gt; *into, const std::string &amp;sep, const std::string &amp;str, std::string::size_type limit=std::string::npos)</td></tr>
<tr class="memdesc:ga431c048d40a30f531e2e419e26582e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator string into distinct substrings.  <a href="group__tlx__string.html#ga431c048d40a30f531e2e419e26582e4c">More...</a><br /></td></tr>
<tr class="separator:ga431c048d40a30f531e2e419e26582e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4997fcbeb1c6a97d23bce8ea590b3ce3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga4997fcbeb1c6a97d23bce8ea590b3ce3">split</a> (std::vector&lt; std::string &gt; *into, char sep, const std::string &amp;str, std::string::size_type min_fields, std::string::size_type limit)</td></tr>
<tr class="memdesc:ga4997fcbeb1c6a97d23bce8ea590b3ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator character into distinct substrings.  <a href="group__tlx__string.html#ga4997fcbeb1c6a97d23bce8ea590b3ce3">More...</a><br /></td></tr>
<tr class="separator:ga4997fcbeb1c6a97d23bce8ea590b3ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40222e4ae7f552a3d6f8d485ced3d91d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga40222e4ae7f552a3d6f8d485ced3d91d">split</a> (std::vector&lt; std::string &gt; *into, const char *sep, const std::string &amp;str, std::string::size_type min_fields, std::string::size_type limit)</td></tr>
<tr class="memdesc:ga40222e4ae7f552a3d6f8d485ced3d91d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator string into distinct substrings.  <a href="group__tlx__string.html#ga40222e4ae7f552a3d6f8d485ced3d91d">More...</a><br /></td></tr>
<tr class="separator:ga40222e4ae7f552a3d6f8d485ced3d91d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4aa7e0fb9bd81e31214087d3d85367a3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga4aa7e0fb9bd81e31214087d3d85367a3">split</a> (std::vector&lt; std::string &gt; *into, const std::string &amp;sep, const std::string &amp;str, std::string::size_type min_fields, std::string::size_type limit)</td></tr>
<tr class="memdesc:ga4aa7e0fb9bd81e31214087d3d85367a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator string into distinct substrings.  <a href="group__tlx__string.html#ga4aa7e0fb9bd81e31214087d3d85367a3">More...</a><br /></td></tr>
<tr class="separator:ga4aa7e0fb9bd81e31214087d3d85367a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc48ce717ba77df6c6f395fb07bc8a1e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gafc48ce717ba77df6c6f395fb07bc8a1e">split_quoted</a> (const std::string &amp;str, char sep, char quote, char escape)</td></tr>
<tr class="memdesc:gafc48ce717ba77df6c6f395fb07bc8a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator character into distinct substrings.  <a href="group__tlx__string.html#gafc48ce717ba77df6c6f395fb07bc8a1e">More...</a><br /></td></tr>
<tr class="separator:gafc48ce717ba77df6c6f395fb07bc8a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0210d995cdc4df9aafcd09c005571449"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga0210d995cdc4df9aafcd09c005571449">split_quoted</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga0210d995cdc4df9aafcd09c005571449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each space into distinct substrings.  <a href="group__tlx__string.html#ga0210d995cdc4df9aafcd09c005571449">More...</a><br /></td></tr>
<tr class="separator:ga0210d995cdc4df9aafcd09c005571449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c9fac87ddaeb902c500f4854af69bec"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:ga6c9fac87ddaeb902c500f4854af69bec"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga6c9fac87ddaeb902c500f4854af69bec">split_view</a> (char sep, const std::string &amp;str, Functor &amp;&amp;callback, std::string::size_type limit=std::string::npos)</td></tr>
<tr class="memdesc:ga6c9fac87ddaeb902c500f4854af69bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator character into distinct substrings, and call the given callback with a <a class="el" href="classtlx_1_1StringView.html" title="StringView is a reference to a part of a string, consisting of only a char pointer and a length...">StringView</a> for each substring.  <a href="group__tlx__string.html#ga6c9fac87ddaeb902c500f4854af69bec">More...</a><br /></td></tr>
<tr class="separator:ga6c9fac87ddaeb902c500f4854af69bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Search and Replace</div></td></tr>
<tr class="memitem:gaca0aeb9a74105ec849e939229d47970b"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gaca0aeb9a74105ec849e939229d47970b">replace_first</a> (std::string *str, const std::string &amp;needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:gaca0aeb9a74105ec849e939229d47970b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="group__tlx__string.html#gaca0aeb9a74105ec849e939229d47970b">More...</a><br /></td></tr>
<tr class="separator:gaca0aeb9a74105ec849e939229d47970b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32d2a706e20d6e5b07cbb677c340deba"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga32d2a706e20d6e5b07cbb677c340deba">replace_first</a> (std::string *str, const std::string &amp;needle, const char *instead)</td></tr>
<tr class="memdesc:ga32d2a706e20d6e5b07cbb677c340deba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="group__tlx__string.html#ga32d2a706e20d6e5b07cbb677c340deba">More...</a><br /></td></tr>
<tr class="separator:ga32d2a706e20d6e5b07cbb677c340deba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2b83d93d49145437aec2964f30e4cd1"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gab2b83d93d49145437aec2964f30e4cd1">replace_first</a> (std::string *str, const char *needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:gab2b83d93d49145437aec2964f30e4cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="group__tlx__string.html#gab2b83d93d49145437aec2964f30e4cd1">More...</a><br /></td></tr>
<tr class="separator:gab2b83d93d49145437aec2964f30e4cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ed49bc3eebffeefeff05f84ffbcc086"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga6ed49bc3eebffeefeff05f84ffbcc086">replace_first</a> (std::string *str, const char *needle, const char *instead)</td></tr>
<tr class="memdesc:ga6ed49bc3eebffeefeff05f84ffbcc086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="group__tlx__string.html#ga6ed49bc3eebffeefeff05f84ffbcc086">More...</a><br /></td></tr>
<tr class="separator:ga6ed49bc3eebffeefeff05f84ffbcc086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4865798a465a43845804dda0fe21f888"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga4865798a465a43845804dda0fe21f888">replace_first</a> (std::string *str, char needle, char instead)</td></tr>
<tr class="memdesc:ga4865798a465a43845804dda0fe21f888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="group__tlx__string.html#ga4865798a465a43845804dda0fe21f888">More...</a><br /></td></tr>
<tr class="separator:ga4865798a465a43845804dda0fe21f888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b0092a333e84d0c4eaae50955bc5a71"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga8b0092a333e84d0c4eaae50955bc5a71">replace_first</a> (const std::string &amp;str, const std::string &amp;needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:ga8b0092a333e84d0c4eaae50955bc5a71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="group__tlx__string.html#ga8b0092a333e84d0c4eaae50955bc5a71">More...</a><br /></td></tr>
<tr class="separator:ga8b0092a333e84d0c4eaae50955bc5a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6b1e9aa3d513c96cd5973e50551d6b5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gab6b1e9aa3d513c96cd5973e50551d6b5">replace_first</a> (const std::string &amp;str, const std::string &amp;needle, const char *instead)</td></tr>
<tr class="memdesc:gab6b1e9aa3d513c96cd5973e50551d6b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="group__tlx__string.html#gab6b1e9aa3d513c96cd5973e50551d6b5">More...</a><br /></td></tr>
<tr class="separator:gab6b1e9aa3d513c96cd5973e50551d6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7e6db7b1dfe54efc4b195f27df5ed71"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gae7e6db7b1dfe54efc4b195f27df5ed71">replace_first</a> (const std::string &amp;str, const char *needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:gae7e6db7b1dfe54efc4b195f27df5ed71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="group__tlx__string.html#gae7e6db7b1dfe54efc4b195f27df5ed71">More...</a><br /></td></tr>
<tr class="separator:gae7e6db7b1dfe54efc4b195f27df5ed71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga711f2f36ac6d9cb35a6a63672e47a47c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga711f2f36ac6d9cb35a6a63672e47a47c">replace_first</a> (const std::string &amp;str, const char *needle, const char *instead)</td></tr>
<tr class="memdesc:ga711f2f36ac6d9cb35a6a63672e47a47c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="group__tlx__string.html#ga711f2f36ac6d9cb35a6a63672e47a47c">More...</a><br /></td></tr>
<tr class="separator:ga711f2f36ac6d9cb35a6a63672e47a47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga276e1110c0ea48a01ef5a84f8ff40f37"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga276e1110c0ea48a01ef5a84f8ff40f37">replace_first</a> (const std::string &amp;str, char needle, char instead)</td></tr>
<tr class="memdesc:ga276e1110c0ea48a01ef5a84f8ff40f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="group__tlx__string.html#ga276e1110c0ea48a01ef5a84f8ff40f37">More...</a><br /></td></tr>
<tr class="separator:ga276e1110c0ea48a01ef5a84f8ff40f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7021d36930f4bd434b2082dce8bd43cf"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga7021d36930f4bd434b2082dce8bd43cf">replace_all</a> (std::string *str, const std::string &amp;needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:ga7021d36930f4bd434b2082dce8bd43cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="group__tlx__string.html#ga7021d36930f4bd434b2082dce8bd43cf">More...</a><br /></td></tr>
<tr class="separator:ga7021d36930f4bd434b2082dce8bd43cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd5bd9f9a887fa20b4a8ebaf987fd5de"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gadd5bd9f9a887fa20b4a8ebaf987fd5de">replace_all</a> (std::string *str, const std::string &amp;needle, const char *instead)</td></tr>
<tr class="memdesc:gadd5bd9f9a887fa20b4a8ebaf987fd5de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="group__tlx__string.html#gadd5bd9f9a887fa20b4a8ebaf987fd5de">More...</a><br /></td></tr>
<tr class="separator:gadd5bd9f9a887fa20b4a8ebaf987fd5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b4b8117690af529b7051a3c10c382ff"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga6b4b8117690af529b7051a3c10c382ff">replace_all</a> (std::string *str, const char *needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:ga6b4b8117690af529b7051a3c10c382ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="group__tlx__string.html#ga6b4b8117690af529b7051a3c10c382ff">More...</a><br /></td></tr>
<tr class="separator:ga6b4b8117690af529b7051a3c10c382ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d7d14badd05473e5a5c847b3f91b9e9"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga0d7d14badd05473e5a5c847b3f91b9e9">replace_all</a> (std::string *str, const char *needle, const char *instead)</td></tr>
<tr class="memdesc:ga0d7d14badd05473e5a5c847b3f91b9e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="group__tlx__string.html#ga0d7d14badd05473e5a5c847b3f91b9e9">More...</a><br /></td></tr>
<tr class="separator:ga0d7d14badd05473e5a5c847b3f91b9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga768d59e5cc6d2c91f25a441ab4d265a6"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga768d59e5cc6d2c91f25a441ab4d265a6">replace_all</a> (std::string *str, char needle, char instead)</td></tr>
<tr class="memdesc:ga768d59e5cc6d2c91f25a441ab4d265a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="group__tlx__string.html#ga768d59e5cc6d2c91f25a441ab4d265a6">More...</a><br /></td></tr>
<tr class="separator:ga768d59e5cc6d2c91f25a441ab4d265a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac001aff0fa6c3bee2e9755e3ddd516f9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gac001aff0fa6c3bee2e9755e3ddd516f9">replace_all</a> (const std::string &amp;str, const std::string &amp;needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:gac001aff0fa6c3bee2e9755e3ddd516f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="group__tlx__string.html#gac001aff0fa6c3bee2e9755e3ddd516f9">More...</a><br /></td></tr>
<tr class="separator:gac001aff0fa6c3bee2e9755e3ddd516f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfe9c066393585d1a769cbd55e9f9960"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gadfe9c066393585d1a769cbd55e9f9960">replace_all</a> (const std::string &amp;str, const std::string &amp;needle, const char *instead)</td></tr>
<tr class="memdesc:gadfe9c066393585d1a769cbd55e9f9960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="group__tlx__string.html#gadfe9c066393585d1a769cbd55e9f9960">More...</a><br /></td></tr>
<tr class="separator:gadfe9c066393585d1a769cbd55e9f9960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e3b406ea495a236fff401c3585d8814"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga4e3b406ea495a236fff401c3585d8814">replace_all</a> (const std::string &amp;str, const char *needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:ga4e3b406ea495a236fff401c3585d8814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="group__tlx__string.html#ga4e3b406ea495a236fff401c3585d8814">More...</a><br /></td></tr>
<tr class="separator:ga4e3b406ea495a236fff401c3585d8814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14cfa75fa579e1d4943855455d9e605d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga14cfa75fa579e1d4943855455d9e605d">replace_all</a> (const std::string &amp;str, const char *needle, const char *instead)</td></tr>
<tr class="memdesc:ga14cfa75fa579e1d4943855455d9e605d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="group__tlx__string.html#ga14cfa75fa579e1d4943855455d9e605d">More...</a><br /></td></tr>
<tr class="separator:ga14cfa75fa579e1d4943855455d9e605d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae87b40ae8e461c110fffcb7a12b066d5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gae87b40ae8e461c110fffcb7a12b066d5">replace_all</a> (const std::string &amp;str, char needle, char instead)</td></tr>
<tr class="memdesc:gae87b40ae8e461c110fffcb7a12b066d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="group__tlx__string.html#gae87b40ae8e461c110fffcb7a12b066d5">More...</a><br /></td></tr>
<tr class="separator:gae87b40ae8e461c110fffcb7a12b066d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Trim</div></td></tr>
<tr class="memitem:gac44946abf6c2e869d57d1ce3d2c9a7e8"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gac44946abf6c2e869d57d1ce3d2c9a7e8">trim</a> (std::string *str)</td></tr>
<tr class="memdesc:gac44946abf6c2e869d57d1ce3d2c9a7e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place on the left and right.  <a href="group__tlx__string.html#gac44946abf6c2e869d57d1ce3d2c9a7e8">More...</a><br /></td></tr>
<tr class="separator:gac44946abf6c2e869d57d1ce3d2c9a7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga033f3fec1db85f0203f9f33ef0cfe271"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga033f3fec1db85f0203f9f33ef0cfe271">trim</a> (std::string *str, const char *drop)</td></tr>
<tr class="memdesc:ga033f3fec1db85f0203f9f33ef0cfe271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place on the left and right.  <a href="group__tlx__string.html#ga033f3fec1db85f0203f9f33ef0cfe271">More...</a><br /></td></tr>
<tr class="separator:ga033f3fec1db85f0203f9f33ef0cfe271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f5067eb83515704232300be374b2857"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga9f5067eb83515704232300be374b2857">trim</a> (std::string *str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:ga9f5067eb83515704232300be374b2857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place on the left and right.  <a href="group__tlx__string.html#ga9f5067eb83515704232300be374b2857">More...</a><br /></td></tr>
<tr class="separator:ga9f5067eb83515704232300be374b2857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a01f705cc7b4a7317a57f6bf41aef25"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga5a01f705cc7b4a7317a57f6bf41aef25">trim</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga5a01f705cc7b4a7317a57f6bf41aef25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place on the left and right.  <a href="group__tlx__string.html#ga5a01f705cc7b4a7317a57f6bf41aef25">More...</a><br /></td></tr>
<tr class="separator:ga5a01f705cc7b4a7317a57f6bf41aef25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadf066d809b088ceda29675da3420c3c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gaadf066d809b088ceda29675da3420c3c">trim</a> (const std::string &amp;str, const char *drop)</td></tr>
<tr class="memdesc:gaadf066d809b088ceda29675da3420c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place on the left and right.  <a href="group__tlx__string.html#gaadf066d809b088ceda29675da3420c3c">More...</a><br /></td></tr>
<tr class="separator:gaadf066d809b088ceda29675da3420c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7aacbd967bfb76fcb4b4d977b4f5d838"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga7aacbd967bfb76fcb4b4d977b4f5d838">trim</a> (const std::string &amp;str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:ga7aacbd967bfb76fcb4b4d977b4f5d838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place on the left and right.  <a href="group__tlx__string.html#ga7aacbd967bfb76fcb4b4d977b4f5d838">More...</a><br /></td></tr>
<tr class="separator:ga7aacbd967bfb76fcb4b4d977b4f5d838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga387d6e51cf1f77b7ac7111e8f0ed7d48"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga387d6e51cf1f77b7ac7111e8f0ed7d48">trim_right</a> (std::string *str)</td></tr>
<tr class="memdesc:ga387d6e51cf1f77b7ac7111e8f0ed7d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place only on the right.  <a href="group__tlx__string.html#ga387d6e51cf1f77b7ac7111e8f0ed7d48">More...</a><br /></td></tr>
<tr class="separator:ga387d6e51cf1f77b7ac7111e8f0ed7d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1480a3758759216e8206fc9bbb58c0da"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga1480a3758759216e8206fc9bbb58c0da">trim_right</a> (std::string *str, const char *drop)</td></tr>
<tr class="memdesc:ga1480a3758759216e8206fc9bbb58c0da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place only on the right.  <a href="group__tlx__string.html#ga1480a3758759216e8206fc9bbb58c0da">More...</a><br /></td></tr>
<tr class="separator:ga1480a3758759216e8206fc9bbb58c0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff5e9a8a1501b420ae5a5f8eca2a2f01"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gaff5e9a8a1501b420ae5a5f8eca2a2f01">trim_right</a> (std::string *str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:gaff5e9a8a1501b420ae5a5f8eca2a2f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place only on the right.  <a href="group__tlx__string.html#gaff5e9a8a1501b420ae5a5f8eca2a2f01">More...</a><br /></td></tr>
<tr class="separator:gaff5e9a8a1501b420ae5a5f8eca2a2f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fb8db490eae39cfd9819b407e8655ee"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga9fb8db490eae39cfd9819b407e8655ee">trim_right</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga9fb8db490eae39cfd9819b407e8655ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string only on the right.  <a href="group__tlx__string.html#ga9fb8db490eae39cfd9819b407e8655ee">More...</a><br /></td></tr>
<tr class="separator:ga9fb8db490eae39cfd9819b407e8655ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga232bc2341b09eea7c6229b7b548f4f8f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga232bc2341b09eea7c6229b7b548f4f8f">trim_right</a> (const std::string &amp;str, const char *drop)</td></tr>
<tr class="memdesc:ga232bc2341b09eea7c6229b7b548f4f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string only on the right.  <a href="group__tlx__string.html#ga232bc2341b09eea7c6229b7b548f4f8f">More...</a><br /></td></tr>
<tr class="separator:ga232bc2341b09eea7c6229b7b548f4f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b761b3a20c3f400f4f3451511016a07"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga4b761b3a20c3f400f4f3451511016a07">trim_right</a> (const std::string &amp;str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:ga4b761b3a20c3f400f4f3451511016a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string only on the right.  <a href="group__tlx__string.html#ga4b761b3a20c3f400f4f3451511016a07">More...</a><br /></td></tr>
<tr class="separator:ga4b761b3a20c3f400f4f3451511016a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd01f5ea03e1d4a21ee26d2f3e20206f"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gacd01f5ea03e1d4a21ee26d2f3e20206f">trim_left</a> (std::string *str)</td></tr>
<tr class="memdesc:gacd01f5ea03e1d4a21ee26d2f3e20206f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place only on the left.  <a href="group__tlx__string.html#gacd01f5ea03e1d4a21ee26d2f3e20206f">More...</a><br /></td></tr>
<tr class="separator:gacd01f5ea03e1d4a21ee26d2f3e20206f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga059d265ada554d8653d877a28d4d518d"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga059d265ada554d8653d877a28d4d518d">trim_left</a> (std::string *str, const char *drop)</td></tr>
<tr class="memdesc:ga059d265ada554d8653d877a28d4d518d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place only on the left.  <a href="group__tlx__string.html#ga059d265ada554d8653d877a28d4d518d">More...</a><br /></td></tr>
<tr class="separator:ga059d265ada554d8653d877a28d4d518d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9db0b1db4ab3774221363c2fafa8bbdf"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga9db0b1db4ab3774221363c2fafa8bbdf">trim_left</a> (std::string *str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:ga9db0b1db4ab3774221363c2fafa8bbdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place only on the left.  <a href="group__tlx__string.html#ga9db0b1db4ab3774221363c2fafa8bbdf">More...</a><br /></td></tr>
<tr class="separator:ga9db0b1db4ab3774221363c2fafa8bbdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58107ce115061cb45873f46778bfe836"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga58107ce115061cb45873f46778bfe836">trim_left</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga58107ce115061cb45873f46778bfe836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string only on the left.  <a href="group__tlx__string.html#ga58107ce115061cb45873f46778bfe836">More...</a><br /></td></tr>
<tr class="separator:ga58107ce115061cb45873f46778bfe836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bc881fad43aa1c573d47d459ed2a721"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga1bc881fad43aa1c573d47d459ed2a721">trim_left</a> (const std::string &amp;str, const char *drop)</td></tr>
<tr class="memdesc:ga1bc881fad43aa1c573d47d459ed2a721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string only on the left.  <a href="group__tlx__string.html#ga1bc881fad43aa1c573d47d459ed2a721">More...</a><br /></td></tr>
<tr class="separator:ga1bc881fad43aa1c573d47d459ed2a721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f870dbf0b1602d063de42caefde8b68"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga9f870dbf0b1602d063de42caefde8b68">trim_left</a> (const std::string &amp;str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:ga9f870dbf0b1602d063de42caefde8b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string only on the left.  <a href="group__tlx__string.html#ga9f870dbf0b1602d063de42caefde8b68">More...</a><br /></td></tr>
<tr class="separator:ga9f870dbf0b1602d063de42caefde8b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga8345e9f64e776708ff06090e0480f9ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#ga8345e9f64e776708ff06090e0480f9ae">parallel_multiway_merge_force_parallel</a> = false</td></tr>
<tr class="memdesc:ga8345e9f64e776708ff06090e0480f9ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">setting to force <a class="el" href="group__tlx__algorithm.html#gac3580dd876ff80d088499292a12d2fbe" title="Parallel multi-way merge routine. ">parallel_multiway_merge()</a> calls to run with parallel code  <a href="group__tlx__algorithm.html#ga8345e9f64e776708ff06090e0480f9ae">More...</a><br /></td></tr>
<tr class="separator:ga8345e9f64e776708ff06090e0480f9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee58bcd5ecf83c8fde2fdfcb4645a91c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#gaee58bcd5ecf83c8fde2fdfcb4645a91c">parallel_multiway_merge_force_sequential</a> = false</td></tr>
<tr class="memdesc:gaee58bcd5ecf83c8fde2fdfcb4645a91c"><td class="mdescLeft">&#160;</td><td class="mdescRight">setting to force all <a class="el" href="group__tlx__algorithm.html#gac3580dd876ff80d088499292a12d2fbe" title="Parallel multi-way merge routine. ">parallel_multiway_merge()</a> calls to run sequentially  <a href="group__tlx__algorithm.html#gaee58bcd5ecf83c8fde2fdfcb4645a91c">More...</a><br /></td></tr>
<tr class="separator:gaee58bcd5ecf83c8fde2fdfcb4645a91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fec55f066eef8bab8e18da604f978f0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#ga3fec55f066eef8bab8e18da604f978f0">parallel_multiway_merge_minimal_k</a> = 2</td></tr>
<tr class="memdesc:ga3fec55f066eef8bab8e18da604f978f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">minimal number of sequences for switching to parallel merging  <a href="group__tlx__algorithm.html#ga3fec55f066eef8bab8e18da604f978f0">More...</a><br /></td></tr>
<tr class="separator:ga3fec55f066eef8bab8e18da604f978f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13c75c629afda60aa74bfc46239c977c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#ga13c75c629afda60aa74bfc46239c977c">parallel_multiway_merge_minimal_n</a> = 1000</td></tr>
<tr class="memdesc:ga13c75c629afda60aa74bfc46239c977c"><td class="mdescLeft">&#160;</td><td class="mdescRight">minimal number of items for switching to parallel merging  <a href="group__tlx__algorithm.html#ga13c75c629afda60aa74bfc46239c977c">More...</a><br /></td></tr>
<tr class="separator:ga13c75c629afda60aa74bfc46239c977c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a0a9b421b4afc71557597aa03874b4d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#ga0a0a9b421b4afc71557597aa03874b4d">parallel_multiway_merge_oversampling</a> = 10</td></tr>
<tr class="memdesc:ga0a0a9b421b4afc71557597aa03874b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">default oversampling factor for parallel_multiway_merge  <a href="group__tlx__algorithm.html#ga0a0a9b421b4afc71557597aa03874b4d">More...</a><br /></td></tr>
<tr class="separator:ga0a0a9b421b4afc71557597aa03874b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30118484a60ca2ede4cf0fe139ce8492"><td class="memItemLeft" align="right" valign="top">static DefaultLoggerOutputCErr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a30118484a60ca2ede4cf0fe139ce8492">s_default_logger_cerr</a></td></tr>
<tr class="memdesc:a30118484a60ca2ede4cf0fe139ce8492"><td class="mdescLeft">&#160;</td><td class="mdescRight">default logger singletons  <a href="#a30118484a60ca2ede4cf0fe139ce8492">More...</a><br /></td></tr>
<tr class="separator:a30118484a60ca2ede4cf0fe139ce8492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69bbed173aa8becd81930ff5478f80d8"><td class="memItemLeft" align="right" valign="top">static DefaultLoggerOutputCOut&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a69bbed173aa8becd81930ff5478f80d8">s_default_logger_cout</a></td></tr>
<tr class="memdesc:a69bbed173aa8becd81930ff5478f80d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">default logger singletons  <a href="#a69bbed173aa8becd81930ff5478f80d8">More...</a><br /></td></tr>
<tr class="separator:a69bbed173aa8becd81930ff5478f80d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60940290b9c3ca9e978cd30dca38d8c8"><td class="memItemLeft" align="right" valign="top">static std::atomic&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a60940290b9c3ca9e978cd30dca38d8c8">s_die_with_exception</a></td></tr>
<tr class="separator:a60940290b9c3ca9e978cd30dca38d8c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a043e222f2e520d8002dd4e31b3696edd"><td class="memItemLeft" align="right" valign="top">static std::atomic&lt; <a class="el" href="classtlx_1_1LoggerOutputHook.html">LoggerOutputHook</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a043e222f2e520d8002dd4e31b3696edd">s_logger_output_hook</a></td></tr>
<tr class="memdesc:a043e222f2e520d8002dd4e31b3696edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">global logger output hook  <a href="#a043e222f2e520d8002dd4e31b3696edd">More...</a><br /></td></tr>
<tr class="separator:a043e222f2e520d8002dd4e31b3696edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c3ea0e853bc0db7e475dce0c2912de"><td class="memItemLeft" align="right" valign="top">static std::atomic&lt; <a class="el" href="classtlx_1_1LoggerPrefixHook.html">LoggerPrefixHook</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#ab8c3ea0e853bc0db7e475dce0c2912de">s_logger_prefix_hook</a></td></tr>
<tr class="memdesc:ab8c3ea0e853bc0db7e475dce0c2912de"><td class="mdescLeft">&#160;</td><td class="mdescRight">global logger prefix hook  <a href="#ab8c3ea0e853bc0db7e475dce0c2912de">More...</a><br /></td></tr>
<tr class="separator:ab8c3ea0e853bc0db7e475dce0c2912de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7675456bd96ef5d5a01b10a9bb444f"><td class="memItemLeft" align="right" valign="top">static std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx.html#a9f7675456bd96ef5d5a01b10a9bb444f">s_timer_add_mutex</a></td></tr>
<tr class="separator:a9f7675456bd96ef5d5a01b10a9bb444f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a2c4e023d82bca2172da2f965e3b42b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c4e023d82bca2172da2f965e3b42b40">&#9670;&nbsp;</a></span>counting_ptr</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetlx.html#a2c4e023d82bca2172da2f965e3b42b40">counting_ptr</a> =  <a class="el" href="classtlx_1_1CountingPtr.html">CountingPtr</a>&lt;Type&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>make alias due to similarity with std::shared_ptr&lt;T&gt; </p>

<p class="definition">Definition at line <a class="el" href="counting__ptr_8hpp_source.html#l00305">305</a> of file <a class="el" href="counting__ptr_8hpp_source.html">counting_ptr.hpp</a>.</p>

</div>
</div>
<a id="a9d28f4e50fa9fc359c658b0911ce06b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d28f4e50fa9fc359c658b0911ce06b8">&#9670;&nbsp;</a></span>CountingPtrNoDelete</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetlx.html#a9d28f4e50fa9fc359c658b0911ce06b8">CountingPtrNoDelete</a> =  <a class="el" href="classtlx_1_1CountingPtr.html">CountingPtr</a>&lt;Type, <a class="el" href="classtlx_1_1CountingPtrNoOperationDeleter.html">CountingPtrNoOperationDeleter</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>make alias for dummy deleter </p>

<p class="definition">Definition at line <a class="el" href="counting__ptr_8hpp_source.html#l00309">309</a> of file <a class="el" href="counting__ptr_8hpp_source.html">counting_ptr.hpp</a>.</p>

</div>
</div>
<a id="afacc9643f535d390fd0ead73790a6d56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afacc9643f535d390fd0ead73790a6d56">&#9670;&nbsp;</a></span>delegate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetlx.html#afacc9643f535d390fd0ead73790a6d56">delegate</a> =  <a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&lt;<a class="el" href="logistic__regression_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a>, Allocator&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>make template alias due to similarity with std::function </p>

<p class="definition">Definition at line <a class="el" href="delegate_8hpp_source.html#l00426">426</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a id="a4a89ad01492580f7cf07d93a99539cf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a89ad01492580f7cf07d93a99539cf5">&#9670;&nbsp;</a></span>reference_counter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetlx.html#a4a89ad01492580f7cf07d93a99539cf5">reference_counter</a> =  <a class="el" href="classtlx_1_1ReferenceCounter.html">ReferenceCounter</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>make alias due to <a class="el" href="classtlx_1_1CountingPtr.html" title="High-performance smart pointer used as a wrapping reference counting pointer. ">CountingPtr</a>'s similarity with std::shared_ptr&lt;T&gt; </p>

<p class="definition">Definition at line <a class="el" href="counting__ptr_8hpp_source.html#l00389">389</a> of file <a class="el" href="counting__ptr_8hpp_source.html">counting_ptr.hpp</a>.</p>

</div>
</div>
<a id="a13b278f8ac00c463d949d2297f0c3381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13b278f8ac00c463d949d2297f0c3381">&#9670;&nbsp;</a></span>semaphore</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacetlx.html#a13b278f8ac00c463d949d2297f0c3381">semaphore</a> =  <a class="el" href="classtlx_1_1Semaphore.html">Semaphore</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>alias for STL-like code style </p>

<p class="definition">Definition at line <a class="el" href="semaphore_8hpp_source.html#l00093">93</a> of file <a class="el" href="semaphore_8hpp_source.html">semaphore.hpp</a>.</p>

</div>
</div>
<a id="afaa62991928fb9fb18ff0db62a040aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaa62991928fb9fb18ff0db62a040aba">&#9670;&nbsp;</a></span>u32</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="namespacetlx.html#afaa62991928fb9fb18ff0db62a040aba">u32</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sha256_8cpp_source.html#l00032">32</a> of file <a class="el" href="sha256_8cpp_source.html">sha256.cpp</a>.</p>

</div>
</div>
<a id="a3f7e2bcbb0b4c338f3c4f6c937cd4234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f7e2bcbb0b4c338f3c4f6c937cd4234">&#9670;&nbsp;</a></span>u64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint64_t <a class="el" href="namespacetlx.html#a3f7e2bcbb0b4c338f3c4f6c937cd4234">u64</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sha256_8cpp_source.html#l00033">33</a> of file <a class="el" href="sha256_8cpp_source.html">sha256.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9f8179e15f255f7283de043a22560c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f8179e15f255f7283de043a22560c25">&#9670;&nbsp;</a></span>die_equal_compare() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::die_equal_compare </td>
          <td>(</td>
          <td class="paramtype">TypeA&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeB&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helper method to compare two values in <a class="el" href="die_8hpp.html#a334b021076c0dff0e3964c6819774ceb">die_unequal()</a> </p>

<p class="definition">Definition at line <a class="el" href="die_2core_8hpp_source.html#l00108">108</a> of file <a class="el" href="die_2core_8hpp_source.html">core.hpp</a>.</p>

</div>
</div>
<a id="ac37c2fc10d396b6a0038eb2d643d1360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac37c2fc10d396b6a0038eb2d643d1360">&#9670;&nbsp;</a></span>die_equal_compare() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::die_equal_compare </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="die_2core_8hpp_source.html#l00113">113</a> of file <a class="el" href="die_2core_8hpp_source.html">core.hpp</a>.</p>

</div>
</div>
<a id="a6834365ccbbe0995d597d91cb16ac05c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6834365ccbbe0995d597d91cb16ac05c">&#9670;&nbsp;</a></span>die_equal_compare() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::die_equal_compare </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="die_2core_8hpp_source.html#l00119">119</a> of file <a class="el" href="die_2core_8hpp_source.html">core.hpp</a>.</p>

</div>
</div>
<a id="ac215c9815621e2ebbc07da9be07a622f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac215c9815621e2ebbc07da9be07a622f">&#9670;&nbsp;</a></span>die_equal_compare() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::die_equal_compare </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="die_2core_8hpp_source.html#l00125">125</a> of file <a class="el" href="die_2core_8hpp_source.html">core.hpp</a>.</p>

</div>
</div>
<a id="acc85623f015ff3ce8bf5a365f14770c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc85623f015ff3ce8bf5a365f14770c4">&#9670;&nbsp;</a></span>die_equal_eps_compare()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::die_equal_eps_compare </td>
          <td>(</td>
          <td class="paramtype">TypeA&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TypeB&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>eps</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>helper method to compare two values in <a class="el" href="die_8hpp.html#a6b7ce407ec77acd1f6b146c1a6ea65ef">die_unequal_eps()</a> </p>

<p class="definition">Definition at line <a class="el" href="die_2core_8hpp_source.html#l00173">173</a> of file <a class="el" href="die_2core_8hpp_source.html">core.hpp</a>.</p>

<p class="reference">References <a class="el" href="die_2core_8hpp_source.html#l00167">die_unequal_eps_abs()</a>.</p>

</div>
</div>
<a id="a9f3602febd2a4b1979c9846da4ce8d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f3602febd2a4b1979c9846da4ce8d62">&#9670;&nbsp;</a></span>die_unequal_eps_abs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Type tlx::die_unequal_eps_abs </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>simple replacement for std::abs </p>

<p class="definition">Definition at line <a class="el" href="die_2core_8hpp_source.html#l00167">167</a> of file <a class="el" href="die_2core_8hpp_source.html">core.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="die_2core_8hpp_source.html#l00173">die_equal_eps_compare()</a>.</p>

</div>
</div>
<a id="a1a4f198a88970a7cb1f5d8d3a0555b79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a4f198a88970a7cb1f5d8d3a0555b79">&#9670;&nbsp;</a></span>die_with_message() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void die_with_message </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>die with message - either throw an exception or die via std::terminate() </p>

<p class="definition">Definition at line <a class="el" href="die_2core_8cpp_source.html#l00029">29</a> of file <a class="el" href="die_2core_8cpp_source.html">core.cpp</a>.</p>

<p class="reference">References <a class="el" href="die_2core_8cpp_source.html#l00021">s_die_with_exception</a>.</p>

<p class="reference">Referenced by <a class="el" href="die_2core_8cpp_source.html#l00039">die_with_message()</a>.</p>

</div>
</div>
<a id="a1972bdbc5b9ff146cf88d18ec9a12d64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1972bdbc5b9ff146cf88d18ec9a12d64">&#9670;&nbsp;</a></span>die_with_message() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void die_with_message </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>die with message - either throw an exception or die via std::terminate() </p>

<p class="definition">Definition at line <a class="el" href="die_2core_8cpp_source.html#l00039">39</a> of file <a class="el" href="die_2core_8cpp_source.html">core.cpp</a>.</p>

<p class="reference">References <a class="el" href="die_2core_8cpp_source.html#l00029">die_with_message()</a>.</p>

</div>
</div>
<a id="acf7bff2d67e5ed89bd9dc6bea904e1c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf7bff2d67e5ed89bd9dc6bea904e1c1">&#9670;&nbsp;</a></span>die_with_message() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void die_with_message </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>line</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>die with message - either throw an exception or die via std::terminate() </p>

<p class="definition">Definition at line <a class="el" href="die_2core_8cpp_source.html#l00045">45</a> of file <a class="el" href="die_2core_8cpp_source.html">core.cpp</a>.</p>

<p class="reference">References <a class="el" href="die_2core_8cpp_source.html#l00029">die_with_message()</a>.</p>

</div>
</div>
<a id="a393c17d312eb726b7e5631ecef50abee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a393c17d312eb726b7e5631ecef50abee">&#9670;&nbsp;</a></span>enable_segv_backtrace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void enable_segv_backtrace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install SIGSEGV signal handler and output backtrace on segmentation fault. </p>
<p>Compile with <code>-rdynamic</code> for more useful output. </p>

<p class="definition">Definition at line <a class="el" href="backtrace_8cpp_source.html#l00178">178</a> of file <a class="el" href="backtrace_8cpp_source.html">backtrace.cpp</a>.</p>

</div>
</div>
<a id="a5333b917b048207991b63b231a801d25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5333b917b048207991b63b231a801d25">&#9670;&nbsp;</a></span>ends_with_icase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::ends_with_icase </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ends__with_8cpp_source.html#l00075">75</a> of file <a class="el" href="ends__with_8cpp_source.html">ends_with.cpp</a>.</p>

<p class="reference">References <a class="el" href="to__lower_8cpp_source.html#l00017">to_lower()</a>.</p>

</div>
</div>
<a id="a03e44d8109f6044de35699f10aea3f0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03e44d8109f6044de35699f10aea3f0e">&#9670;&nbsp;</a></span>ends_with_icase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::ends_with_icase </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ends__with_8cpp_source.html#l00091">91</a> of file <a class="el" href="ends__with_8cpp_source.html">ends_with.cpp</a>.</p>

<p class="reference">References <a class="el" href="to__lower_8cpp_source.html#l00017">to_lower()</a>.</p>

</div>
</div>
<a id="a536ac2439a4b7a17a0e089c443249e67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a536ac2439a4b7a17a0e089c443249e67">&#9670;&nbsp;</a></span>extract_between_template()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string tlx::extract_between_template </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Separator1 &amp;&#160;</td>
          <td class="paramname"><em>sep1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sep1_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Separator2 &amp;&#160;</td>
          <td class="paramname"><em>sep2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="extract__between_8cpp_source.html#l00019">19</a> of file <a class="el" href="extract__between_8cpp_source.html">extract_between.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="extract__between_8cpp_source.html#l00037">extract_between()</a>.</p>

</div>
</div>
<a id="aced5355a13aebabfa68ca4100e507e83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced5355a13aebabfa68ca4100e507e83">&#9670;&nbsp;</a></span>is_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::is_space </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="word__wrap_8cpp_source.html#l00017">17</a> of file <a class="el" href="word__wrap_8cpp_source.html">word_wrap.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="word__wrap_8cpp_source.html#l00022">word_wrap()</a>.</p>

</div>
</div>
<a id="a7aebcd1b9a6ce6667c8bbcab36aeaadb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aebcd1b9a6ce6667c8bbcab36aeaadb">&#9670;&nbsp;</a></span>is_white()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool tlx::is_white </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="contains__word_8cpp_source.html#l00015">15</a> of file <a class="el" href="contains__word_8cpp_source.html">contains_word.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="contains__word_8cpp_source.html#l00019">contains_word()</a>.</p>

</div>
</div>
<a id="a6e20c59eaf19af62994ddc495412dde4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e20c59eaf19af62994ddc495412dde4">&#9670;&nbsp;</a></span>make_counting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1CountingPtr.html">CountingPtr</a>&lt;Type&gt; tlx::make_counting </td>
          <td>(</td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>method analogous to std::make_shared and std::make_unique. </p>

<p class="definition">Definition at line <a class="el" href="counting__ptr_8hpp_source.html#l00313">313</a> of file <a class="el" href="counting__ptr_8hpp_source.html">counting_ptr.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="dyn__block__reader_8hpp_source.html#l00111">thrill::data::ConstructDynBlockSource()</a>.</p>

</div>
</div>
<a id="abac208faa35171eb6016cf9730ed83f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abac208faa35171eb6016cf9730ed83f3">&#9670;&nbsp;</a></span>make_delegate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&lt; R(A...)&gt; make_delegate </td>
          <td>(</td>
          <td class="paramtype">C *const&#160;</td>
          <td class="paramname"><em>object_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(C::*)(A...)&#160;</td>
          <td class="paramname"><em>method_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor for wrapping a class::method with object pointer. </p>
<p>constructor for wrapping a const class::method with object pointer. </p>

<p class="definition">Definition at line <a class="el" href="delegate_8hpp_source.html#l00431">431</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a id="a36e57fc132415d92776d9eed01ae3442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36e57fc132415d92776d9eed01ae3442">&#9670;&nbsp;</a></span>make_delegate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&lt;R(A...)&gt; tlx::make_delegate </td>
          <td>(</td>
          <td class="paramtype">C &amp;&#160;</td>
          <td class="paramname"><em>object_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(C::*)(A...)&#160;</td>
          <td class="paramname"><em>method_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor for wrapping a class::method with object reference. </p>

<p class="definition">Definition at line <a class="el" href="delegate_8hpp_source.html#l00447">447</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a id="aaf10f085647ba34ff677aeecba994064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf10f085647ba34ff677aeecba994064">&#9670;&nbsp;</a></span>make_delegate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1Delegate.html">Delegate</a>&lt;R(A...)&gt; tlx::make_delegate </td>
          <td>(</td>
          <td class="paramtype">C const &amp;&#160;</td>
          <td class="paramname"><em>object_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R(C::*)(A...) const&#160;</td>
          <td class="paramname"><em>method_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>constructor for wrapping a const class::method with object reference. </p>

<p class="definition">Definition at line <a class="el" href="delegate_8hpp_source.html#l00455">455</a> of file <a class="el" href="delegate_8hpp_source.html">delegate.hpp</a>.</p>

</div>
</div>
<a id="a571b1c19ce4d530c4aaa3cd797c8ccae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a571b1c19ce4d530c4aaa3cd797c8ccae">&#9670;&nbsp;</a></span>operator<<()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; tlx::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1CountingPtr.html">CountingPtr</a>&lt; A, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>print pointer </p>

<p class="definition">Definition at line <a class="el" href="counting__ptr_8hpp_source.html#l00326">326</a> of file <a class="el" href="counting__ptr_8hpp_source.html">counting_ptr.hpp</a>.</p>

</div>
</div>
<a id="adad32b2f09919dea0ffb70cecfa4ee70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adad32b2f09919dea0ffb70cecfa4ee70">&#9670;&nbsp;</a></span>print_cxx_backtrace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void void print_cxx_backtrace </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>out</em> = <code>stderr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_frames</em> = <code>63</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a demangled stack backtrace of the caller function to FILE* out. </p>
<dl class="section warning"><dt>Warning</dt><dd>The binary has to be compiled with <code>-rdynamic</code> for meaningful output. </dd></dl>

<p class="definition">Definition at line <a class="el" href="backtrace_8cpp_source.html#l00073">73</a> of file <a class="el" href="backtrace_8cpp_source.html">backtrace.cpp</a>.</p>

<p class="reference">References <a class="el" href="malloc__tracker_8cpp_source.html#l01038">free()</a>, and <a class="el" href="unused_8hpp_source.html#l00020">unused()</a>.</p>

</div>
</div>
<a id="a5e964500195bf49264036402214d61ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e964500195bf49264036402214d61ed">&#9670;&nbsp;</a></span>print_raw_backtrace() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_raw_backtrace </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_frames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a plain hex stack backtrace of the called function to FILE* out, prefixed with the given printf formatted output. </p>

<p class="definition">Definition at line <a class="el" href="backtrace_8cpp_source.html#l00030">30</a> of file <a class="el" href="backtrace_8cpp_source.html">backtrace.cpp</a>.</p>

<p class="reference">References <a class="el" href="unused_8hpp_source.html#l00020">unused()</a>.</p>

<p class="reference">Referenced by <a class="el" href="malloc__tracker_8cpp_source.html#l00461">thrill::mem::bypass_malloc()</a>, <a class="el" href="malloc__tracker_8cpp_source.html#l00816">thrill::mem::malloc_tracker_print_leaks()</a>, and <a class="el" href="backtrace_8cpp_source.html#l00069">print_raw_backtrace()</a>.</p>

</div>
</div>
<a id="a1d2bac4967f005d9dd31c0c300eef091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d2bac4967f005d9dd31c0c300eef091">&#9670;&nbsp;</a></span>print_raw_backtrace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void print_raw_backtrace </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_frames</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a plain hex stack backtrace of the called function to FILE* out. </p>

<p class="definition">Definition at line <a class="el" href="backtrace_8cpp_source.html#l00069">69</a> of file <a class="el" href="backtrace_8cpp_source.html">backtrace.cpp</a>.</p>

<p class="reference">References <a class="el" href="backtrace_8cpp_source.html#l00030">print_raw_backtrace()</a>.</p>

</div>
</div>
<a id="aa17989dc1fbbf1047c8f238aaafe7092"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa17989dc1fbbf1047c8f238aaafe7092">&#9670;&nbsp;</a></span>set_die_with_exception()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool set_die_with_exception </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Switch between dying via std::terminate() and throwing an exception. Alternatively define the macro TLX_DIE_WITH_EXCEPTION=1 </p>

<p class="definition">Definition at line <a class="el" href="die_2core_8cpp_source.html#l00052">52</a> of file <a class="el" href="die_2core_8cpp_source.html">core.cpp</a>.</p>

<p class="reference">References <a class="el" href="die_2core_8cpp_source.html#l00021">s_die_with_exception</a>.</p>

</div>
</div>
<a id="a369d24d80d405a29502266c3c3742b42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a369d24d80d405a29502266c3c3742b42">&#9670;&nbsp;</a></span>set_logger_output_hook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1LoggerOutputHook.html">LoggerOutputHook</a> * set_logger_output_hook </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtlx_1_1LoggerOutputHook.html">LoggerOutputHook</a> *&#160;</td>
          <td class="paramname"><em>hook</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>set new <a class="el" href="classtlx_1_1LoggerOutputHook.html" title="Abstract class to implement output hooks for logging. ">LoggerOutputHook</a> instance to receive global log lines. returns the old hook. </p>

<p class="definition">Definition at line <a class="el" href="logger_2core_8cpp_source.html#l00065">65</a> of file <a class="el" href="logger_2core_8cpp_source.html">core.cpp</a>.</p>

<p class="reference">References <a class="el" href="logger_2core_8cpp_source.html#l00061">s_logger_output_hook</a>.</p>

<p class="reference">Referenced by <a class="el" href="logger_2core_8cpp_source.html#l00118">LoggerCollectOutput::LoggerCollectOutput()</a>, <a class="el" href="logger_2core_8cpp_source.html#l00069">set_logger_to_stderr()</a>, and <a class="el" href="logger_2core_8cpp_source.html#l00123">LoggerCollectOutput::~LoggerCollectOutput()</a>.</p>

</div>
</div>
<a id="a6f6fd6485b3c32e7706d585634e012d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f6fd6485b3c32e7706d585634e012d0">&#9670;&nbsp;</a></span>set_logger_prefix_hook()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1LoggerPrefixHook.html">LoggerPrefixHook</a> * set_logger_prefix_hook </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtlx_1_1LoggerPrefixHook.html">LoggerPrefixHook</a> *&#160;</td>
          <td class="paramname"><em>hook</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set new <a class="el" href="classtlx_1_1LoggerPrefixHook.html" title="Abstract class to implement prefix output hooks for logging. ">LoggerPrefixHook</a> instance to prefix global log lines. Returns the old hook. </p>

<p class="definition">Definition at line <a class="el" href="logger_2core_8cpp_source.html#l00080">80</a> of file <a class="el" href="logger_2core_8cpp_source.html">core.cpp</a>.</p>

<p class="reference">References <a class="el" href="logger_2core_8cpp_source.html#l00076">s_logger_prefix_hook</a>.</p>

</div>
</div>
<a id="aafcbf5e112757758add1662cf66498d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafcbf5e112757758add1662cf66498d0">&#9670;&nbsp;</a></span>set_logger_to_stderr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1LoggerOutputHook.html">LoggerOutputHook</a> * set_logger_to_stderr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>install default logger to cerr / stderr instead of stdout. returns the old hook. </p>

<p class="definition">Definition at line <a class="el" href="logger_2core_8cpp_source.html#l00069">69</a> of file <a class="el" href="logger_2core_8cpp_source.html">core.cpp</a>.</p>

<p class="reference">References <a class="el" href="logger_2core_8cpp_source.html#l00065">set_logger_output_hook()</a>.</p>

</div>
</div>
<a id="ac377d7abe96391a306d74f49c1f92ab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac377d7abe96391a306d74f49c1f92ab0">&#9670;&nbsp;</a></span>siphash() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t tlx::siphash </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>key</em>[16], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="siphash_8hpp_source.html#l00240">240</a> of file <a class="el" href="siphash_8hpp_source.html">siphash.hpp</a>.</p>

<p class="reference">References <a class="el" href="siphash_8hpp_source.html#l00042">siphash_plain()</a>.</p>

<p class="reference">Referenced by <a class="el" href="core_2hyperloglog_8hpp_source.html#l00047">HyperLogLogRegisters&lt; p &gt;::insert()</a>, and <a class="el" href="siphash_8hpp_source.html#l00249">siphash()</a>.</p>

</div>
</div>
<a id="ab5b74a8ec4e849ee19578715c65836ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5b74a8ec4e849ee19578715c65836ab">&#9670;&nbsp;</a></span>siphash() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t tlx::siphash </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="siphash_8hpp_source.html#l00249">249</a> of file <a class="el" href="siphash_8hpp_source.html">siphash.hpp</a>.</p>

<p class="reference">References <a class="el" href="siphash_8hpp_source.html#l00240">siphash()</a>.</p>

</div>
</div>
<a id="a9a3b1c56cc81840ced52f695ee4bcfdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a3b1c56cc81840ced52f695ee4bcfdd">&#9670;&nbsp;</a></span>siphash() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t tlx::siphash </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="siphash_8hpp_source.html#l00257">257</a> of file <a class="el" href="siphash_8hpp_source.html">siphash.hpp</a>.</p>

<p class="reference">References <a class="el" href="siphash_8hpp_source.html#l00240">siphash()</a>.</p>

</div>
</div>
<a id="a8194cb6726acefe4fd4f7993c1b1fdfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8194cb6726acefe4fd4f7993c1b1fdfd">&#9670;&nbsp;</a></span>siphash() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t tlx::siphash </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="siphash_8hpp_source.html#l00262">262</a> of file <a class="el" href="siphash_8hpp_source.html">siphash.hpp</a>.</p>

<p class="reference">References <a class="el" href="siphash_8hpp_source.html#l00240">siphash()</a>.</p>

</div>
</div>
<a id="a36e52665aa49af074f344396ad6264f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36e52665aa49af074f344396ad6264f8">&#9670;&nbsp;</a></span>siphash() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t tlx::siphash </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="siphash_8hpp_source.html#l00268">268</a> of file <a class="el" href="siphash_8hpp_source.html">siphash.hpp</a>.</p>

<p class="reference">References <a class="el" href="siphash_8hpp_source.html#l00240">siphash()</a>.</p>

</div>
</div>
<a id="a1dbb7e10c5e866474d0a516ba06388f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dbb7e10c5e866474d0a516ba06388f8">&#9670;&nbsp;</a></span>siphash_plain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint64_t tlx::siphash_plain </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&#160;</td>
          <td class="paramname"><em>key</em>[16], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="siphash_8hpp_source.html#l00042">42</a> of file <a class="el" href="siphash_8hpp_source.html">siphash.hpp</a>.</p>

<p class="reference">References <a class="el" href="attribute__fallthrough_8hpp_source.html#l00027">TLX_ATTRIBUTE_FALLTHROUGH</a>, <a class="el" href="siphash_8hpp.html#acdaafa9d242d6164e81b60fa64617feb">TLX_SIPCOMPRESS</a>, and <a class="el" href="extlib_2foxxll_2foxxll_2common_2uint__types_8hpp_source.html#l00128">ull()</a>.</p>

<p class="reference">Referenced by <a class="el" href="siphash_8hpp_source.html#l00240">siphash()</a>.</p>

</div>
</div>
<a id="ae88597e53210df27ef4d5db668a02fa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae88597e53210df27ef4d5db668a02fa7">&#9670;&nbsp;</a></span>split()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt;std::string&gt;&amp; tlx::split </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; *&#160;</td>
          <td class="paramname"><em>into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sep_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="split_8cpp_source.html#l00107">107</a> of file <a class="el" href="split_8cpp_source.html">split.cpp</a>.</p>

</div>
</div>
<a id="ga1cc4f715331a96631370a8a25d6e9526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cc4f715331a96631370a8a25d6e9526">&#9670;&nbsp;</a></span>ssnprintf_generic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">String String tlx::ssnprintf_generic </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ssprintf__generic_8hpp_source.html#l00070">70</a> of file <a class="el" href="ssprintf__generic_8hpp_source.html">ssprintf_generic.hpp</a>.</p>

</div>
</div>
<a id="gaa45e4c8639177f5deb682313a572c32b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa45e4c8639177f5deb682313a572c32b">&#9670;&nbsp;</a></span>ssprintf_generic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">String String tlx::ssprintf_generic </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ssprintf__generic_8hpp_source.html#l00035">35</a> of file <a class="el" href="ssprintf__generic_8hpp_source.html">ssprintf_generic.hpp</a>.</p>

<p class="reference">References <a class="el" href="group__tlx__string.html#ga1cc4f715331a96631370a8a25d6e9526">ssnprintf_generic()</a>, and <a class="el" href="attribute__format__printf_8hpp_source.html#l00026">TLX_ATTRIBUTE_FORMAT_PRINTF</a>.</p>

</div>
</div>
<a id="ade1320658af9846df1831480a96e7a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade1320658af9846df1831480a96e7a38">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void tlx::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtlx_1_1CountingPtr.html">CountingPtr</a>&lt; A, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtlx_1_1CountingPtr.html">CountingPtr</a>&lt; A, D &gt; &amp;&#160;</td>
          <td class="paramname"><em>a2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>swap enclosed object with another counting pointer (no reference counts need change) </p>

<p class="definition">Definition at line <a class="el" href="counting__ptr_8hpp_source.html#l00320">320</a> of file <a class="el" href="counting__ptr_8hpp_source.html">counting_ptr.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="thrill_2data_2file_8cpp_source.html#l00057">File::Clear()</a>, <a class="el" href="loser__tree_8hpp_source.html#l00198">LoserTreeCopy&lt; Stable, ValueType, Comparator &gt;::delete_min_insert()</a>, <a class="el" href="loser__tree_8hpp_source.html#l00265">LoserTreeCopy&lt; true, ValueType, Comparator &gt;::delete_min_insert()</a>, <a class="el" href="loser__tree_8hpp_source.html#l00433">LoserTreePointer&lt; Stable, ValueType, Comparator &gt;::delete_min_insert()</a>, <a class="el" href="loser__tree_8hpp_source.html#l00493">LoserTreePointer&lt; true, ValueType, Comparator &gt;::delete_min_insert()</a>, <a class="el" href="loser__tree_8hpp_source.html#l00629">LoserTreeCopyUnguarded&lt; Stable, ValueType, Comparator &gt;::delete_min_insert()</a>, <a class="el" href="loser__tree_8hpp_source.html#l00670">LoserTreeCopyUnguarded&lt; true, ValueType, Comparator &gt;::delete_min_insert()</a>, <a class="el" href="loser__tree_8hpp_source.html#l00806">LoserTreePointerUnguarded&lt; Stable, ValueType, Comparator &gt;::delete_min_insert()</a>, <a class="el" href="loser__tree_8hpp_source.html#l00844">LoserTreePointerUnguarded&lt; true, ValueType, Comparator &gt;::delete_min_insert()</a>, <a class="el" href="binary__heap_8hpp_source.html#l00079">BinaryHeap&lt; Timer &gt;::erase()</a>, <a class="el" href="polynomial__regression_8hpp_source.html#l00154">PolynomialRegression&lt; Type, WithStore &gt;::fit_coefficients()</a>, <a class="el" href="qsort_8hpp_source.html#l00113">thrill::common::qsort_local::InsertionSort()</a>, <a class="el" href="levenshtein_8hpp_source.html#l00067">levenshtein_algorithm()</a>, <a class="el" href="parallel__sample__sort_8hpp_source.html#l00760">PS5SmallsortJob&lt; Context, StringPtr, BktSizeType &gt;::MKQSStep::MKQSStep()</a>, <a class="el" href="multikey__quicksort_8hpp_source.html#l00074">tlx::sort_strings_detail::multikey_quicksort()</a>, <a class="el" href="extlib_2tlx_2tlx_2algorithm_2multiway__merge_8hpp_source.html#l00728">tlx::multiway_merge_detail::multiway_merge_bubble()</a>, <a class="el" href="thrill_2api_2sort_8hpp_source.html#l00744">SortNode&lt; ValueType, CompareFunction, SortAlgorithm, Stable &gt;::PartialMultiwayMerge()</a>, <a class="el" href="d__ary__heap_8hpp_source.html#l00107">DAryHeap&lt; KeyType, Arity, Compare &gt;::pop()</a>, <a class="el" href="binary__heap_8hpp_source.html#l00178">BinaryHeap&lt; Timer &gt;::pop_heap()</a>, <a class="el" href="qsort_8hpp_source.html#l00244">thrill::common::qsort_three_pivots()</a>, <a class="el" href="qsort_8hpp_source.html#l00186">thrill::common::qsort_two_pivots_yaroslavskiy()</a>, <a class="el" href="thrill_2common_2radix__sort_8hpp_source.html#l00038">thrill::common::radix_sort_CI()</a>, <a class="el" href="extlib_2tlx_2tlx_2sort_2strings_2radix__sort_8hpp_source.html#l00547">RadixStep_CI2&lt; StringPtr &gt;::RadixStep_CI2()</a>, <a class="el" href="extlib_2tlx_2tlx_2sort_2strings_2radix__sort_8hpp_source.html#l00711">RadixStep_CI3&lt; StringPtr &gt;::RadixStep_CI3()</a>, <a class="el" href="random__bipartition__shuffle_8hpp_source.html#l00044">random_bipartition_shuffle()</a>, <a class="el" href="d__ary__addressable__int__heap_8hpp_source.html#l00140">DAryAddressableIntHeap&lt; KeyType, Arity, Compare &gt;::remove()</a>, <a class="el" href="block__scheduler_8hpp_source.html#l01285">block_scheduler_algorithm_offline_lru_prefetching&lt; SwappableBlockType &gt;::schedule_read()</a>, <a class="el" href="qsort_8hpp_source.html#l00051">thrill::common::qsort_local::sort3()</a>, <a class="el" href="qsort_8hpp_source.html#l00076">thrill::common::qsort_local::sort4()</a>, <a class="el" href="qsort_8hpp_source.html#l00093">thrill::common::qsort_local::sort5()</a>, <a class="el" href="thrill_2common_2math_8hpp_source.html#l00071">Range::Swap()</a>, <a class="el" href="container_2simple__vector_8hpp_source.html#l00104">SimpleVector&lt; std::thread &gt;::swap()</a>, <a class="el" href="btree__set_8hpp_source.html#l00202">btree_set&lt; Key_, Compare_, Traits_, Alloc_ &gt;::swap()</a>, <a class="el" href="btree__multiset_8hpp_source.html#l00203">btree_multiset&lt; Key_, Compare_, Traits_, Alloc_ &gt;::swap()</a>, <a class="el" href="btree__map_8hpp_source.html#l00204">btree_map&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::swap()</a>, <a class="el" href="btree__multimap_8hpp_source.html#l00205">btree_multimap&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::swap()</a>, <a class="el" href="counting__ptr_8hpp_source.html#l00238">CountingPtr&lt; WriteStream &gt;::swap()</a>, <a class="el" href="delegate_8hpp_source.html#l00266">Delegate&lt; R(A...), Allocator &gt;::swap()</a>, <a class="el" href="btree_8hpp_source.html#l01144">BTree&lt; key_type, value_type, key_of_value, key_compare, traits, true, allocator_type &gt;::swap()</a>, <a class="el" href="utils_8hpp_source.html#l00089">foxxll::swap_1D_arrays()</a>, <a class="el" href="thrill_2api_2sort_8hpp_source.html#l00434">SortNode&lt; ValueType, CompareFunction, SortAlgorithm, Stable &gt;::TransmitItems()</a>, <a class="el" href="multikey__quicksort_8hpp_source.html#l00040">tlx::sort_strings_detail::vec_swap()</a>, and <a class="el" href="vector__free_8hpp_source.html#l00021">vector_free()</a>.</p>

</div>
</div>
<a id="a5ae9556f2da6820a4e4b5f85c4ab229e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae9556f2da6820a4e4b5f85c4ab229e">&#9670;&nbsp;</a></span>timestamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double timestamp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns number of seconds since the epoch, currently microsecond resolution. </p>

<p class="definition">Definition at line <a class="el" href="timestamp_8cpp_source.html#l00017">17</a> of file <a class="el" href="timestamp_8cpp_source.html">timestamp.cpp</a>.</p>

</div>
</div>
<a id="a5a63b398e6678264958fb8590e9332bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a63b398e6678264958fb8590e9332bf">&#9670;&nbsp;</a></span>unused()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tlx::unused </td>
          <td>(</td>
          <td class="paramtype">Types &amp;&amp;&#160;</td>
          <td class="paramname"><em>...</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="unused_8hpp_source.html#l00020">20</a> of file <a class="el" href="unused_8hpp_source.html">unused.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="block__scheduler_8hpp_source.html#l01701">block_scheduler_algorithm_offline_lru_prefetching&lt; SwappableBlockType &gt;::acquire()</a>, <a class="el" href="async__schedule_8cpp_source.html#l00172">foxxll::compute_prefetch_schedule()</a>, <a class="el" href="loser__tree_8hpp_source.html#l00433">LoserTreePointer&lt; Stable, ValueType, Comparator &gt;::delete_min_insert()</a>, <a class="el" href="loser__tree_8hpp_source.html#l00493">LoserTreePointer&lt; true, ValueType, Comparator &gt;::delete_min_insert()</a>, <a class="el" href="loser__tree_8hpp_source.html#l00629">LoserTreeCopyUnguarded&lt; Stable, ValueType, Comparator &gt;::delete_min_insert()</a>, <a class="el" href="loser__tree_8hpp_source.html#l00670">LoserTreeCopyUnguarded&lt; true, ValueType, Comparator &gt;::delete_min_insert()</a>, <a class="el" href="loser__tree_8hpp_source.html#l00806">LoserTreePointerUnguarded&lt; Stable, ValueType, Comparator &gt;::delete_min_insert()</a>, <a class="el" href="loser__tree_8hpp_source.html#l00844">LoserTreePointerUnguarded&lt; true, ValueType, Comparator &gt;::delete_min_insert()</a>, <a class="el" href="memory__file_8cpp_source.html#l00073">memory_file::discard()</a>, <a class="el" href="fileperblock__file_8cpp_source.html#l00105">fileperblock_file&lt; base_file_type &gt;::discard()</a>, <a class="el" href="extlib_2foxxll_2foxxll_2io_2file_8hpp_source.html#l00159">file::discard()</a>, <a class="el" href="fileperblock__file_8cpp_source.html#l00122">fileperblock_file&lt; base_file_type &gt;::export_files()</a>, <a class="el" href="extlib_2foxxll_2foxxll_2io_2file_8hpp_source.html#l00165">file::export_files()</a>, <a class="el" href="loser__tree_8hpp_source.html#l00362">LoserTreePointerBase&lt; ValueType, Comparator &gt;::insert_start()</a>, <a class="el" href="loser__tree_8hpp_source.html#l00573">LoserTreeCopyUnguardedBase&lt; ValueType, Comparator &gt;::insert_start()</a>, <a class="el" href="loser__tree_8hpp_source.html#l00751">LoserTreePointerUnguardedBase&lt; ValueType, Comparator &gt;::insert_start()</a>, <a class="el" href="porting_8cpp_source.html#l00068">thrill::common::LogCmdlineParams()</a>, <a class="el" href="zip__window_8hpp_source.html#l00394">ZipWindowNode&lt; ValueType, ZipFunction_, Pad_, UnequalCheck, UseStdArray, kNumInputs_ &gt;::MainOp()</a>, <a class="el" href="extlib_2tlx_2tlx_2algorithm_2multiway__merge_8hpp_source.html#l00374">tlx::multiway_merge_detail::multiway_merge_3_variant()</a>, <a class="el" href="extlib_2tlx_2tlx_2algorithm_2multiway__merge_8hpp_source.html#l00548">tlx::multiway_merge_detail::multiway_merge_4_variant()</a>, <a class="el" href="k-means__run_8cpp_source.html#l00049">OutputSVG()</a>, <a class="el" href="parallel__sample__sort_8hpp_source.html#l01464">tlx::sort_strings_detail::parallel_sample_sort_params()</a>, <a class="el" href="porting_8cpp_source.html#l00042">thrill::common::PortSetCloseOnExec()</a>, <a class="el" href="backtrace_8cpp_source.html#l00073">print_cxx_backtrace()</a>, <a class="el" href="backtrace_8cpp_source.html#l00030">print_raw_backtrace()</a>, <a class="el" href="dispatcher_8cpp_source.html#l00174">Dispatcher::PumpRecvQueue()</a>, <a class="el" href="dispatcher_8cpp_source.html#l00158">Dispatcher::PumpSendQueue()</a>, <a class="el" href="dispatcher_8cpp_source.html#l00137">Dispatcher::QueueAsyncRecv()</a>, <a class="el" href="dispatcher_8cpp_source.html#l00117">Dispatcher::QueueAsyncSend()</a>, <a class="el" href="reduce__pre__phase_8hpp_source.html#l00130">ReducePrePhase&lt; TableItem, Key, Value, KeyExtractor, ReduceFunction, VolatileKey, BlockWriter, ReduceConfig_, IndexFunction, KeyEqualFunction, HashFunction, false &gt;::ReducePrePhase()</a>, <a class="el" href="request__queue__impl__1q_8cpp_source.html#l00049">request_queue_impl_1q::request_queue_impl_1q()</a>, <a class="el" href="request__queue__impl__qwqr_8cpp_source.html#l00048">request_queue_impl_qwqr::request_queue_impl_qwqr()</a>, <a class="el" href="block__scheduler_8hpp_source.html#l01238">block_scheduler_algorithm_offline_lru_prefetching&lt; SwappableBlockType &gt;::schedule_write()</a>, <a class="el" href="request__queue_8hpp_source.html#l00048">request_queue::set_priority_op()</a>, <a class="el" href="request__queue__impl__1q_8cpp_source.html#l00056">request_queue_impl_1q::set_priority_op()</a>, <a class="el" href="request__queue__impl__qwqr_8cpp_source.html#l00055">request_queue_impl_qwqr::set_priority_op()</a>, and <a class="el" href="porting_8cpp_source.html#l00111">thrill::common::SetCpuAffinity()</a>.</p>

</div>
</div>
<a id="a3e74e205a0ec4b2d823fd7baf42dcd82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e74e205a0ec4b2d823fd7baf42dcd82">&#9670;&nbsp;</a></span>vector_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tlx::vector_free </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Type &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Simple method to free the underlying memory in a vector, because .clear() need not do it. </p>

<p class="definition">Definition at line <a class="el" href="vector__free_8hpp_source.html#l00021">21</a> of file <a class="el" href="vector__free_8hpp_source.html">vector_free.hpp</a>.</p>

<p class="reference">References <a class="el" href="counting__ptr_8hpp_source.html#l00320">swap()</a>.</p>

<p class="reference">Referenced by <a class="el" href="inner__join_8hpp_source.html#l00380">JoinNode&lt; ValueType, FirstDIA, SecondDIA, KeyExtractor1, KeyExtractor2, JoinFunction, HashFunction, UseLocationDetection &gt;::AddEqualKeysToVec()</a>, <a class="el" href="concat__to__dia_8hpp_source.html#l00054">ConcatToDIANode&lt; ValueType &gt;::Dispose()</a>, <a class="el" href="equal__to__dia_8hpp_source.html#l00056">EqualToDIANode&lt; ValueType &gt;::Dispose()</a>, <a class="el" href="distribute_8hpp_source.html#l00084">DistributeNode&lt; ValueType &gt;::Dispose()</a>, <a class="el" href="reduce__table_8hpp_source.html#l00152">ReduceTable&lt; TableItem, Key, Value, KeyExtractor, ReduceFunction, Emitter, VolatileKey, ReduceConfig_, IndexFunction, KeyEqualFunction &gt;::Dispose()</a>, <a class="el" href="sample_8hpp_source.html#l00165">SampleNode&lt; ValueType &gt;::Dispose()</a>, <a class="el" href="reduce__by__index__post__phase_8hpp_source.html#l00252">ReduceByIndexPostPhase&lt; TableItem, Key, ValueType, KeyExtractor, ReduceFunction, thrill::api::ReduceToIndexNode::Emitter, VolatileKey, ReduceConfig &gt;::Dispose()</a>, <a class="el" href="reduce__old__probing__hash__table_8hpp_source.html#l00253">ReduceOldProbingHashTable&lt; TableItem, Key, Value, KeyExtractor, ReduceFunction, Emitter, VolatileKey, ReduceConfig_, IndexFunction, KeyEqualFunction &gt;::Dispose()</a>, <a class="el" href="read__binary_8hpp_source.html#l00257">ReadBinaryNode&lt; ValueType &gt;::Dispose()</a>, <a class="el" href="reduce__bucket__hash__table_8hpp_source.html#l00334">ReduceBucketHashTable&lt; TableItem, Key, Value, KeyExtractor, ReduceFunction, Emitter, VolatileKey, ReduceConfig, IndexFunction, KeyEqualFunction &gt;::Dispose()</a>, <a class="el" href="location__detection_8hpp_source.html#l00359">LocationDetection&lt; thrill::api::JoinNode::HashCount &gt;::Dispose()</a>, <a class="el" href="location__detection_8hpp_source.html#l00193">LocationDetection&lt; thrill::api::JoinNode::HashCount &gt;::Flush()</a>, <a class="el" href="reduce__by__index__post__phase_8hpp_source.html#l00268">ReduceByIndexPostPhase&lt; TableItem, Key, ValueType, KeyExtractor, ReduceFunction, thrill::api::ReduceToIndexNode::Emitter, VolatileKey, ReduceConfig &gt;::FlushAndConsume()</a>, <a class="el" href="group__to__index_8hpp_source.html#l00234">GroupToIndexNode&lt; ValueType, KeyExtractor, GroupFunction &gt;::MainOp()</a>, <a class="el" href="group__by__key_8hpp_source.html#l00348">GroupByNode&lt; ValueType, KeyExtractor, GroupFunction, HashFunction, UseLocationDetection &gt;::MainOp()</a>, <a class="el" href="thrill_2api_2sort_8hpp_source.html#l00537">SortNode&lt; ValueType, CompareFunction, SortAlgorithm, Stable &gt;::MainOp()</a>, and <a class="el" href="sample_8hpp_source.html#l00127">SampleNode&lt; ValueType &gt;::PushData()</a>.</p>

</div>
</div>
<a id="a2667d7bf97ece107dd08b61ef3a64c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2667d7bf97ece107dd08b61ef3a64c82">&#9670;&nbsp;</a></span>wrap_unp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtlx_1_1enable__if.html">enable_if</a>&lt;!<a class="el" href="structtlx_1_1has__ostream__operator.html">has_ostream_operator</a>&lt;Type&gt;::value, const char*&gt;::type tlx::wrap_unp </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>instead</em> = <code>&quot;&lt;unprintable&gt;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SFINAE magic to return "&lt;unprintable&gt;" instead if the value HAS NO ostream operator &lt;&lt; available. Shortened name of <a class="el" href="namespacetlx.html#a4685dbcbe251d930c560b5071ece8049">wrap_unprintable()</a> </p>

<p class="definition">Definition at line <a class="el" href="wrap__unprintable_8hpp_source.html#l00052">52</a> of file <a class="el" href="wrap__unprintable_8hpp_source.html">wrap_unprintable.hpp</a>.</p>

</div>
</div>
<a id="ad0ffad4740d8fa55e8ad74591b592083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ffad4740d8fa55e8ad74591b592083">&#9670;&nbsp;</a></span>wrap_unp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtlx_1_1enable__if.html">enable_if</a>&lt;<a class="el" href="structtlx_1_1has__ostream__operator.html">has_ostream_operator</a>&lt;Type&gt;::value, Type&gt;::type tlx::wrap_unp </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SFINAE magic to return the value if the value HAS a ostream operator &lt;&lt; available. Shortened name of <a class="el" href="namespacetlx.html#a4685dbcbe251d930c560b5071ece8049">wrap_unprintable()</a> </p>

<p class="definition">Definition at line <a class="el" href="wrap__unprintable_8hpp_source.html#l00060">60</a> of file <a class="el" href="wrap__unprintable_8hpp_source.html">wrap_unprintable.hpp</a>.</p>

<p class="reference">References <a class="el" href="wrap__unprintable_8hpp_source.html#l00024">has_ostream_operator&lt; typename, typename &gt;::value</a>.</p>

</div>
</div>
<a id="a4685dbcbe251d930c560b5071ece8049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4685dbcbe251d930c560b5071ece8049">&#9670;&nbsp;</a></span>wrap_unprintable() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtlx_1_1enable__if.html">enable_if</a>&lt;!<a class="el" href="structtlx_1_1has__ostream__operator.html">has_ostream_operator</a>&lt;Type&gt;::value, const char*&gt;::type tlx::wrap_unprintable </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>instead</em> = <code>&quot;&lt;unprintable&gt;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SFINAE magic to return "&lt;unprintable&gt;" instead if the value HAS NO ostream operator &lt;&lt; available. Identical to shorter <a class="el" href="namespacetlx.html#a2667d7bf97ece107dd08b61ef3a64c82">wrap_unp()</a>. </p>

<p class="definition">Definition at line <a class="el" href="wrap__unprintable_8hpp_source.html#l00036">36</a> of file <a class="el" href="wrap__unprintable_8hpp_source.html">wrap_unprintable.hpp</a>.</p>

</div>
</div>
<a id="ace3a0f19b5c1679cfe2f825709428dbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace3a0f19b5c1679cfe2f825709428dbf">&#9670;&nbsp;</a></span>wrap_unprintable() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtlx_1_1enable__if.html">enable_if</a>&lt;<a class="el" href="structtlx_1_1has__ostream__operator.html">has_ostream_operator</a>&lt;Type&gt;::value, Type&gt;::type tlx::wrap_unprintable </td>
          <td>(</td>
          <td class="paramtype">Type&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>SFINAE magic to return the value if the value HAS a ostream operator &lt;&lt; available. Identical to shorter <a class="el" href="namespacetlx.html#a2667d7bf97ece107dd08b61ef3a64c82">wrap_unp()</a>. </p>

<p class="definition">Definition at line <a class="el" href="wrap__unprintable_8hpp_source.html#l00044">44</a> of file <a class="el" href="wrap__unprintable_8hpp_source.html">wrap_unprintable.hpp</a>.</p>

<p class="reference">References <a class="el" href="wrap__unprintable_8hpp_source.html#l00024">has_ostream_operator&lt; typename, typename &gt;::value</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a30118484a60ca2ede4cf0fe139ce8492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30118484a60ca2ede4cf0fe139ce8492">&#9670;&nbsp;</a></span>s_default_logger_cerr</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DefaultLoggerOutputCErr s_default_logger_cerr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>default logger singletons </p>

<p class="definition">Definition at line <a class="el" href="logger_2core_8cpp_source.html#l00058">58</a> of file <a class="el" href="logger_2core_8cpp_source.html">core.cpp</a>.</p>

</div>
</div>
<a id="a69bbed173aa8becd81930ff5478f80d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69bbed173aa8becd81930ff5478f80d8">&#9670;&nbsp;</a></span>s_default_logger_cout</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">DefaultLoggerOutputCOut s_default_logger_cout</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>default logger singletons </p>

<p class="definition">Definition at line <a class="el" href="logger_2core_8cpp_source.html#l00055">55</a> of file <a class="el" href="logger_2core_8cpp_source.html">core.cpp</a>.</p>

</div>
</div>
<a id="a60940290b9c3ca9e978cd30dca38d8c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60940290b9c3ca9e978cd30dca38d8c8">&#9670;&nbsp;</a></span>s_die_with_exception</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;bool&gt; s_die_with_exception</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">false</span></div><div class="line"></div><div class="line">}</div></div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="die_2core_8cpp_source.html#l00021">21</a> of file <a class="el" href="die_2core_8cpp_source.html">core.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="die_2core_8cpp_source.html#l00029">die_with_message()</a>, and <a class="el" href="die_2core_8cpp_source.html#l00052">set_die_with_exception()</a>.</p>

</div>
</div>
<a id="a043e222f2e520d8002dd4e31b3696edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a043e222f2e520d8002dd4e31b3696edd">&#9670;&nbsp;</a></span>s_logger_output_hook</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;<a class="el" href="classtlx_1_1LoggerOutputHook.html">LoggerOutputHook</a>*&gt; s_logger_output_hook</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line">    &amp;<a class="code" href="namespacetlx.html#a69bbed173aa8becd81930ff5478f80d8">s_default_logger_cout</a></div><div class="line">}</div><div class="ttc" id="namespacetlx_html_a69bbed173aa8becd81930ff5478f80d8"><div class="ttname"><a href="namespacetlx.html#a69bbed173aa8becd81930ff5478f80d8">tlx::s_default_logger_cout</a></div><div class="ttdeci">static DefaultLoggerOutputCOut s_default_logger_cout</div><div class="ttdoc">default logger singletons </div><div class="ttdef"><b>Definition:</b> <a href="logger_2core_8cpp_source.html#l00055">core.cpp:55</a></div></div>
</div><!-- fragment -->
<p>global logger output hook </p>

<p class="definition">Definition at line <a class="el" href="logger_2core_8cpp_source.html#l00061">61</a> of file <a class="el" href="logger_2core_8cpp_source.html">core.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="logger_2core_8cpp_source.html#l00065">set_logger_output_hook()</a>.</p>

</div>
</div>
<a id="ab8c3ea0e853bc0db7e475dce0c2912de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c3ea0e853bc0db7e475dce0c2912de">&#9670;&nbsp;</a></span>s_logger_prefix_hook</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;<a class="el" href="classtlx_1_1LoggerPrefixHook.html">LoggerPrefixHook</a>*&gt; s_logger_prefix_hook</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line">    <span class="keyword">nullptr</span></div><div class="line">}</div></div><!-- fragment -->
<p>global logger prefix hook </p>

<p class="definition">Definition at line <a class="el" href="logger_2core_8cpp_source.html#l00076">76</a> of file <a class="el" href="logger_2core_8cpp_source.html">core.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="logger_2core_8cpp_source.html#l00086">Logger::Logger()</a>, <a class="el" href="logger_2core_8cpp_source.html#l00080">set_logger_prefix_hook()</a>, and <a class="el" href="logger_2core_8cpp_source.html#l00097">SpacingLogger::SpacingLogger()</a>.</p>

</div>
</div>
<a id="a9f7675456bd96ef5d5a01b10a9bb444f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f7675456bd96ef5d5a01b10a9bb444f">&#9670;&nbsp;</a></span>s_timer_add_mutex</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex s_timer_add_mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="multi__timer_8cpp_source.html#l00022">22</a> of file <a class="el" href="multi__timer_8cpp_source.html">multi_timer.cpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacetlx.html">tlx</a></li>
    <li class="footer">Generated on Mon Apr 6 2020 07:29:30 for Thrill by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
