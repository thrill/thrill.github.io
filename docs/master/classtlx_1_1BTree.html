<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Thrill: BTree&lt; Key, Value, KeyOfValue, Compare, Traits, Duplicates, Allocator &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Thrill
   &#160;<span id="projectnumber">0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classtlx_1_1BTree.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="classtlx_1_1BTree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">BTree&lt; Key, Value, KeyOfValue, Compare, Traits, Duplicates, Allocator &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__layers.html">Thrill Layers</a> &raquo; <a class="el" href="group__tlx.html">tlx - C++ Extensions and Utilities</a> &raquo; <a class="el" href="group__tlx__container.html">Containers and Data Structures</a> &raquo; <a class="el" href="group__tlx__container__btree.html">B+ Trees</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Key, typename Value, typename KeyOfValue, typename Compare = std::less&lt;Key&gt;, typename Traits = btree_default_traits&lt;Key, Value&gt;, bool Duplicates = false, typename Allocator = std::allocator&lt;Value&gt;&gt;<br />
class tlx::BTree&lt; Key, Value, KeyOfValue, Compare, Traits, Duplicates, Allocator &gt;</h3>

<p>Basic class implementing a B+ tree data structure in memory. </p>
<p>The base implementation of an in-memory B+ tree. It is based on the implementation in Cormen's Introduction into Algorithms, Jan Jannink's paper and other algorithm resources. Almost all STL-required function calls are implemented. The asymptotic time requirements of the STL are not always fulfilled in theory, however, in practice this B+ tree performs better than a red-black tree and almost always uses less memory. The insertion function splits the nodes on the recursion unroll. Erase is largely based on Jannink's ideas.</p>
<p>This class is specialized into <a class="el" href="classtlx_1_1btree__set.html" title="Specialized B+ tree template class implementing STL&#39;s set container. ">btree_set</a>, <a class="el" href="classtlx_1_1btree__multiset.html" title="Specialized B+ tree template class implementing STL&#39;s multiset container. ">btree_multiset</a>, <a class="el" href="classtlx_1_1btree__map.html" title="Specialized B+ tree template class implementing STL&#39;s map container. ">btree_map</a> and <a class="el" href="classtlx_1_1btree__multimap.html" title="Specialized B+ tree template class implementing STL&#39;s multimap container. ">btree_multimap</a> using default template parameters and facade functions. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l00124">124</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>
</div><div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for BTree&lt; Key, Value, KeyOfValue, Compare, Traits, Duplicates, Allocator &gt;:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classtlx_1_1BTree__inherit__graph.svg" width="611" height="176"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for BTree&lt; Key, Value, KeyOfValue, Compare, Traits, Duplicates, Allocator &gt;:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="classtlx_1_1BTree__coll__graph.svg" width="368" height="264"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>

<p><code>#include &lt;<a class="el" href="btree_8hpp_source.html">btree.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree_1_1const__iterator.html">const_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree_1_1const__reverse__iterator.html">const_reverse_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree_1_1iterator.html">iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1BTree_1_1LeafNode.html">LeafNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1BTree_1_1node.html">node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1BTree_1_1result__t.html">result_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree_1_1reverse__iterator.html">reverse_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1BTree_1_1tree__stats.html">tree_stats</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A small struct containing basic statistics about the B+ tree.  <a href="structtlx_1_1BTree_1_1tree__stats.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree_1_1value__compare.html">value_compare</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function class to compare value_type objects. Required by the STL.  <a href="classtlx_1_1BTree_1_1value__compare.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructed Types</div></td></tr>
<tr class="memitem:a33b885434598e4d5ac5f06605e53b678"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classtlx_1_1BTree.html">BTree</a>&lt; <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a>, <a class="el" href="classtlx_1_1BTree.html#a04f69f8f2936ff309627511179c1709b">value_type</a>, <a class="el" href="classtlx_1_1BTree.html#a21e576e049c90e014ffeb583c24d2f38">key_of_value</a>, <a class="el" href="classtlx_1_1BTree.html#a6ff4e347839868db0770859a3dd55a27">key_compare</a>, <a class="el" href="classtlx_1_1BTree.html#ab0d2e59411be6b53e63c29149a17fbcc">traits</a>, <a class="el" href="classtlx_1_1BTree.html#a4a380c8745ff0a1c814742821e85403e">allow_duplicates</a>, <a class="el" href="classtlx_1_1BTree.html#aff35d256caa55f37343da8200179e608">allocator_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a33b885434598e4d5ac5f06605e53b678">Self</a></td></tr>
<tr class="memdesc:a33b885434598e4d5ac5f06605e53b678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Typedef of our own type.  <a href="#a33b885434598e4d5ac5f06605e53b678">More...</a><br /></td></tr>
<tr class="separator:a33b885434598e4d5ac5f06605e53b678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b489a408a211a90e766329c0732d7b"><td class="memItemLeft" align="right" valign="top">typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a49b489a408a211a90e766329c0732d7b">size_type</a></td></tr>
<tr class="memdesc:a49b489a408a211a90e766329c0732d7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Size type used to count keys.  <a href="#a49b489a408a211a90e766329c0732d7b">More...</a><br /></td></tr>
<tr class="separator:a49b489a408a211a90e766329c0732d7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and Destructor</div></td></tr>
<tr class="memitem:a6f73c3bb670ec75c0b6910927cf6606b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a6f73c3bb670ec75c0b6910927cf6606b">BTree</a> (const <a class="el" href="classtlx_1_1BTree.html#aff35d256caa55f37343da8200179e608">allocator_type</a> &amp;alloc=<a class="el" href="classtlx_1_1BTree.html#aff35d256caa55f37343da8200179e608">allocator_type</a>())</td></tr>
<tr class="separator:a6f73c3bb670ec75c0b6910927cf6606b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f96f907c281e0c29c4f5129b6cf3169"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a8f96f907c281e0c29c4f5129b6cf3169">BTree</a> (const <a class="el" href="classtlx_1_1BTree.html#a6ff4e347839868db0770859a3dd55a27">key_compare</a> &amp;kcf, const <a class="el" href="classtlx_1_1BTree.html#aff35d256caa55f37343da8200179e608">allocator_type</a> &amp;alloc=<a class="el" href="classtlx_1_1BTree.html#aff35d256caa55f37343da8200179e608">allocator_type</a>())</td></tr>
<tr class="separator:a8f96f907c281e0c29c4f5129b6cf3169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cbb054ada3a2e9ebe4f822f0799b10b"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:a6cbb054ada3a2e9ebe4f822f0799b10b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a6cbb054ada3a2e9ebe4f822f0799b10b">BTree</a> (InputIterator first, InputIterator last, const <a class="el" href="classtlx_1_1BTree.html#aff35d256caa55f37343da8200179e608">allocator_type</a> &amp;alloc=<a class="el" href="classtlx_1_1BTree.html#aff35d256caa55f37343da8200179e608">allocator_type</a>())</td></tr>
<tr class="separator:a6cbb054ada3a2e9ebe4f822f0799b10b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c4fcb14953cafb848894fccab09ebe"><td class="memTemplParams" colspan="2">template&lt;class InputIterator &gt; </td></tr>
<tr class="memitem:ad9c4fcb14953cafb848894fccab09ebe"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#ad9c4fcb14953cafb848894fccab09ebe">BTree</a> (InputIterator first, InputIterator last, const <a class="el" href="classtlx_1_1BTree.html#a6ff4e347839868db0770859a3dd55a27">key_compare</a> &amp;kcf, const <a class="el" href="classtlx_1_1BTree.html#aff35d256caa55f37343da8200179e608">allocator_type</a> &amp;alloc=<a class="el" href="classtlx_1_1BTree.html#aff35d256caa55f37343da8200179e608">allocator_type</a>())</td></tr>
<tr class="separator:ad9c4fcb14953cafb848894fccab09ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af50bbeb39af1051f057b65da1c71a671"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#af50bbeb39af1051f057b65da1c71a671">~BTree</a> ()</td></tr>
<tr class="memdesc:af50bbeb39af1051f057b65da1c71a671"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees up all used B+ tree memory pages.  <a href="#af50bbeb39af1051f057b65da1c71a671">More...</a><br /></td></tr>
<tr class="separator:af50bbeb39af1051f057b65da1c71a671"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1e04d5d606adc2876b61fafc73c645"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a0c1e04d5d606adc2876b61fafc73c645">swap</a> (<a class="el" href="classtlx_1_1BTree.html">BTree</a> &amp;from)</td></tr>
<tr class="memdesc:a0c1e04d5d606adc2876b61fafc73c645"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fast swapping of two identical B+ tree objects.  <a href="#a0c1e04d5d606adc2876b61fafc73c645">More...</a><br /></td></tr>
<tr class="separator:a0c1e04d5d606adc2876b61fafc73c645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Key and Value Comparison Function Objects</div></td></tr>
<tr class="memitem:ae9e650d8249954362ec4225dfb73e9fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1BTree.html#a6ff4e347839868db0770859a3dd55a27">key_compare</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#ae9e650d8249954362ec4225dfb73e9fe">key_comp</a> () const</td></tr>
<tr class="memdesc:ae9e650d8249954362ec4225dfb73e9fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constant access to the key comparison object sorting the B+ tree.  <a href="#ae9e650d8249954362ec4225dfb73e9fe">More...</a><br /></td></tr>
<tr class="separator:ae9e650d8249954362ec4225dfb73e9fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac312f2a857eabffe1ca5c8711e0207bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1BTree_1_1value__compare.html">value_compare</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#ac312f2a857eabffe1ca5c8711e0207bc">value_comp</a> () const</td></tr>
<tr class="separator:ac312f2a857eabffe1ca5c8711e0207bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Allocators</div></td></tr>
<tr class="memitem:a6e99c6263568d88f95ca01dc694f1051"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1BTree.html#aff35d256caa55f37343da8200179e608">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a6e99c6263568d88f95ca01dc694f1051">get_allocator</a> () const</td></tr>
<tr class="memdesc:a6e99c6263568d88f95ca01dc694f1051"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the base node allocator provided during construction.  <a href="#a6e99c6263568d88f95ca01dc694f1051">More...</a><br /></td></tr>
<tr class="separator:a6e99c6263568d88f95ca01dc694f1051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">STL Iterator Construction Functions</div></td></tr>
<tr class="memitem:ad69bd11391be1a1dba5c8202259664f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1BTree_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#ad69bd11391be1a1dba5c8202259664f8">begin</a> ()</td></tr>
<tr class="separator:ad69bd11391be1a1dba5c8202259664f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad38d52497a975bfb6f2f6acd76631f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1BTree_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#acad38d52497a975bfb6f2f6acd76631f">end</a> ()</td></tr>
<tr class="separator:acad38d52497a975bfb6f2f6acd76631f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29305669b60ca1680752e2fc3592ba99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1BTree_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a29305669b60ca1680752e2fc3592ba99">begin</a> () const</td></tr>
<tr class="separator:a29305669b60ca1680752e2fc3592ba99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf9a4bd0c34d4a5f6a7dab66ea10cdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1BTree_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#accf9a4bd0c34d4a5f6a7dab66ea10cdc">end</a> () const</td></tr>
<tr class="separator:accf9a4bd0c34d4a5f6a7dab66ea10cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acea44ed500a54b2bb93e16b86e81afa8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1BTree_1_1reverse__iterator.html">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#acea44ed500a54b2bb93e16b86e81afa8">rbegin</a> ()</td></tr>
<tr class="separator:acea44ed500a54b2bb93e16b86e81afa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68c599ddcbfddc65170de524ac165e44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1BTree_1_1reverse__iterator.html">reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a68c599ddcbfddc65170de524ac165e44">rend</a> ()</td></tr>
<tr class="separator:a68c599ddcbfddc65170de524ac165e44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af086cceac199bd735c7a97c2a8d7ed21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1BTree_1_1const__reverse__iterator.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#af086cceac199bd735c7a97c2a8d7ed21">rbegin</a> () const</td></tr>
<tr class="separator:af086cceac199bd735c7a97c2a8d7ed21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07da1fdc890b6949f1a20a1961c6fc44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1BTree_1_1const__reverse__iterator.html">const_reverse_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a07da1fdc890b6949f1a20a1961c6fc44">rend</a> () const</td></tr>
<tr class="separator:a07da1fdc890b6949f1a20a1961c6fc44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Access Functions to the Item Count</div></td></tr>
<tr class="memitem:a60304b65bf89363bcc3165d3cde67f86"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1BTree.html#a49b489a408a211a90e766329c0732d7b">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a60304b65bf89363bcc3165d3cde67f86">size</a> () const</td></tr>
<tr class="memdesc:a60304b65bf89363bcc3165d3cde67f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of key/data pairs in the B+ tree.  <a href="#a60304b65bf89363bcc3165d3cde67f86">More...</a><br /></td></tr>
<tr class="separator:a60304b65bf89363bcc3165d3cde67f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644718bb2fb240de962dc3c9a1fdf0dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a644718bb2fb240de962dc3c9a1fdf0dc">empty</a> () const</td></tr>
<tr class="memdesc:a644718bb2fb240de962dc3c9a1fdf0dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if there is at least one key/data pair in the B+ tree.  <a href="#a644718bb2fb240de962dc3c9a1fdf0dc">More...</a><br /></td></tr>
<tr class="separator:a644718bb2fb240de962dc3c9a1fdf0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95205eb0260cd9ed6efac29f93508193"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1BTree.html#a49b489a408a211a90e766329c0732d7b">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a95205eb0260cd9ed6efac29f93508193">max_size</a> () const</td></tr>
<tr class="separator:a95205eb0260cd9ed6efac29f93508193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a41faf8b8ec2c138a53d4c1b1a1873c"><td class="memItemLeft" align="right" valign="top">const struct <a class="el" href="structtlx_1_1BTree_1_1tree__stats.html">tree_stats</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a1a41faf8b8ec2c138a53d4c1b1a1873c">get_stats</a> () const</td></tr>
<tr class="memdesc:a1a41faf8b8ec2c138a53d4c1b1a1873c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a const reference to the current statistics.  <a href="#a1a41faf8b8ec2c138a53d4c1b1a1873c">More...</a><br /></td></tr>
<tr class="separator:a1a41faf8b8ec2c138a53d4c1b1a1873c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">STL Access Functions Querying the Tree by Descending to a Leaf</div></td></tr>
<tr class="memitem:ab753b07ce19a1e35c9b3d56e73a879f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#ab753b07ce19a1e35c9b3d56e73a879f0">exists</a> (const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;key) const</td></tr>
<tr class="separator:ab753b07ce19a1e35c9b3d56e73a879f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c9766a96c492f3e9e5861d6b4f87387"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1BTree_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a9c9766a96c492f3e9e5861d6b4f87387">find</a> (const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;key)</td></tr>
<tr class="separator:a9c9766a96c492f3e9e5861d6b4f87387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a080484f0b756af6f218c0e6bae306"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1BTree_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#af2a080484f0b756af6f218c0e6bae306">find</a> (const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;key) const</td></tr>
<tr class="separator:af2a080484f0b756af6f218c0e6bae306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a644672ba9cde511335e48e231ddbea74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1BTree.html#a49b489a408a211a90e766329c0732d7b">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a644672ba9cde511335e48e231ddbea74">count</a> (const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;key) const</td></tr>
<tr class="separator:a644672ba9cde511335e48e231ddbea74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a373c61cca9b31735f4548b5b59b70184"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1BTree_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a373c61cca9b31735f4548b5b59b70184">lower_bound</a> (const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;key)</td></tr>
<tr class="separator:a373c61cca9b31735f4548b5b59b70184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e4f1a835d27ae60002cc709750b221"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1BTree_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a47e4f1a835d27ae60002cc709750b221">lower_bound</a> (const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;key) const</td></tr>
<tr class="separator:a47e4f1a835d27ae60002cc709750b221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482b50e623a123f653e2a91f113a507b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1BTree_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a482b50e623a123f653e2a91f113a507b">upper_bound</a> (const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;key)</td></tr>
<tr class="separator:a482b50e623a123f653e2a91f113a507b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7256d525d9ea50f133bb206aa869f21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1BTree_1_1const__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#ab7256d525d9ea50f133bb206aa869f21">upper_bound</a> (const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;key) const</td></tr>
<tr class="separator:ab7256d525d9ea50f133bb206aa869f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97bb054bc81e97ec55f0b539cdcbfcde"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtlx_1_1BTree_1_1iterator.html">iterator</a>, <a class="el" href="classtlx_1_1BTree_1_1iterator.html">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a97bb054bc81e97ec55f0b539cdcbfcde">equal_range</a> (const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;key)</td></tr>
<tr class="memdesc:a97bb054bc81e97ec55f0b539cdcbfcde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the B+ tree and returns both <a class="el" href="classtlx_1_1BTree.html#a373c61cca9b31735f4548b5b59b70184">lower_bound()</a> and <a class="el" href="classtlx_1_1BTree.html#a482b50e623a123f653e2a91f113a507b">upper_bound()</a>.  <a href="#a97bb054bc81e97ec55f0b539cdcbfcde">More...</a><br /></td></tr>
<tr class="separator:a97bb054bc81e97ec55f0b539cdcbfcde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b8748584487d921a4bdf3b9ac06be2"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtlx_1_1BTree_1_1const__iterator.html">const_iterator</a>, <a class="el" href="classtlx_1_1BTree_1_1const__iterator.html">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#af9b8748584487d921a4bdf3b9ac06be2">equal_range</a> (const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;key) const</td></tr>
<tr class="memdesc:af9b8748584487d921a4bdf3b9ac06be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches the B+ tree and returns both <a class="el" href="classtlx_1_1BTree.html#a373c61cca9b31735f4548b5b59b70184">lower_bound()</a> and <a class="el" href="classtlx_1_1BTree.html#a482b50e623a123f653e2a91f113a507b">upper_bound()</a>.  <a href="#af9b8748584487d921a4bdf3b9ac06be2">More...</a><br /></td></tr>
<tr class="separator:af9b8748584487d921a4bdf3b9ac06be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">B+ Tree Object Comparison Functions</div></td></tr>
<tr class="memitem:a1ae298c2babff3aff6bd164bd257a685"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a1ae298c2babff3aff6bd164bd257a685">operator==</a> (const <a class="el" href="classtlx_1_1BTree.html">BTree</a> &amp;other) const</td></tr>
<tr class="separator:a1ae298c2babff3aff6bd164bd257a685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953af036ec17e9b0953cfcfd23315352"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a953af036ec17e9b0953cfcfd23315352">operator!=</a> (const <a class="el" href="classtlx_1_1BTree.html">BTree</a> &amp;other) const</td></tr>
<tr class="memdesc:a953af036ec17e9b0953cfcfd23315352"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inequality relation. Based on operator==.  <a href="#a953af036ec17e9b0953cfcfd23315352">More...</a><br /></td></tr>
<tr class="separator:a953af036ec17e9b0953cfcfd23315352"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7da23d4be7770d1c3d32b3b1426e857"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#af7da23d4be7770d1c3d32b3b1426e857">operator&lt;</a> (const <a class="el" href="classtlx_1_1BTree.html">BTree</a> &amp;other) const</td></tr>
<tr class="separator:af7da23d4be7770d1c3d32b3b1426e857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aace573405ed5157dda5d0c8bc74ae2d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#aace573405ed5157dda5d0c8bc74ae2d8">operator&gt;</a> (const <a class="el" href="classtlx_1_1BTree.html">BTree</a> &amp;other) const</td></tr>
<tr class="memdesc:aace573405ed5157dda5d0c8bc74ae2d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater relation. Based on operator&lt;.  <a href="#aace573405ed5157dda5d0c8bc74ae2d8">More...</a><br /></td></tr>
<tr class="separator:aace573405ed5157dda5d0c8bc74ae2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af166796475be0ee04e124e40f60af96e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#af166796475be0ee04e124e40f60af96e">operator&lt;=</a> (const <a class="el" href="classtlx_1_1BTree.html">BTree</a> &amp;other) const</td></tr>
<tr class="memdesc:af166796475be0ee04e124e40f60af96e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Less-equal relation. Based on operator&lt;.  <a href="#af166796475be0ee04e124e40f60af96e">More...</a><br /></td></tr>
<tr class="separator:af166796475be0ee04e124e40f60af96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a177c1adf602ee33c48f94e4906cae241"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a177c1adf602ee33c48f94e4906cae241">operator&gt;=</a> (const <a class="el" href="classtlx_1_1BTree.html">BTree</a> &amp;other) const</td></tr>
<tr class="memdesc:a177c1adf602ee33c48f94e4906cae241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Greater-equal relation. Based on operator&lt;.  <a href="#a177c1adf602ee33c48f94e4906cae241">More...</a><br /></td></tr>
<tr class="separator:a177c1adf602ee33c48f94e4906cae241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Public Insertion Functions</div></td></tr>
<tr class="memitem:aa218c2c89397f8d0484ef9438d540456"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtlx_1_1BTree_1_1iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#aa218c2c89397f8d0484ef9438d540456">insert</a> (const <a class="el" href="classtlx_1_1BTree.html#a04f69f8f2936ff309627511179c1709b">value_type</a> &amp;x)</td></tr>
<tr class="separator:aa218c2c89397f8d0484ef9438d540456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff25301e2f68b6862c2ea4a36dab058"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1BTree_1_1iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a3ff25301e2f68b6862c2ea4a36dab058">insert</a> (<a class="el" href="classtlx_1_1BTree_1_1iterator.html">iterator</a>, const <a class="el" href="classtlx_1_1BTree.html#a04f69f8f2936ff309627511179c1709b">value_type</a> &amp;x)</td></tr>
<tr class="separator:a3ff25301e2f68b6862c2ea4a36dab058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac048f549259de32da2acd742cce52d5c"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:ac048f549259de32da2acd742cce52d5c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#ac048f549259de32da2acd742cce52d5c">insert</a> (InputIterator first, InputIterator last)</td></tr>
<tr class="separator:ac048f549259de32da2acd742cce52d5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Bulk Loader - Construct Tree from Sorted Sequence</div></td></tr>
<tr class="memitem:a3d0a35a00bc2ff5608fe613ea8fa47e6"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a3d0a35a00bc2ff5608fe613ea8fa47e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a3d0a35a00bc2ff5608fe613ea8fa47e6">bulk_load</a> (Iterator ibegin, Iterator iend)</td></tr>
<tr class="separator:a3d0a35a00bc2ff5608fe613ea8fa47e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Public Erase Functions</div></td></tr>
<tr class="memitem:a3a79f5c030eea924dbd8fcc9417b9263"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a3a79f5c030eea924dbd8fcc9417b9263">erase_one</a> (const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;key)</td></tr>
<tr class="separator:a3a79f5c030eea924dbd8fcc9417b9263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57ff6dd1cb4dc347b892dfa87ea6613"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1BTree.html#a49b489a408a211a90e766329c0732d7b">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#ae57ff6dd1cb4dc347b892dfa87ea6613">erase</a> (const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;key)</td></tr>
<tr class="separator:ae57ff6dd1cb4dc347b892dfa87ea6613"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b2d25c3e313e0b24656afe5cd4f6f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#af8b2d25c3e313e0b24656afe5cd4f6f2">erase</a> (<a class="el" href="classtlx_1_1BTree_1_1iterator.html">iterator</a> iter)</td></tr>
<tr class="memdesc:af8b2d25c3e313e0b24656afe5cd4f6f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase the key/data pair referenced by the iterator.  <a href="#af8b2d25c3e313e0b24656afe5cd4f6f2">More...</a><br /></td></tr>
<tr class="separator:af8b2d25c3e313e0b24656afe5cd4f6f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Static Constant Options and Values of the B+ Tree</div></td></tr>
<tr class="memitem:a52e57d8d7e32f6d5a56227a8d1f899cf"><td class="memItemLeft" align="right" valign="top">static const unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a52e57d8d7e32f6d5a56227a8d1f899cf">leaf_slotmax</a> = traits::leaf_slots</td></tr>
<tr class="memdesc:a52e57d8d7e32f6d5a56227a8d1f899cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base B+ tree parameter: The number of key/data slots in each leaf.  <a href="#a52e57d8d7e32f6d5a56227a8d1f899cf">More...</a><br /></td></tr>
<tr class="separator:a52e57d8d7e32f6d5a56227a8d1f899cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a004e76f14b7697d3801e3b1d397da5a5"><td class="memItemLeft" align="right" valign="top">static const unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a004e76f14b7697d3801e3b1d397da5a5">inner_slotmax</a> = traits::inner_slots</td></tr>
<tr class="separator:a004e76f14b7697d3801e3b1d397da5a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbec00fa1cdcfbf6b78482915c644dba"><td class="memItemLeft" align="right" valign="top">static const unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#abbec00fa1cdcfbf6b78482915c644dba">leaf_slotmin</a> = (<a class="el" href="classtlx_1_1BTree.html#a52e57d8d7e32f6d5a56227a8d1f899cf">leaf_slotmax</a> / 2)</td></tr>
<tr class="separator:abbec00fa1cdcfbf6b78482915c644dba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a416b2e639a4ec04429632c3ee85e747c"><td class="memItemLeft" align="right" valign="top">static const unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a416b2e639a4ec04429632c3ee85e747c">inner_slotmin</a> = (<a class="el" href="classtlx_1_1BTree.html#a004e76f14b7697d3801e3b1d397da5a5">inner_slotmax</a> / 2)</td></tr>
<tr class="separator:a416b2e639a4ec04429632c3ee85e747c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a632bc519f850f4af56567ba404f4e"><td class="memItemLeft" align="right" valign="top">static const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a81a632bc519f850f4af56567ba404f4e">self_verify</a> = traits::self_verify</td></tr>
<tr class="separator:a81a632bc519f850f4af56567ba404f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6295d47efda04de55c38cb8ea1cdb807"><td class="memItemLeft" align="right" valign="top">static const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a6295d47efda04de55c38cb8ea1cdb807">debug</a> = traits::debug</td></tr>
<tr class="separator:a6295d47efda04de55c38cb8ea1cdb807"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Support Class Encapsulating Deletion Results</div></td></tr>
<tr class="memitem:a3a617d72a0b84dcbdf111d1fe19ec0b5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a3a617d72a0b84dcbdf111d1fe19ec0b5">result_flags_t</a> { <a class="el" href="classtlx_1_1BTree.html#a3a617d72a0b84dcbdf111d1fe19ec0b5acc548bf14d595f9790f15c6514e626d8">btree_ok</a> = 0, 
<a class="el" href="classtlx_1_1BTree.html#a3a617d72a0b84dcbdf111d1fe19ec0b5a828fdc69a5b8ce344d849c52f4002434">btree_not_found</a> = 1, 
<a class="el" href="classtlx_1_1BTree.html#a3a617d72a0b84dcbdf111d1fe19ec0b5a99aacb09662e9c66cdef8fc5a605ec75">btree_update_lastkey</a> = 2, 
<a class="el" href="classtlx_1_1BTree.html#a3a617d72a0b84dcbdf111d1fe19ec0b5a1253a0a76ac7b4ca061433c10f7f832a">btree_fixmerge</a> = 4
 }<tr class="memdesc:a3a617d72a0b84dcbdf111d1fe19ec0b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result flags of recursive deletion.  <a href="classtlx_1_1BTree.html#a3a617d72a0b84dcbdf111d1fe19ec0b5">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a3a617d72a0b84dcbdf111d1fe19ec0b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Convenient Key Comparison Functions Generated From key_less</div></td></tr>
<tr class="memitem:a20b973c16347c015746fa9ee5884d60a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a20b973c16347c015746fa9ee5884d60a">key_less</a> (const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;a, const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;b) const</td></tr>
<tr class="memdesc:a20b973c16347c015746fa9ee5884d60a"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if a &lt; b ? "constructed" from <a class="el" href="classtlx_1_1BTree.html#a5d945dbdb41ca2fe76d87b2ba122e13e">key_less_()</a>  <a href="#a20b973c16347c015746fa9ee5884d60a">More...</a><br /></td></tr>
<tr class="separator:a20b973c16347c015746fa9ee5884d60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60d771db1962102667ae44cd3396a17"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#ae60d771db1962102667ae44cd3396a17">key_lessequal</a> (const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;a, const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;b) const</td></tr>
<tr class="memdesc:ae60d771db1962102667ae44cd3396a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if a &lt;= b ? constructed from <a class="el" href="classtlx_1_1BTree.html#a20b973c16347c015746fa9ee5884d60a" title="True if a &lt; b ? &quot;constructed&quot; from key_less_() ">key_less()</a>  <a href="#ae60d771db1962102667ae44cd3396a17">More...</a><br /></td></tr>
<tr class="separator:ae60d771db1962102667ae44cd3396a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a889913329d2cfe5e2d6f794162843d15"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a889913329d2cfe5e2d6f794162843d15">key_greater</a> (const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;a, const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;b) const</td></tr>
<tr class="memdesc:a889913329d2cfe5e2d6f794162843d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if a &gt; b ? constructed from <a class="el" href="classtlx_1_1BTree.html#a20b973c16347c015746fa9ee5884d60a" title="True if a &lt; b ? &quot;constructed&quot; from key_less_() ">key_less()</a>  <a href="#a889913329d2cfe5e2d6f794162843d15">More...</a><br /></td></tr>
<tr class="separator:a889913329d2cfe5e2d6f794162843d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69071aa249ceb086b673520deaa927b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a69071aa249ceb086b673520deaa927b0">key_greaterequal</a> (const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;a, const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;b) const</td></tr>
<tr class="memdesc:a69071aa249ceb086b673520deaa927b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">True if a &gt;= b ? constructed from <a class="el" href="classtlx_1_1BTree.html#a20b973c16347c015746fa9ee5884d60a" title="True if a &lt; b ? &quot;constructed&quot; from key_less_() ">key_less()</a>  <a href="#a69071aa249ceb086b673520deaa927b0">More...</a><br /></td></tr>
<tr class="separator:a69071aa249ceb086b673520deaa927b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfb47ece6195973d5cbcf73470f47b06"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#abfb47ece6195973d5cbcf73470f47b06">key_equal</a> (const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;a, const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;b) const</td></tr>
<tr class="separator:abfb47ece6195973d5cbcf73470f47b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Node Object Allocation and Deallocation Functions</div></td></tr>
<tr class="memitem:a353e5a73d56e289c9b48a5bc43e72211"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtlx_1_1BTree_1_1LeafNode.html#a022e856be0486dadd1a67f21a65562f4">LeafNode::alloc_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a353e5a73d56e289c9b48a5bc43e72211">leaf_node_allocator</a> ()</td></tr>
<tr class="memdesc:a353e5a73d56e289c9b48a5bc43e72211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an allocator for <a class="el" href="structtlx_1_1BTree_1_1LeafNode.html">LeafNode</a> objects.  <a href="#a353e5a73d56e289c9b48a5bc43e72211">More...</a><br /></td></tr>
<tr class="separator:a353e5a73d56e289c9b48a5bc43e72211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791d570451c392e04774581a7d04707a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtlx_1_1BTree_1_1InnerNode.html#a420a071517903c1cfc59a6846534982d">InnerNode::alloc_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a791d570451c392e04774581a7d04707a">inner_node_allocator</a> ()</td></tr>
<tr class="memdesc:a791d570451c392e04774581a7d04707a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return an allocator for <a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a> objects.  <a href="#a791d570451c392e04774581a7d04707a">More...</a><br /></td></tr>
<tr class="separator:a791d570451c392e04774581a7d04707a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ac8f3e8366bd3a32709a1fb44e8524"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtlx_1_1BTree_1_1LeafNode.html">LeafNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#ab3ac8f3e8366bd3a32709a1fb44e8524">allocate_leaf</a> ()</td></tr>
<tr class="memdesc:ab3ac8f3e8366bd3a32709a1fb44e8524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize a leaf node.  <a href="#ab3ac8f3e8366bd3a32709a1fb44e8524">More...</a><br /></td></tr>
<tr class="separator:ab3ac8f3e8366bd3a32709a1fb44e8524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75eef3ff50d37f5b6c2eeea491cade1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#aa75eef3ff50d37f5b6c2eeea491cade1">allocate_inner</a> (unsigned short level)</td></tr>
<tr class="memdesc:aa75eef3ff50d37f5b6c2eeea491cade1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate and initialize an inner node.  <a href="#aa75eef3ff50d37f5b6c2eeea491cade1">More...</a><br /></td></tr>
<tr class="separator:aa75eef3ff50d37f5b6c2eeea491cade1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d054d5f2dfa6c0d777e2ceb7e4f89d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a12d054d5f2dfa6c0d777e2ceb7e4f89d">free_node</a> (<a class="el" href="structtlx_1_1BTree_1_1node.html">node</a> *n)</td></tr>
<tr class="separator:a12d054d5f2dfa6c0d777e2ceb7e4f89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">B+ Tree Node Binary Search Functions</div></td></tr>
<tr class="memitem:a703877855dd603b8d39c9cf8b446922e"><td class="memTemplParams" colspan="2">template&lt;typename node_type &gt; </td></tr>
<tr class="memitem:a703877855dd603b8d39c9cf8b446922e"><td class="memTemplItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a703877855dd603b8d39c9cf8b446922e">find_lower</a> (const node_type *n, const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;key) const</td></tr>
<tr class="separator:a703877855dd603b8d39c9cf8b446922e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861f6a7187f888061818dc01baccb3fe"><td class="memTemplParams" colspan="2">template&lt;typename node_type &gt; </td></tr>
<tr class="memitem:a861f6a7187f888061818dc01baccb3fe"><td class="memTemplItemLeft" align="right" valign="top">unsigned short&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a861f6a7187f888061818dc01baccb3fe">find_upper</a> (const node_type *n, const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;key) const</td></tr>
<tr class="separator:a861f6a7187f888061818dc01baccb3fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Private Insertion Functions</div></td></tr>
<tr class="memitem:af580a76629eafd1d907fa5e1e18556a2"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtlx_1_1BTree_1_1iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#af580a76629eafd1d907fa5e1e18556a2">insert_start</a> (const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;key, const <a class="el" href="classtlx_1_1BTree.html#a04f69f8f2936ff309627511179c1709b">value_type</a> &amp;value)</td></tr>
<tr class="separator:af580a76629eafd1d907fa5e1e18556a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3734f27e109c9117ded78c25d6d40624"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classtlx_1_1BTree_1_1iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a3734f27e109c9117ded78c25d6d40624">insert_descend</a> (<a class="el" href="structtlx_1_1BTree_1_1node.html">node</a> *n, const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;key, const <a class="el" href="classtlx_1_1BTree.html#a04f69f8f2936ff309627511179c1709b">value_type</a> &amp;value, <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> *splitkey, <a class="el" href="structtlx_1_1BTree_1_1node.html">node</a> **splitnode)</td></tr>
<tr class="memdesc:a3734f27e109c9117ded78c25d6d40624"><td class="mdescLeft">&#160;</td><td class="mdescRight">Insert an item into the B+ tree.  <a href="#a3734f27e109c9117ded78c25d6d40624">More...</a><br /></td></tr>
<tr class="separator:a3734f27e109c9117ded78c25d6d40624"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1234e2d209b518ae0396fb36b4be82d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a1234e2d209b518ae0396fb36b4be82d4">split_leaf_node</a> (<a class="el" href="structtlx_1_1BTree_1_1LeafNode.html">LeafNode</a> *leaf, <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> *out_newkey, <a class="el" href="structtlx_1_1BTree_1_1node.html">node</a> **out_newleaf)</td></tr>
<tr class="separator:a1234e2d209b518ae0396fb36b4be82d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6849b9290c28ea815a0c03b1d9321a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#afd6849b9290c28ea815a0c03b1d9321a">split_inner_node</a> (<a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a> *inner, <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> *out_newkey, <a class="el" href="structtlx_1_1BTree_1_1node.html">node</a> **out_newinner, unsigned int addslot)</td></tr>
<tr class="separator:afd6849b9290c28ea815a0c03b1d9321a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Tree Object Data Members</div></td></tr>
<tr class="memitem:aebc82407c13a86e9551f7984d2e3d356"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtlx_1_1BTree_1_1node.html">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#aebc82407c13a86e9551f7984d2e3d356">root_</a></td></tr>
<tr class="memdesc:aebc82407c13a86e9551f7984d2e3d356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to the B+ tree's root node, either leaf or inner node.  <a href="#aebc82407c13a86e9551f7984d2e3d356">More...</a><br /></td></tr>
<tr class="separator:aebc82407c13a86e9551f7984d2e3d356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d6ac34d80de837a5e6125c932f1c288"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtlx_1_1BTree_1_1LeafNode.html">LeafNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a8d6ac34d80de837a5e6125c932f1c288">head_leaf_</a></td></tr>
<tr class="memdesc:a8d6ac34d80de837a5e6125c932f1c288"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to first leaf in the double linked leaf chain.  <a href="#a8d6ac34d80de837a5e6125c932f1c288">More...</a><br /></td></tr>
<tr class="separator:a8d6ac34d80de837a5e6125c932f1c288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6747e195cffb9e4dbceef6a4848b3563"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtlx_1_1BTree_1_1LeafNode.html">LeafNode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a6747e195cffb9e4dbceef6a4848b3563">tail_leaf_</a></td></tr>
<tr class="memdesc:a6747e195cffb9e4dbceef6a4848b3563"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to last leaf in the double linked leaf chain.  <a href="#a6747e195cffb9e4dbceef6a4848b3563">More...</a><br /></td></tr>
<tr class="separator:a6747e195cffb9e4dbceef6a4848b3563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed457b19fc617a12201f09de1d885368"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtlx_1_1BTree_1_1tree__stats.html">tree_stats</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#aed457b19fc617a12201f09de1d885368">stats_</a></td></tr>
<tr class="memdesc:aed457b19fc617a12201f09de1d885368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Other small statistics about the B+ tree.  <a href="#aed457b19fc617a12201f09de1d885368">More...</a><br /></td></tr>
<tr class="separator:aed457b19fc617a12201f09de1d885368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d945dbdb41ca2fe76d87b2ba122e13e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1BTree.html#a6ff4e347839868db0770859a3dd55a27">key_compare</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a5d945dbdb41ca2fe76d87b2ba122e13e">key_less_</a></td></tr>
<tr class="separator:a5d945dbdb41ca2fe76d87b2ba122e13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8746da7b8170695c17d760f1a43bd4fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1BTree.html#aff35d256caa55f37343da8200179e608">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a8746da7b8170695c17d760f1a43bd4fe">allocator_</a></td></tr>
<tr class="memdesc:a8746da7b8170695c17d760f1a43bd4fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memory allocator.  <a href="#a8746da7b8170695c17d760f1a43bd4fe">More...</a><br /></td></tr>
<tr class="separator:a8746da7b8170695c17d760f1a43bd4fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Template Parameter Types</h2></td></tr>
<tr class="memitem:a38ec6d0825c22c2d0ad31f3209ed2d02"><td class="memItemLeft" align="right" valign="top">typedef Key&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a></td></tr>
<tr class="separator:a38ec6d0825c22c2d0ad31f3209ed2d02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f69f8f2936ff309627511179c1709b"><td class="memItemLeft" align="right" valign="top">typedef Value&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a04f69f8f2936ff309627511179c1709b">value_type</a></td></tr>
<tr class="separator:a04f69f8f2936ff309627511179c1709b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e576e049c90e014ffeb583c24d2f38"><td class="memItemLeft" align="right" valign="top">typedef KeyOfValue&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a21e576e049c90e014ffeb583c24d2f38">key_of_value</a></td></tr>
<tr class="memdesc:a21e576e049c90e014ffeb583c24d2f38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Third template: key extractor class to pull key_type from value_type.  <a href="#a21e576e049c90e014ffeb583c24d2f38">More...</a><br /></td></tr>
<tr class="separator:a21e576e049c90e014ffeb583c24d2f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ff4e347839868db0770859a3dd55a27"><td class="memItemLeft" align="right" valign="top">typedef Compare&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a6ff4e347839868db0770859a3dd55a27">key_compare</a></td></tr>
<tr class="memdesc:a6ff4e347839868db0770859a3dd55a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fourth template parameter: key_type comparison function object.  <a href="#a6ff4e347839868db0770859a3dd55a27">More...</a><br /></td></tr>
<tr class="separator:a6ff4e347839868db0770859a3dd55a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0d2e59411be6b53e63c29149a17fbcc"><td class="memItemLeft" align="right" valign="top">typedef Traits&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#ab0d2e59411be6b53e63c29149a17fbcc">traits</a></td></tr>
<tr class="separator:ab0d2e59411be6b53e63c29149a17fbcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff35d256caa55f37343da8200179e608"><td class="memItemLeft" align="right" valign="top">typedef Allocator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#aff35d256caa55f37343da8200179e608">allocator_type</a></td></tr>
<tr class="memdesc:aff35d256caa55f37343da8200179e608"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seventh template parameter: STL allocator for tree nodes.  <a href="#aff35d256caa55f37343da8200179e608">More...</a><br /></td></tr>
<tr class="separator:aff35d256caa55f37343da8200179e608"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a380c8745ff0a1c814742821e85403e"><td class="memItemLeft" align="right" valign="top">static const bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a4a380c8745ff0a1c814742821e85403e">allow_duplicates</a> = Duplicates</td></tr>
<tr class="separator:a4a380c8745ff0a1c814742821e85403e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Fast Destruction of the B+ Tree</h2></td></tr>
<tr class="memitem:ac8bb3912a3ce86b15842e79d0b421204"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#ac8bb3912a3ce86b15842e79d0b421204">clear</a> ()</td></tr>
<tr class="memdesc:ac8bb3912a3ce86b15842e79d0b421204"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees all key/data pairs and all nodes of the tree.  <a href="#ac8bb3912a3ce86b15842e79d0b421204">More...</a><br /></td></tr>
<tr class="separator:ac8bb3912a3ce86b15842e79d0b421204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049ea88e87d1254a65596324d47155ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a049ea88e87d1254a65596324d47155ed">clear_recursive</a> (<a class="el" href="structtlx_1_1BTree_1_1node.html">node</a> *n)</td></tr>
<tr class="memdesc:a049ea88e87d1254a65596324d47155ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively free up nodes.  <a href="#a049ea88e87d1254a65596324d47155ed">More...</a><br /></td></tr>
<tr class="separator:a049ea88e87d1254a65596324d47155ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Fast Copy: Assign Operator and Copy Constructors</h2></td></tr>
<tr class="memitem:a5d7edbc2e0e59ec25a21d0950c77a50c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classtlx_1_1BTree.html">BTree</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a5d7edbc2e0e59ec25a21d0950c77a50c">operator=</a> (const <a class="el" href="classtlx_1_1BTree.html">BTree</a> &amp;other)</td></tr>
<tr class="memdesc:a5d7edbc2e0e59ec25a21d0950c77a50c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator. All the key/data pairs are copied.  <a href="#a5d7edbc2e0e59ec25a21d0950c77a50c">More...</a><br /></td></tr>
<tr class="separator:a5d7edbc2e0e59ec25a21d0950c77a50c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b4c13faa3ff390aeb52760c88210d6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a62b4c13faa3ff390aeb52760c88210d6">BTree</a> (const <a class="el" href="classtlx_1_1BTree.html">BTree</a> &amp;other)</td></tr>
<tr class="separator:a62b4c13faa3ff390aeb52760c88210d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37a9d364cc587fa88fc7e498cbbbd8e9"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structtlx_1_1BTree_1_1node.html">node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a37a9d364cc587fa88fc7e498cbbbd8e9">copy_recursive</a> (const <a class="el" href="structtlx_1_1BTree_1_1node.html">node</a> *n)</td></tr>
<tr class="memdesc:a37a9d364cc587fa88fc7e498cbbbd8e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively copy nodes from another B+ tree object.  <a href="#a37a9d364cc587fa88fc7e498cbbbd8e9">More...</a><br /></td></tr>
<tr class="separator:a37a9d364cc587fa88fc7e498cbbbd8e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Private Erase Functions</h2></td></tr>
<tr class="memitem:aaa130f2c02b8f7701a6795c09d8988f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtlx_1_1BTree_1_1result__t.html">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#aaa130f2c02b8f7701a6795c09d8988f5">erase_one_descend</a> (const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;key, <a class="el" href="structtlx_1_1BTree_1_1node.html">node</a> *curr, <a class="el" href="structtlx_1_1BTree_1_1node.html">node</a> *left, <a class="el" href="structtlx_1_1BTree_1_1node.html">node</a> *right, <a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a> *left_parent, <a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a> *right_parent, <a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a> *parent, unsigned int parentslot)</td></tr>
<tr class="memdesc:aaa130f2c02b8f7701a6795c09d8988f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase one (the first) key/data pair in the B+ tree matching key.  <a href="#aaa130f2c02b8f7701a6795c09d8988f5">More...</a><br /></td></tr>
<tr class="separator:aaa130f2c02b8f7701a6795c09d8988f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59929a3ceec53dc1b7e288c245f7f4f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtlx_1_1BTree_1_1result__t.html">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a59929a3ceec53dc1b7e288c245f7f4f7">erase_iter_descend</a> (const <a class="el" href="classtlx_1_1BTree_1_1iterator.html">iterator</a> &amp;iter, <a class="el" href="structtlx_1_1BTree_1_1node.html">node</a> *curr, <a class="el" href="structtlx_1_1BTree_1_1node.html">node</a> *left, <a class="el" href="structtlx_1_1BTree_1_1node.html">node</a> *right, <a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a> *left_parent, <a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a> *right_parent, <a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a> *parent, unsigned int parentslot)</td></tr>
<tr class="memdesc:a59929a3ceec53dc1b7e288c245f7f4f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Erase one key/data pair referenced by an iterator in the B+ tree.  <a href="#a59929a3ceec53dc1b7e288c245f7f4f7">More...</a><br /></td></tr>
<tr class="separator:a59929a3ceec53dc1b7e288c245f7f4f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62fda6629d06db7d6fdcd3e81916932"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtlx_1_1BTree_1_1result__t.html">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#ae62fda6629d06db7d6fdcd3e81916932">merge_leaves</a> (<a class="el" href="structtlx_1_1BTree_1_1LeafNode.html">LeafNode</a> *left, <a class="el" href="structtlx_1_1BTree_1_1LeafNode.html">LeafNode</a> *right, <a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a> *parent)</td></tr>
<tr class="separator:ae62fda6629d06db7d6fdcd3e81916932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f41c2452c5416a662e8176af0a97b7"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structtlx_1_1BTree_1_1result__t.html">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a05f41c2452c5416a662e8176af0a97b7">merge_inner</a> (<a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a> *left, <a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a> *right, <a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a> *parent, unsigned int parentslot)</td></tr>
<tr class="separator:a05f41c2452c5416a662e8176af0a97b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae301448f117e44063d3b322be3534c13"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structtlx_1_1BTree_1_1result__t.html">result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#ae301448f117e44063d3b322be3534c13">shift_left_leaf</a> (<a class="el" href="structtlx_1_1BTree_1_1LeafNode.html">LeafNode</a> *left, <a class="el" href="structtlx_1_1BTree_1_1LeafNode.html">LeafNode</a> *right, <a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a> *parent, unsigned int parentslot)</td></tr>
<tr class="separator:ae301448f117e44063d3b322be3534c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c8a3da26251dfccff50c8bb174c3a4"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a22c8a3da26251dfccff50c8bb174c3a4">shift_left_inner</a> (<a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a> *left, <a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a> *right, <a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a> *parent, unsigned int parentslot)</td></tr>
<tr class="separator:a22c8a3da26251dfccff50c8bb174c3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8169e809b9e94043b7aa6c5d9847fb19"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a8169e809b9e94043b7aa6c5d9847fb19">shift_right_leaf</a> (<a class="el" href="structtlx_1_1BTree_1_1LeafNode.html">LeafNode</a> *left, <a class="el" href="structtlx_1_1BTree_1_1LeafNode.html">LeafNode</a> *right, <a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a> *parent, unsigned int parentslot)</td></tr>
<tr class="separator:a8169e809b9e94043b7aa6c5d9847fb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e25d4b9f9efb4a5496dcf849836fe16"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a3e25d4b9f9efb4a5496dcf849836fe16">shift_right_inner</a> (<a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a> *left, <a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a> *right, <a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a> *parent, unsigned int parentslot)</td></tr>
<tr class="separator:a3e25d4b9f9efb4a5496dcf849836fe16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Verification of B+ Tree Invariants</h2></td></tr>
<tr class="memitem:a8d93d1ede91beb3794a211e32fefa2b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a8d93d1ede91beb3794a211e32fefa2b6">verify</a> () const</td></tr>
<tr class="separator:a8d93d1ede91beb3794a211e32fefa2b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6062e764ae39bb06fa9183b47be948c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#ac6062e764ae39bb06fa9183b47be948c">verify_node</a> (const <a class="el" href="structtlx_1_1BTree_1_1node.html">node</a> *n, <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> *minkey, <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> *maxkey, <a class="el" href="structtlx_1_1BTree_1_1tree__stats.html">tree_stats</a> &amp;vstats) const</td></tr>
<tr class="memdesc:ac6062e764ae39bb06fa9183b47be948c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recursively descend down the tree and verify each node.  <a href="#ac6062e764ae39bb06fa9183b47be948c">More...</a><br /></td></tr>
<tr class="separator:ac6062e764ae39bb06fa9183b47be948c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0584c6460492e482a018e0f7e251b1d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classtlx_1_1BTree.html#a0584c6460492e482a018e0f7e251b1d5">verify_leaflinks</a> () const</td></tr>
<tr class="memdesc:a0584c6460492e482a018e0f7e251b1d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Verify the double linked list of leaves.  <a href="#a0584c6460492e482a018e0f7e251b1d5">More...</a><br /></td></tr>
<tr class="separator:a0584c6460492e482a018e0f7e251b1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="aff35d256caa55f37343da8200179e608"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff35d256caa55f37343da8200179e608">&#9670;&nbsp;</a></span>allocator_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Allocator <a class="el" href="classtlx_1_1BTree.html#aff35d256caa55f37343da8200179e608">allocator_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Seventh template parameter: STL allocator for tree nodes. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l00153">153</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a6ff4e347839868db0770859a3dd55a27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ff4e347839868db0770859a3dd55a27">&#9670;&nbsp;</a></span>key_compare</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Compare <a class="el" href="classtlx_1_1BTree.html#a6ff4e347839868db0770859a3dd55a27">key_compare</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fourth template parameter: key_type comparison function object. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l00142">142</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a21e576e049c90e014ffeb583c24d2f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21e576e049c90e014ffeb583c24d2f38">&#9670;&nbsp;</a></span>key_of_value</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef KeyOfValue <a class="el" href="classtlx_1_1BTree.html#a21e576e049c90e014ffeb583c24d2f38">key_of_value</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Third template: key extractor class to pull key_type from value_type. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l00139">139</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a38ec6d0825c22c2d0ad31f3209ed2d02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38ec6d0825c22c2d0ad31f3209ed2d02">&#9670;&nbsp;</a></span>key_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Key <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>First template parameter: The key type of the B+ tree. This is stored in inner nodes. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l00132">132</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a33b885434598e4d5ac5f06605e53b678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33b885434598e4d5ac5f06605e53b678">&#9670;&nbsp;</a></span>Self</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classtlx_1_1BTree.html">BTree</a>&lt;<a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a>, <a class="el" href="classtlx_1_1BTree.html#a04f69f8f2936ff309627511179c1709b">value_type</a>, <a class="el" href="classtlx_1_1BTree.html#a21e576e049c90e014ffeb583c24d2f38">key_of_value</a>, <a class="el" href="classtlx_1_1BTree.html#a6ff4e347839868db0770859a3dd55a27">key_compare</a>, <a class="el" href="classtlx_1_1BTree.html#ab0d2e59411be6b53e63c29149a17fbcc">traits</a>, <a class="el" href="classtlx_1_1BTree.html#a4a380c8745ff0a1c814742821e85403e">allow_duplicates</a>, <a class="el" href="classtlx_1_1BTree.html#aff35d256caa55f37343da8200179e608">allocator_type</a>&gt; <a class="el" href="classtlx_1_1BTree.html#a33b885434598e4d5ac5f06605e53b678">Self</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Typedef of our own type. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l00168">168</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a49b489a408a211a90e766329c0732d7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b489a408a211a90e766329c0732d7b">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t <a class="el" href="classtlx_1_1BTree.html#a49b489a408a211a90e766329c0732d7b">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Size type used to count keys. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l00171">171</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="ab0d2e59411be6b53e63c29149a17fbcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0d2e59411be6b53e63c29149a17fbcc">&#9670;&nbsp;</a></span>traits</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Traits <a class="el" href="classtlx_1_1BTree.html#ab0d2e59411be6b53e63c29149a17fbcc">traits</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fifth template parameter: Traits object used to define more parameters of the B+ tree </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l00146">146</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a04f69f8f2936ff309627511179c1709b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04f69f8f2936ff309627511179c1709b">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef Value <a class="el" href="classtlx_1_1BTree.html#a04f69f8f2936ff309627511179c1709b">value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Second template parameter: Composition pair of key and data types, or just the key for set containers. This data type is stored in the leaves. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l00136">136</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a3a617d72a0b84dcbdf111d1fe19ec0b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a617d72a0b84dcbdf111d1fe19ec0b5">&#9670;&nbsp;</a></span>result_flags_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classtlx_1_1BTree.html#a3a617d72a0b84dcbdf111d1fe19ec0b5">result_flags_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Result flags of recursive deletion. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3a617d72a0b84dcbdf111d1fe19ec0b5acc548bf14d595f9790f15c6514e626d8"></a>btree_ok&#160;</td><td class="fielddoc"><p>Deletion successful and no fix-ups necessary. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3a617d72a0b84dcbdf111d1fe19ec0b5a828fdc69a5b8ce344d849c52f4002434"></a>btree_not_found&#160;</td><td class="fielddoc"><p>Deletion not successful because key was not found. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3a617d72a0b84dcbdf111d1fe19ec0b5a99aacb09662e9c66cdef8fc5a605ec75"></a>btree_update_lastkey&#160;</td><td class="fielddoc"><p>Deletion successful, the last key was updated so parent slotkeys need updates. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3a617d72a0b84dcbdf111d1fe19ec0b5a1253a0a76ac7b4ca061433c10f7f832a"></a>btree_fixmerge&#160;</td><td class="fielddoc"><p>Deletion successful, children nodes were merged and the parent needs to remove the empty node. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l02307">2307</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6f73c3bb670ec75c0b6910927cf6606b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f73c3bb670ec75c0b6910927cf6606b">&#9670;&nbsp;</a></span>BTree() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1BTree.html">BTree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html#aff35d256caa55f37343da8200179e608">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="classtlx_1_1BTree.html#aff35d256caa55f37343da8200179e608">allocator_type</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default constructor initializing an empty B+ tree with the standard key comparison function. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01103">1103</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a8f96f907c281e0c29c4f5129b6cf3169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f96f907c281e0c29c4f5129b6cf3169">&#9670;&nbsp;</a></span>BTree() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1BTree.html">BTree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html#a6ff4e347839868db0770859a3dd55a27">key_compare</a> &amp;&#160;</td>
          <td class="paramname"><em>kcf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html#aff35d256caa55f37343da8200179e608">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="classtlx_1_1BTree.html#aff35d256caa55f37343da8200179e608">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor initializing an empty B+ tree with a special key comparison object. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01110">1110</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a6cbb054ada3a2e9ebe4f822f0799b10b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cbb054ada3a2e9ebe4f822f0799b10b">&#9670;&nbsp;</a></span>BTree() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1BTree.html">BTree</a> </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html#aff35d256caa55f37343da8200179e608">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="classtlx_1_1BTree.html#aff35d256caa55f37343da8200179e608">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor initializing a B+ tree with the range [first,last). The range need not be sorted. To create a B+ tree from a sorted range, use <a class="el" href="classtlx_1_1BTree.html#a3d0a35a00bc2ff5608fe613ea8fa47e6">bulk_load()</a>. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01120">1120</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="ad9c4fcb14953cafb848894fccab09ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c4fcb14953cafb848894fccab09ebe">&#9670;&nbsp;</a></span>BTree() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1BTree.html">BTree</a> </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html#a6ff4e347839868db0770859a3dd55a27">key_compare</a> &amp;&#160;</td>
          <td class="paramname"><em>kcf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html#aff35d256caa55f37343da8200179e608">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"><em>alloc</em> = <code><a class="el" href="classtlx_1_1BTree.html#aff35d256caa55f37343da8200179e608">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor initializing a B+ tree with the range [first,last) and a special key comparison object. The range need not be sorted. To create a B+ tree from a sorted range, use <a class="el" href="classtlx_1_1BTree.html#a3d0a35a00bc2ff5608fe613ea8fa47e6">bulk_load()</a>. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01131">1131</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="af50bbeb39af1051f057b65da1c71a671"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af50bbeb39af1051f057b65da1c71a671">&#9670;&nbsp;</a></span>~BTree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="classtlx_1_1BTree.html">BTree</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees up all used B+ tree memory pages. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01139">1139</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a62b4c13faa3ff390aeb52760c88210d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b4c13faa3ff390aeb52760c88210d6">&#9670;&nbsp;</a></span>BTree() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1BTree.html">BTree</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html">BTree</a>&lt; Key, Value, KeyOfValue, Compare, Traits, Duplicates, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor. The newly initialized B+ tree object will contain a copy of all key/data pairs. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01779">1779</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa75eef3ff50d37f5b6c2eeea491cade1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa75eef3ff50d37f5b6c2eeea491cade1">&#9670;&nbsp;</a></span>allocate_inner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a>* allocate_inner </td>
          <td>(</td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate and initialize an inner node. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01261">1261</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="ab3ac8f3e8366bd3a32709a1fb44e8524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3ac8f3e8366bd3a32709a1fb44e8524">&#9670;&nbsp;</a></span>allocate_leaf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtlx_1_1BTree_1_1LeafNode.html">LeafNode</a>* allocate_leaf </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocate and initialize a leaf node. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01253">1253</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="ad69bd11391be1a1dba5c8202259664f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad69bd11391be1a1dba5c8202259664f8">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1BTree_1_1iterator.html">iterator</a> begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a read/data-write iterator that points to the first slot in the first leaf of the B+ tree. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01341">1341</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="btree__set_8hpp_source.html#l00253">btree_set&lt; Key_, Compare_, Traits_, Alloc_ &gt;::begin()</a>, <a class="el" href="btree__multiset_8hpp_source.html#l00254">btree_multiset&lt; Key_, Compare_, Traits_, Alloc_ &gt;::begin()</a>, <a class="el" href="btree__map_8hpp_source.html#l00255">btree_map&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::begin()</a>, <a class="el" href="btree__multimap_8hpp_source.html#l00256">btree_multimap&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::begin()</a>, <a class="el" href="btree_8hpp_source.html#l01728">BTree&lt; key_type, value_type, key_of_value, key_compare, traits, true, allocator_type &gt;::operator&lt;()</a>, and <a class="el" href="btree_8hpp_source.html#l01716">BTree&lt; key_type, value_type, key_of_value, key_compare, traits, true, allocator_type &gt;::operator==()</a>.</p>

</div>
</div>
<a id="a29305669b60ca1680752e2fc3592ba99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29305669b60ca1680752e2fc3592ba99">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1BTree_1_1const__iterator.html">const_iterator</a> begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a read-only constant iterator that points to the first slot in the first leaf of the B+ tree. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01353">1353</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a3d0a35a00bc2ff5608fe613ea8fa47e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d0a35a00bc2ff5608fe613ea8fa47e6">&#9670;&nbsp;</a></span>bulk_load()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void bulk_load </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>ibegin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>iend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Bulk load a sorted range. Loads items into leaves and constructs a B-tree above them. The tree must be empty when calling this function. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l02155">2155</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="btree__set_8hpp_source.html#l00482">btree_set&lt; Key_, Compare_, Traits_, Alloc_ &gt;::bulk_load()</a>, <a class="el" href="btree__multiset_8hpp_source.html#l00483">btree_multiset&lt; Key_, Compare_, Traits_, Alloc_ &gt;::bulk_load()</a>, <a class="el" href="btree__multimap_8hpp_source.html#l00495">btree_multimap&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::bulk_load()</a>, and <a class="el" href="btree__map_8hpp_source.html#l00502">btree_map&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::bulk_load()</a>.</p>

</div>
</div>
<a id="ac8bb3912a3ce86b15842e79d0b421204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8bb3912a3ce86b15842e79d0b421204">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees all key/data pairs and all nodes of the tree. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01294">1294</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="btree__set_8hpp_source.html#l00241">btree_set&lt; Key_, Compare_, Traits_, Alloc_ &gt;::clear()</a>, <a class="el" href="btree__multiset_8hpp_source.html#l00242">btree_multiset&lt; Key_, Compare_, Traits_, Alloc_ &gt;::clear()</a>, <a class="el" href="btree__map_8hpp_source.html#l00243">btree_map&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::clear()</a>, and <a class="el" href="btree__multimap_8hpp_source.html#l00244">btree_multimap&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::clear()</a>.</p>

</div>
</div>
<a id="a049ea88e87d1254a65596324d47155ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a049ea88e87d1254a65596324d47155ed">&#9670;&nbsp;</a></span>clear_recursive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void clear_recursive </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtlx_1_1BTree_1_1node.html">node</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively free up nodes. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01311">1311</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a37a9d364cc587fa88fc7e498cbbbd8e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37a9d364cc587fa88fc7e498cbbbd8e9">&#9670;&nbsp;</a></span>copy_recursive()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structtlx_1_1BTree_1_1node.html">node</a>* copy_recursive </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtlx_1_1BTree_1_1node.html">node</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively copy nodes from another B+ tree object. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01796">1796</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a644672ba9cde511335e48e231ddbea74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a644672ba9cde511335e48e231ddbea74">&#9670;&nbsp;</a></span>count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1BTree.html#a49b489a408a211a90e766329c0732d7b">size_type</a> count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to locate a key in the B+ tree and returns the number of identical key entries found. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01584">1584</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="btree__multiset_8hpp_source.html#l00353">btree_multiset&lt; Key_, Compare_, Traits_, Alloc_ &gt;::count()</a>, <a class="el" href="btree__set_8hpp_source.html#l00353">btree_set&lt; Key_, Compare_, Traits_, Alloc_ &gt;::count()</a>, <a class="el" href="btree__map_8hpp_source.html#l00355">btree_map&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::count()</a>, and <a class="el" href="btree__multimap_8hpp_source.html#l00355">btree_multimap&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::count()</a>.</p>

</div>
</div>
<a id="a644718bb2fb240de962dc3c9a1fdf0dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a644718bb2fb240de962dc3c9a1fdf0dc">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if there is at least one key/data pair in the B+ tree. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01499">1499</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="btree__set_8hpp_source.html#l00311">btree_set&lt; Key_, Compare_, Traits_, Alloc_ &gt;::empty()</a>, <a class="el" href="btree__multiset_8hpp_source.html#l00312">btree_multiset&lt; Key_, Compare_, Traits_, Alloc_ &gt;::empty()</a>, <a class="el" href="btree__map_8hpp_source.html#l00313">btree_map&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::empty()</a>, and <a class="el" href="btree__multimap_8hpp_source.html#l00314">btree_multimap&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::empty()</a>.</p>

</div>
</div>
<a id="acad38d52497a975bfb6f2f6acd76631f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad38d52497a975bfb6f2f6acd76631f">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1BTree_1_1iterator.html">iterator</a> end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a read/data-write iterator that points to the first invalid slot in the last leaf of the B+ tree. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01347">1347</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="btree__set_8hpp_source.html#l00259">btree_set&lt; Key_, Compare_, Traits_, Alloc_ &gt;::end()</a>, <a class="el" href="btree__multiset_8hpp_source.html#l00260">btree_multiset&lt; Key_, Compare_, Traits_, Alloc_ &gt;::end()</a>, <a class="el" href="btree__map_8hpp_source.html#l00261">btree_map&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::end()</a>, <a class="el" href="btree__multimap_8hpp_source.html#l00262">btree_multimap&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::end()</a>, and <a class="el" href="btree_8hpp_source.html#l01728">BTree&lt; key_type, value_type, key_of_value, key_compare, traits, true, allocator_type &gt;::operator&lt;()</a>.</p>

</div>
</div>
<a id="accf9a4bd0c34d4a5f6a7dab66ea10cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf9a4bd0c34d4a5f6a7dab66ea10cdc">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1BTree_1_1const__iterator.html">const_iterator</a> end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a read-only constant iterator that points to the first invalid slot in the last leaf of the B+ tree. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01359">1359</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a97bb054bc81e97ec55f0b539cdcbfcde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97bb054bc81e97ec55f0b539cdcbfcde">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtlx_1_1BTree_1_1iterator.html">iterator</a>, <a class="el" href="classtlx_1_1BTree_1_1iterator.html">iterator</a>&gt; equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches the B+ tree and returns both <a class="el" href="classtlx_1_1BTree.html#a373c61cca9b31735f4548b5b59b70184">lower_bound()</a> and <a class="el" href="classtlx_1_1BTree.html#a482b50e623a123f653e2a91f113a507b">upper_bound()</a>. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01695">1695</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="btree__multiset_8hpp_source.html#l00382">btree_multiset&lt; Key_, Compare_, Traits_, Alloc_ &gt;::equal_range()</a>, <a class="el" href="btree__set_8hpp_source.html#l00382">btree_set&lt; Key_, Compare_, Traits_, Alloc_ &gt;::equal_range()</a>, <a class="el" href="btree__map_8hpp_source.html#l00384">btree_map&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::equal_range()</a>, and <a class="el" href="btree__multimap_8hpp_source.html#l00384">btree_multimap&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::equal_range()</a>.</p>

</div>
</div>
<a id="af9b8748584487d921a4bdf3b9ac06be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b8748584487d921a4bdf3b9ac06be2">&#9670;&nbsp;</a></span>equal_range() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtlx_1_1BTree_1_1const__iterator.html">const_iterator</a>, <a class="el" href="classtlx_1_1BTree_1_1const__iterator.html">const_iterator</a>&gt; equal_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Searches the B+ tree and returns both <a class="el" href="classtlx_1_1BTree.html#a373c61cca9b31735f4548b5b59b70184">lower_bound()</a> and <a class="el" href="classtlx_1_1BTree.html#a482b50e623a123f653e2a91f113a507b">upper_bound()</a>. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01702">1702</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="ae57ff6dd1cb4dc347b892dfa87ea6613"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae57ff6dd1cb4dc347b892dfa87ea6613">&#9670;&nbsp;</a></span>erase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1BTree.html#a49b489a408a211a90e766329c0732d7b">size_type</a> erase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Erases all the key/data pairs associated with the given key. This is implemented using <a class="el" href="classtlx_1_1BTree.html#a3a79f5c030eea924dbd8fcc9417b9263">erase_one()</a>. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l02392">2392</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="btree__set_8hpp_source.html#l00499">btree_set&lt; Key_, Compare_, Traits_, Alloc_ &gt;::erase()</a>, <a class="el" href="btree__multiset_8hpp_source.html#l00500">btree_multiset&lt; Key_, Compare_, Traits_, Alloc_ &gt;::erase()</a>, <a class="el" href="btree__multimap_8hpp_source.html#l00513">btree_multimap&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::erase()</a>, and <a class="el" href="btree__map_8hpp_source.html#l00520">btree_map&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::erase()</a>.</p>

</div>
</div>
<a id="af8b2d25c3e313e0b24656afe5cd4f6f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8b2d25c3e313e0b24656afe5cd4f6f2">&#9670;&nbsp;</a></span>erase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtlx_1_1BTree_1_1iterator.html">iterator</a>&#160;</td>
          <td class="paramname"><em>iter</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase the key/data pair referenced by the iterator. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l02405">2405</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a59929a3ceec53dc1b7e288c245f7f4f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59929a3ceec53dc1b7e288c245f7f4f7">&#9670;&nbsp;</a></span>erase_iter_descend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtlx_1_1BTree_1_1result__t.html">result_t</a> erase_iter_descend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree_1_1iterator.html">iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>iter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtlx_1_1BTree_1_1node.html">node</a> *&#160;</td>
          <td class="paramname"><em>curr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtlx_1_1BTree_1_1node.html">node</a> *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtlx_1_1BTree_1_1node.html">node</a> *&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a> *&#160;</td>
          <td class="paramname"><em>left_parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a> *&#160;</td>
          <td class="paramname"><em>right_parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>parentslot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase one key/data pair referenced by an iterator in the B+ tree. </p>
<p>Descends down the tree in search of an iterator. During the descent the parent, left and right siblings and their parents are computed and passed down. The difficulty is that the iterator contains only a pointer to a <a class="el" href="structtlx_1_1BTree_1_1LeafNode.html">LeafNode</a>, which means that this function must do a recursive depth first search for that leaf node in the subtree containing all pairs of the same key. This subtree can be very large, even the whole tree, though in practice it would not make sense to have so many duplicate keys.</p>
<p>Once the referenced key/data pair is found, it is removed from the leaf and the same underflow cases are handled as in erase_one_descend. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l02779">2779</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a3a79f5c030eea924dbd8fcc9417b9263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a79f5c030eea924dbd8fcc9417b9263">&#9670;&nbsp;</a></span>erase_one()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool erase_one </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Erases one (the first) of the key/data pairs associated with the given key. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l02368">2368</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="btree__multiset_8hpp_source.html#l00494">btree_multiset&lt; Key_, Compare_, Traits_, Alloc_ &gt;::erase_one()</a>, <a class="el" href="btree__set_8hpp_source.html#l00494">btree_set&lt; Key_, Compare_, Traits_, Alloc_ &gt;::erase_one()</a>, <a class="el" href="btree__multimap_8hpp_source.html#l00507">btree_multimap&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::erase_one()</a>, and <a class="el" href="btree__map_8hpp_source.html#l00514">btree_map&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::erase_one()</a>.</p>

</div>
</div>
<a id="aaa130f2c02b8f7701a6795c09d8988f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa130f2c02b8f7701a6795c09d8988f5">&#9670;&nbsp;</a></span>erase_one_descend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtlx_1_1BTree_1_1result__t.html">result_t</a> erase_one_descend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtlx_1_1BTree_1_1node.html">node</a> *&#160;</td>
          <td class="paramname"><em>curr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtlx_1_1BTree_1_1node.html">node</a> *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtlx_1_1BTree_1_1node.html">node</a> *&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a> *&#160;</td>
          <td class="paramname"><em>left_parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a> *&#160;</td>
          <td class="paramname"><em>right_parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>parentslot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Erase one (the first) key/data pair in the B+ tree matching key. </p>
<p>Descends down the tree in search of key. During the descent the parent, left and right siblings and their parents are computed and passed down. Once the key/data pair is found, it is removed from the leaf. If the leaf underflows 6 different cases are handled. These cases resolve the underflow by shifting key/data pairs from adjacent sibling nodes, merging two sibling nodes or trimming the tree. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l02449">2449</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="ab753b07ce19a1e35c9b3d56e73a879f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab753b07ce19a1e35c9b3d56e73a879f0">&#9670;&nbsp;</a></span>exists()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool exists </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Non-STL function checking whether a key is in the B+ tree. The same as (find(k) != <a class="el" href="classtlx_1_1BTree.html#acad38d52497a975bfb6f2f6acd76631f">end()</a>) or (<a class="el" href="classtlx_1_1BTree.html#a644672ba9cde511335e48e231ddbea74">count()</a> != 0). </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01522">1522</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="btree__set_8hpp_source.html#l00334">btree_set&lt; Key_, Compare_, Traits_, Alloc_ &gt;::exists()</a>, <a class="el" href="btree__multiset_8hpp_source.html#l00335">btree_multiset&lt; Key_, Compare_, Traits_, Alloc_ &gt;::exists()</a>, <a class="el" href="btree__map_8hpp_source.html#l00336">btree_map&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::exists()</a>, and <a class="el" href="btree__multimap_8hpp_source.html#l00337">btree_multimap&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::exists()</a>.</p>

</div>
</div>
<a id="a9c9766a96c492f3e9e5861d6b4f87387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c9766a96c492f3e9e5861d6b4f87387">&#9670;&nbsp;</a></span>find() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1BTree_1_1iterator.html">iterator</a> find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to locate a key in the B+ tree and returns an iterator to the key/data slot if found. If unsuccessful it returns <a class="el" href="classtlx_1_1BTree.html#acad38d52497a975bfb6f2f6acd76631f">end()</a>. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01542">1542</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="btree__set_8hpp_source.html#l00340">btree_set&lt; Key_, Compare_, Traits_, Alloc_ &gt;::find()</a>, <a class="el" href="btree__multiset_8hpp_source.html#l00341">btree_multiset&lt; Key_, Compare_, Traits_, Alloc_ &gt;::find()</a>, <a class="el" href="btree__map_8hpp_source.html#l00342">btree_map&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::find()</a>, and <a class="el" href="btree__multimap_8hpp_source.html#l00343">btree_multimap&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::find()</a>.</p>

</div>
</div>
<a id="af2a080484f0b756af6f218c0e6bae306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2a080484f0b756af6f218c0e6bae306">&#9670;&nbsp;</a></span>find() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1BTree_1_1const__iterator.html">const_iterator</a> find </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tries to locate a key in the B+ tree and returns an constant iterator to the key/data slot if found. If unsuccessful it returns <a class="el" href="classtlx_1_1BTree.html#acad38d52497a975bfb6f2f6acd76631f">end()</a>. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01563">1563</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a703877855dd603b8d39c9cf8b446922e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a703877855dd603b8d39c9cf8b446922e">&#9670;&nbsp;</a></span>find_lower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short find_lower </td>
          <td>(</td>
          <td class="paramtype">const node_type *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Searches for the first key in the node n greater or equal to key. Uses binary search with an optional linear self-verification. This is a template function, because the slotkey array is located at different places in <a class="el" href="structtlx_1_1BTree_1_1LeafNode.html">LeafNode</a> and <a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a>. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01398">1398</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a861f6a7187f888061818dc01baccb3fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861f6a7187f888061818dc01baccb3fe">&#9670;&nbsp;</a></span>find_upper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned short find_upper </td>
          <td>(</td>
          <td class="paramtype">const node_type *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Searches for the first key in the node n greater than key. Uses binary search with an optional linear self-verification. This is a template function, because the slotkey array is located at different places in <a class="el" href="structtlx_1_1BTree_1_1LeafNode.html">LeafNode</a> and <a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a>. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01445">1445</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a12d054d5f2dfa6c0d777e2ceb7e4f89d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12d054d5f2dfa6c0d777e2ceb7e4f89d">&#9670;&nbsp;</a></span>free_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void free_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtlx_1_1BTree_1_1node.html">node</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Correctly free either inner or leaf node, destructs all contained key and value objects. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01270">1270</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a6e99c6263568d88f95ca01dc694f1051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e99c6263568d88f95ca01dc694f1051">&#9670;&nbsp;</a></span>get_allocator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1BTree.html#aff35d256caa55f37343da8200179e608">allocator_type</a> get_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the base node allocator provided during construction. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01232">1232</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="btree__set_8hpp_source.html#l00230">btree_set&lt; Key_, Compare_, Traits_, Alloc_ &gt;::get_allocator()</a>, <a class="el" href="btree__multiset_8hpp_source.html#l00231">btree_multiset&lt; Key_, Compare_, Traits_, Alloc_ &gt;::get_allocator()</a>, <a class="el" href="btree__map_8hpp_source.html#l00232">btree_map&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::get_allocator()</a>, <a class="el" href="btree__multimap_8hpp_source.html#l00233">btree_multimap&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::get_allocator()</a>, and <a class="el" href="btree_8hpp_source.html#l01755">BTree&lt; key_type, value_type, key_of_value, key_compare, traits, true, allocator_type &gt;::operator=()</a>.</p>

</div>
</div>
<a id="a1a41faf8b8ec2c138a53d4c1b1a1873c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a41faf8b8ec2c138a53d4c1b1a1873c">&#9670;&nbsp;</a></span>get_stats()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const struct <a class="el" href="structtlx_1_1BTree_1_1tree__stats.html">tree_stats</a>&amp; get_stats </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a const reference to the current statistics. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01510">1510</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="btree__set_8hpp_source.html#l00322">btree_set&lt; Key_, Compare_, Traits_, Alloc_ &gt;::get_stats()</a>, <a class="el" href="btree__multiset_8hpp_source.html#l00323">btree_multiset&lt; Key_, Compare_, Traits_, Alloc_ &gt;::get_stats()</a>, <a class="el" href="btree__map_8hpp_source.html#l00324">btree_map&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::get_stats()</a>, and <a class="el" href="btree__multimap_8hpp_source.html#l00325">btree_multimap&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::get_stats()</a>.</p>

</div>
</div>
<a id="a791d570451c392e04774581a7d04707a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a791d570451c392e04774581a7d04707a">&#9670;&nbsp;</a></span>inner_node_allocator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtlx_1_1BTree_1_1InnerNode.html#a420a071517903c1cfc59a6846534982d">InnerNode::alloc_type</a> inner_node_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an allocator for <a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a> objects. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01248">1248</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="aa218c2c89397f8d0484ef9438d540456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa218c2c89397f8d0484ef9438d540456">&#9670;&nbsp;</a></span>insert() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtlx_1_1BTree_1_1iterator.html">iterator</a>, bool&gt; insert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html#a04f69f8f2936ff309627511179c1709b">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempt to insert a key/data pair into the B+ tree. If the tree does not allow duplicate keys, then the insert may fail if it is already present. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01846">1846</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="btree__set_8hpp_source.html#l00456">btree_set&lt; Key_, Compare_, Traits_, Alloc_ &gt;::insert()</a>, <a class="el" href="btree__multiset_8hpp_source.html#l00457">btree_multiset&lt; Key_, Compare_, Traits_, Alloc_ &gt;::insert()</a>, <a class="el" href="btree__map_8hpp_source.html#l00459">btree_map&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::insert()</a>, <a class="el" href="btree__multimap_8hpp_source.html#l00460">btree_multimap&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::insert()</a>, <a class="el" href="btree__map_8hpp_source.html#l00465">btree_map&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::insert2()</a>, and <a class="el" href="btree__multimap_8hpp_source.html#l00467">btree_multimap&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::insert2()</a>.</p>

</div>
</div>
<a id="a3ff25301e2f68b6862c2ea4a36dab058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ff25301e2f68b6862c2ea4a36dab058">&#9670;&nbsp;</a></span>insert() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1BTree_1_1iterator.html">iterator</a> insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtlx_1_1BTree_1_1iterator.html">iterator</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html#a04f69f8f2936ff309627511179c1709b">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempt to insert a key/data pair into the B+ tree. The iterator hint is currently ignored by the B+ tree insertion routine. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01852">1852</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="ac048f549259de32da2acd742cce52d5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac048f549259de32da2acd742cce52d5c">&#9670;&nbsp;</a></span>insert() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void insert </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Attempt to insert the range [first,last) of value_type pairs into the B+ tree. Each key/data pair is inserted individually; to bulk load the tree, use a constructor with range. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01860">1860</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a3734f27e109c9117ded78c25d6d40624"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3734f27e109c9117ded78c25d6d40624">&#9670;&nbsp;</a></span>insert_descend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtlx_1_1BTree_1_1iterator.html">iterator</a>, bool&gt; insert_descend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtlx_1_1BTree_1_1node.html">node</a> *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html#a04f69f8f2936ff309627511179c1709b">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> *&#160;</td>
          <td class="paramname"><em>splitkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtlx_1_1BTree_1_1node.html">node</a> **&#160;</td>
          <td class="paramname"><em>splitnode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Insert an item into the B+ tree. </p>
<p>Descend down the nodes to a leaf, insert the key/data pair in a free slot. If the node overflows, then it must be split and the new split node inserted into the parent. Unroll / this splitting up to the root. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01928">1928</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="af580a76629eafd1d907fa5e1e18556a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af580a76629eafd1d907fa5e1e18556a2">&#9670;&nbsp;</a></span>insert_start()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classtlx_1_1BTree_1_1iterator.html">iterator</a>, bool&gt; insert_start </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html#a04f69f8f2936ff309627511179c1709b">value_type</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start the insertion descent at the current root and handle root splits. Returns true if the item was inserted </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01878">1878</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="ae9e650d8249954362ec4225dfb73e9fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e650d8249954362ec4225dfb73e9fe">&#9670;&nbsp;</a></span>key_comp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1BTree.html#a6ff4e347839868db0770859a3dd55a27">key_compare</a> key_comp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constant access to the key comparison object sorting the B+ tree. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01183">1183</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="btree__set_8hpp_source.html#l00213">btree_set&lt; Key_, Compare_, Traits_, Alloc_ &gt;::key_comp()</a>, <a class="el" href="btree__multiset_8hpp_source.html#l00214">btree_multiset&lt; Key_, Compare_, Traits_, Alloc_ &gt;::key_comp()</a>, <a class="el" href="btree__map_8hpp_source.html#l00215">btree_map&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::key_comp()</a>, <a class="el" href="btree__multimap_8hpp_source.html#l00216">btree_multimap&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::key_comp()</a>, and <a class="el" href="btree_8hpp_source.html#l01755">BTree&lt; key_type, value_type, key_of_value, key_compare, traits, true, allocator_type &gt;::operator=()</a>.</p>

</div>
</div>
<a id="abfb47ece6195973d5cbcf73470f47b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfb47ece6195973d5cbcf73470f47b06">&#9670;&nbsp;</a></span>key_equal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool key_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>True if a == b ? constructed from <a class="el" href="classtlx_1_1BTree.html#a20b973c16347c015746fa9ee5884d60a" title="True if a &lt; b ? &quot;constructed&quot; from key_less_() ">key_less()</a>. This requires the &lt; relation to be a total order, otherwise the B+ tree cannot be sorted. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01221">1221</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a889913329d2cfe5e2d6f794162843d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a889913329d2cfe5e2d6f794162843d15">&#9670;&nbsp;</a></span>key_greater()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool key_greater </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if a &gt; b ? constructed from <a class="el" href="classtlx_1_1BTree.html#a20b973c16347c015746fa9ee5884d60a" title="True if a &lt; b ? &quot;constructed&quot; from key_less_() ">key_less()</a> </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01210">1210</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a69071aa249ceb086b673520deaa927b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69071aa249ceb086b673520deaa927b0">&#9670;&nbsp;</a></span>key_greaterequal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool key_greaterequal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if a &gt;= b ? constructed from <a class="el" href="classtlx_1_1BTree.html#a20b973c16347c015746fa9ee5884d60a" title="True if a &lt; b ? &quot;constructed&quot; from key_less_() ">key_less()</a> </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01215">1215</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a20b973c16347c015746fa9ee5884d60a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b973c16347c015746fa9ee5884d60a">&#9670;&nbsp;</a></span>key_less()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool key_less </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if a &lt; b ? "constructed" from <a class="el" href="classtlx_1_1BTree.html#a5d945dbdb41ca2fe76d87b2ba122e13e">key_less_()</a> </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01200">1200</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="ae60d771db1962102667ae44cd3396a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae60d771db1962102667ae44cd3396a17">&#9670;&nbsp;</a></span>key_lessequal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool key_lessequal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True if a &lt;= b ? constructed from <a class="el" href="classtlx_1_1BTree.html#a20b973c16347c015746fa9ee5884d60a" title="True if a &lt; b ? &quot;constructed&quot; from key_less_() ">key_less()</a> </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01205">1205</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a353e5a73d56e289c9b48a5bc43e72211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a353e5a73d56e289c9b48a5bc43e72211">&#9670;&nbsp;</a></span>leaf_node_allocator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtlx_1_1BTree_1_1LeafNode.html#a022e856be0486dadd1a67f21a65562f4">LeafNode::alloc_type</a> leaf_node_allocator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return an allocator for <a class="el" href="structtlx_1_1BTree_1_1LeafNode.html">LeafNode</a> objects. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01243">1243</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a373c61cca9b31735f4548b5b59b70184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a373c61cca9b31735f4548b5b59b70184">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1BTree_1_1iterator.html">iterator</a> lower_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Searches the B+ tree and returns an iterator to the first pair equal to or greater than key, or <a class="el" href="classtlx_1_1BTree.html#acad38d52497a975bfb6f2f6acd76631f">end()</a> if all keys are smaller. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01616">1616</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="btree__multiset_8hpp_source.html#l00359">btree_multiset&lt; Key_, Compare_, Traits_, Alloc_ &gt;::lower_bound()</a>, <a class="el" href="btree__set_8hpp_source.html#l00359">btree_set&lt; Key_, Compare_, Traits_, Alloc_ &gt;::lower_bound()</a>, <a class="el" href="btree__map_8hpp_source.html#l00361">btree_map&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::lower_bound()</a>, and <a class="el" href="btree__multimap_8hpp_source.html#l00361">btree_multimap&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::lower_bound()</a>.</p>

</div>
</div>
<a id="a47e4f1a835d27ae60002cc709750b221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47e4f1a835d27ae60002cc709750b221">&#9670;&nbsp;</a></span>lower_bound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1BTree_1_1const__iterator.html">const_iterator</a> lower_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Searches the B+ tree and returns a constant iterator to the first pair equal to or greater than key, or <a class="el" href="classtlx_1_1BTree.html#acad38d52497a975bfb6f2f6acd76631f">end()</a> if all keys are smaller. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01636">1636</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a95205eb0260cd9ed6efac29f93508193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95205eb0260cd9ed6efac29f93508193">&#9670;&nbsp;</a></span>max_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1BTree.html#a49b489a408a211a90e766329c0732d7b">size_type</a> max_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the largest possible size of the B+ Tree. This is just a function required by the STL standard, the B+ Tree can hold more items. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01505">1505</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="btree__set_8hpp_source.html#l00317">btree_set&lt; Key_, Compare_, Traits_, Alloc_ &gt;::max_size()</a>, <a class="el" href="btree__multiset_8hpp_source.html#l00318">btree_multiset&lt; Key_, Compare_, Traits_, Alloc_ &gt;::max_size()</a>, <a class="el" href="btree__map_8hpp_source.html#l00319">btree_map&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::max_size()</a>, and <a class="el" href="btree__multimap_8hpp_source.html#l00320">btree_multimap&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::max_size()</a>.</p>

</div>
</div>
<a id="a05f41c2452c5416a662e8176af0a97b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05f41c2452c5416a662e8176af0a97b7">&#9670;&nbsp;</a></span>merge_inner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structtlx_1_1BTree_1_1result__t.html">result_t</a> merge_inner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a> *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a> *&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>parentslot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Merge two inner nodes. The function moves all key/childid pairs from right to left and sets right's slotuse to zero. The right slot is then removed by the calling parent node. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l03169">3169</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="ae62fda6629d06db7d6fdcd3e81916932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae62fda6629d06db7d6fdcd3e81916932">&#9670;&nbsp;</a></span>merge_leaves()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtlx_1_1BTree_1_1result__t.html">result_t</a> merge_leaves </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtlx_1_1BTree_1_1LeafNode.html">LeafNode</a> *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtlx_1_1BTree_1_1LeafNode.html">LeafNode</a> *&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Merge two leaf nodes. The function moves all key/data pairs from right to left and sets right's slotuse to zero. The right slot is then removed by the calling parent node. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l03139">3139</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a953af036ec17e9b0953cfcfd23315352"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a953af036ec17e9b0953cfcfd23315352">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html">BTree</a>&lt; Key, Value, KeyOfValue, Compare, Traits, Duplicates, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Inequality relation. Based on operator==. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01722">1722</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="af7da23d4be7770d1c3d32b3b1426e857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7da23d4be7770d1c3d32b3b1426e857">&#9670;&nbsp;</a></span>operator<()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html">BTree</a>&lt; Key, Value, KeyOfValue, Compare, Traits, Duplicates, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Total ordering relation of B+ trees of the same type. It uses std::lexicographical_compare() for the actual comparison of elements. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01728">1728</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="af166796475be0ee04e124e40f60af96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af166796475be0ee04e124e40f60af96e">&#9670;&nbsp;</a></span>operator<=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&lt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html">BTree</a>&lt; Key, Value, KeyOfValue, Compare, Traits, Duplicates, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Less-equal relation. Based on operator&lt;. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01739">1739</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a5d7edbc2e0e59ec25a21d0950c77a50c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d7edbc2e0e59ec25a21d0950c77a50c">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1BTree.html">BTree</a>&amp; operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html">BTree</a>&lt; Key, Value, KeyOfValue, Compare, Traits, Duplicates, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Assignment operator. All the key/data pairs are copied. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01755">1755</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a1ae298c2babff3aff6bd164bd257a685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ae298c2babff3aff6bd164bd257a685">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html">BTree</a>&lt; Key, Value, KeyOfValue, Compare, Traits, Duplicates, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Equality relation of B+ trees of the same type. B+ trees of the same size and equal elements (both key and data) are considered equal. Beware of the random ordering of duplicate keys. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01716">1716</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="aace573405ed5157dda5d0c8bc74ae2d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aace573405ed5157dda5d0c8bc74ae2d8">&#9670;&nbsp;</a></span>operator>()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html">BTree</a>&lt; Key, Value, KeyOfValue, Compare, Traits, Duplicates, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater relation. Based on operator&lt;. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01734">1734</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a177c1adf602ee33c48f94e4906cae241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a177c1adf602ee33c48f94e4906cae241">&#9670;&nbsp;</a></span>operator>=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool operator&gt;= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html">BTree</a>&lt; Key, Value, KeyOfValue, Compare, Traits, Duplicates, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Greater-equal relation. Based on operator&lt;. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01744">1744</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="acea44ed500a54b2bb93e16b86e81afa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acea44ed500a54b2bb93e16b86e81afa8">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1BTree_1_1reverse__iterator.html">reverse_iterator</a> rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a read/data-write reverse iterator that points to the first invalid slot in the last leaf of the B+ tree. Uses STL magic. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01365">1365</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="btree__set_8hpp_source.html#l00277">btree_set&lt; Key_, Compare_, Traits_, Alloc_ &gt;::rbegin()</a>, <a class="el" href="btree__multiset_8hpp_source.html#l00278">btree_multiset&lt; Key_, Compare_, Traits_, Alloc_ &gt;::rbegin()</a>, <a class="el" href="btree__map_8hpp_source.html#l00279">btree_map&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::rbegin()</a>, and <a class="el" href="btree__multimap_8hpp_source.html#l00280">btree_multimap&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::rbegin()</a>.</p>

</div>
</div>
<a id="af086cceac199bd735c7a97c2a8d7ed21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af086cceac199bd735c7a97c2a8d7ed21">&#9670;&nbsp;</a></span>rbegin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1BTree_1_1const__reverse__iterator.html">const_reverse_iterator</a> rbegin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a read-only reverse iterator that points to the first invalid slot in the last leaf of the B+ tree. Uses STL magic. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01377">1377</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a68c599ddcbfddc65170de524ac165e44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68c599ddcbfddc65170de524ac165e44">&#9670;&nbsp;</a></span>rend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1BTree_1_1reverse__iterator.html">reverse_iterator</a> rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a read/data-write reverse iterator that points to the first slot in the first leaf of the B+ tree. Uses STL magic. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01371">1371</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="btree__set_8hpp_source.html#l00283">btree_set&lt; Key_, Compare_, Traits_, Alloc_ &gt;::rend()</a>, <a class="el" href="btree__multiset_8hpp_source.html#l00284">btree_multiset&lt; Key_, Compare_, Traits_, Alloc_ &gt;::rend()</a>, <a class="el" href="btree__map_8hpp_source.html#l00285">btree_map&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::rend()</a>, and <a class="el" href="btree__multimap_8hpp_source.html#l00286">btree_multimap&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::rend()</a>.</p>

</div>
</div>
<a id="a07da1fdc890b6949f1a20a1961c6fc44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07da1fdc890b6949f1a20a1961c6fc44">&#9670;&nbsp;</a></span>rend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1BTree_1_1const__reverse__iterator.html">const_reverse_iterator</a> rend </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a read-only reverse iterator that points to the first slot in the first leaf of the B+ tree. Uses STL magic. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01383">1383</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a22c8a3da26251dfccff50c8bb174c3a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22c8a3da26251dfccff50c8bb174c3a4">&#9670;&nbsp;</a></span>shift_left_inner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void shift_left_inner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a> *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a> *&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>parentslot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Balance two inner nodes. The function moves key/data pairs from right to left so that both nodes are equally filled. The parent node is updated if possible. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l03264">3264</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="ae301448f117e44063d3b322be3534c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae301448f117e44063d3b322be3534c13">&#9670;&nbsp;</a></span>shift_left_leaf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structtlx_1_1BTree_1_1result__t.html">result_t</a> shift_left_leaf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtlx_1_1BTree_1_1LeafNode.html">LeafNode</a> *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtlx_1_1BTree_1_1LeafNode.html">LeafNode</a> *&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>parentslot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Balance two leaf nodes. The function moves key/data pairs from right to left so that both nodes are equally filled. The parent node is updated if possible. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l03215">3215</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a3e25d4b9f9efb4a5496dcf849836fe16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e25d4b9f9efb4a5496dcf849836fe16">&#9670;&nbsp;</a></span>shift_right_inner()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void shift_right_inner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a> *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a> *&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>parentslot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Balance two inner nodes. The function moves key/data pairs from left to right so that both nodes are equally filled. The parent node is updated if possible. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l03385">3385</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a8169e809b9e94043b7aa6c5d9847fb19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8169e809b9e94043b7aa6c5d9847fb19">&#9670;&nbsp;</a></span>shift_right_leaf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void shift_right_leaf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtlx_1_1BTree_1_1LeafNode.html">LeafNode</a> *&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtlx_1_1BTree_1_1LeafNode.html">LeafNode</a> *&#160;</td>
          <td class="paramname"><em>right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a> *&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>parentslot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Balance two leaf nodes. The function moves key/data pairs from left to right so that both nodes are equally filled. The parent node is updated if possible. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l03329">3329</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a60304b65bf89363bcc3165d3cde67f86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60304b65bf89363bcc3165d3cde67f86">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1BTree.html#a49b489a408a211a90e766329c0732d7b">size_type</a> size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of key/data pairs in the B+ tree. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01494">1494</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="btree_8hpp_source.html#l01755">BTree&lt; key_type, value_type, key_of_value, key_compare, traits, true, allocator_type &gt;::operator=()</a>, <a class="el" href="btree_8hpp_source.html#l01716">BTree&lt; key_type, value_type, key_of_value, key_compare, traits, true, allocator_type &gt;::operator==()</a>, <a class="el" href="btree__set_8hpp_source.html#l00306">btree_set&lt; Key_, Compare_, Traits_, Alloc_ &gt;::size()</a>, <a class="el" href="btree__multiset_8hpp_source.html#l00307">btree_multiset&lt; Key_, Compare_, Traits_, Alloc_ &gt;::size()</a>, <a class="el" href="btree__map_8hpp_source.html#l00308">btree_map&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::size()</a>, and <a class="el" href="btree__multimap_8hpp_source.html#l00309">btree_multimap&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::size()</a>.</p>

</div>
</div>
<a id="afd6849b9290c28ea815a0c03b1d9321a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd6849b9290c28ea815a0c03b1d9321a">&#9670;&nbsp;</a></span>split_inner_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void split_inner_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtlx_1_1BTree_1_1InnerNode.html">InnerNode</a> *&#160;</td>
          <td class="paramname"><em>inner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> *&#160;</td>
          <td class="paramname"><em>out_newkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtlx_1_1BTree_1_1node.html">node</a> **&#160;</td>
          <td class="paramname"><em>out_newinner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>addslot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split up an inner node into two equally-filled sibling nodes. Returns the new nodes and it's insertion key in the two parameters. Requires the slot of the item will be inserted, so the nodes will be the same size after the insert. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l02110">2110</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a1234e2d209b518ae0396fb36b4be82d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1234e2d209b518ae0396fb36b4be82d4">&#9670;&nbsp;</a></span>split_leaf_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void split_leaf_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtlx_1_1BTree_1_1LeafNode.html">LeafNode</a> *&#160;</td>
          <td class="paramname"><em>leaf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> *&#160;</td>
          <td class="paramname"><em>out_newkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtlx_1_1BTree_1_1node.html">node</a> **&#160;</td>
          <td class="paramname"><em>out_newleaf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split up a leaf node into two equally-filled sibling leaves. Returns the new nodes and it's insertion key in the two parameters. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l02074">2074</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a0c1e04d5d606adc2876b61fafc73c645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c1e04d5d606adc2876b61fafc73c645">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classtlx_1_1BTree.html">BTree</a>&lt; Key, Value, KeyOfValue, Compare, Traits, Duplicates, Allocator &gt; &amp;&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fast swapping of two identical B+ tree objects. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01144">1144</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a482b50e623a123f653e2a91f113a507b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a482b50e623a123f653e2a91f113a507b">&#9670;&nbsp;</a></span>upper_bound() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1BTree_1_1iterator.html">iterator</a> upper_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Searches the B+ tree and returns an iterator to the first pair greater than key, or <a class="el" href="classtlx_1_1BTree.html#acad38d52497a975bfb6f2f6acd76631f">end()</a> if all keys are smaller or equal. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01656">1656</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="btree__multiset_8hpp_source.html#l00371">btree_multiset&lt; Key_, Compare_, Traits_, Alloc_ &gt;::upper_bound()</a>, <a class="el" href="btree__set_8hpp_source.html#l00371">btree_set&lt; Key_, Compare_, Traits_, Alloc_ &gt;::upper_bound()</a>, <a class="el" href="btree__map_8hpp_source.html#l00373">btree_map&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::upper_bound()</a>, and <a class="el" href="btree__multimap_8hpp_source.html#l00373">btree_multimap&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::upper_bound()</a>.</p>

</div>
</div>
<a id="ab7256d525d9ea50f133bb206aa869f21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7256d525d9ea50f133bb206aa869f21">&#9670;&nbsp;</a></span>upper_bound() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1BTree_1_1const__iterator.html">const_iterator</a> upper_bound </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Searches the B+ tree and returns a constant iterator to the first pair greater than key, or <a class="el" href="classtlx_1_1BTree.html#acad38d52497a975bfb6f2f6acd76631f">end()</a> if all keys are smaller or equal. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01676">1676</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="ac312f2a857eabffe1ca5c8711e0207bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac312f2a857eabffe1ca5c8711e0207bc">&#9670;&nbsp;</a></span>value_comp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1BTree_1_1value__compare.html">value_compare</a> value_comp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constant access to a constructed value_type comparison object. Required by the STL. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01189">1189</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="btree__set_8hpp_source.html#l00219">btree_set&lt; Key_, Compare_, Traits_, Alloc_ &gt;::value_comp()</a>, <a class="el" href="btree__multiset_8hpp_source.html#l00220">btree_multiset&lt; Key_, Compare_, Traits_, Alloc_ &gt;::value_comp()</a>, <a class="el" href="btree__map_8hpp_source.html#l00221">btree_map&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::value_comp()</a>, and <a class="el" href="btree__multimap_8hpp_source.html#l00222">btree_multimap&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::value_comp()</a>.</p>

</div>
</div>
<a id="a8d93d1ede91beb3794a211e32fefa2b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d93d1ede91beb3794a211e32fefa2b6">&#9670;&nbsp;</a></span>verify()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void verify </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Run a thorough verification of all B+ tree invariants. The program aborts via <a class="el" href="die_2core_8hpp.html#ae75b813cfb11a89830e7e7e98dec7ac0">tlx_die_unless()</a> if something is wrong. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l03541">3541</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="btree__set_8hpp_source.html#l00545">btree_set&lt; Key_, Compare_, Traits_, Alloc_ &gt;::verify()</a>, <a class="el" href="btree__multiset_8hpp_source.html#l00546">btree_multiset&lt; Key_, Compare_, Traits_, Alloc_ &gt;::verify()</a>, <a class="el" href="btree__multimap_8hpp_source.html#l00559">btree_multimap&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::verify()</a>, and <a class="el" href="btree__map_8hpp_source.html#l00566">btree_map&lt; Key_, Data_, Compare_, Traits_, Alloc_ &gt;::verify()</a>.</p>

</div>
</div>
<a id="a0584c6460492e482a018e0f7e251b1d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0584c6460492e482a018e0f7e251b1d5">&#9670;&nbsp;</a></span>verify_leaflinks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void verify_leaflinks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Verify the double linked list of leaves. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l03653">3653</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="ac6062e764ae39bb06fa9183b47be948c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6062e764ae39bb06fa9183b47be948c">&#9670;&nbsp;</a></span>verify_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void verify_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtlx_1_1BTree_1_1node.html">node</a> *&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> *&#160;</td>
          <td class="paramname"><em>minkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classtlx_1_1BTree.html#a38ec6d0825c22c2d0ad31f3209ed2d02">key_type</a> *&#160;</td>
          <td class="paramname"><em>maxkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtlx_1_1BTree_1_1tree__stats.html">tree_stats</a> &amp;&#160;</td>
          <td class="paramname"><em>vstats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Recursively descend down the tree and verify each node. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l03559">3559</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a8746da7b8170695c17d760f1a43bd4fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8746da7b8170695c17d760f1a43bd4fe">&#9670;&nbsp;</a></span>allocator_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1BTree.html#aff35d256caa55f37343da8200179e608">allocator_type</a> allocator_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Memory allocator. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01093">1093</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="btree_8hpp_source.html#l01144">BTree&lt; key_type, value_type, key_of_value, key_compare, traits, true, allocator_type &gt;::swap()</a>.</p>

</div>
</div>
<a id="a4a380c8745ff0a1c814742821e85403e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a380c8745ff0a1c814742821e85403e">&#9670;&nbsp;</a></span>allow_duplicates</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool allow_duplicates = Duplicates</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sixth template parameter: Allow duplicate keys in the B+ tree. Used to implement multiset and multimap. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l00150">150</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a6295d47efda04de55c38cb8ea1cdb807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6295d47efda04de55c38cb8ea1cdb807">&#9670;&nbsp;</a></span>debug</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool debug = traits::debug</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Debug parameter: Prints out lots of debug information about how the algorithms change the tree. Requires the header file to be compiled with TLX_BTREE_DEBUG and the key type must be std::ostream printable. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l00203">203</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a8d6ac34d80de837a5e6125c932f1c288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d6ac34d80de837a5e6125c932f1c288">&#9670;&nbsp;</a></span>head_leaf_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtlx_1_1BTree_1_1LeafNode.html">LeafNode</a>* head_leaf_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to first leaf in the double linked leaf chain. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01080">1080</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="btree_8hpp_source.html#l01144">BTree&lt; key_type, value_type, key_of_value, key_compare, traits, true, allocator_type &gt;::swap()</a>.</p>

</div>
</div>
<a id="a004e76f14b7697d3801e3b1d397da5a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a004e76f14b7697d3801e3b1d397da5a5">&#9670;&nbsp;</a></span>inner_slotmax</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned short inner_slotmax = traits::inner_slots</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Base B+ tree parameter: The number of key slots in each inner node, this can differ from slots in each leaf. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l00184">184</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a416b2e639a4ec04429632c3ee85e747c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a416b2e639a4ec04429632c3ee85e747c">&#9670;&nbsp;</a></span>inner_slotmin</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned short inner_slotmin = (<a class="el" href="classtlx_1_1BTree.html#a004e76f14b7697d3801e3b1d397da5a5">inner_slotmax</a> / 2)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computed B+ tree parameter: The minimum number of key slots used in an inner node. If fewer slots are used, the inner node will be merged or slots shifted from it's siblings. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l00194">194</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="a5d945dbdb41ca2fe76d87b2ba122e13e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d945dbdb41ca2fe76d87b2ba122e13e">&#9670;&nbsp;</a></span>key_less_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classtlx_1_1BTree.html#a6ff4e347839868db0770859a3dd55a27">key_compare</a> key_less_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Key comparison object. More comparison functions are generated from this &lt; relation. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01090">1090</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="btree_8hpp_source.html#l01144">BTree&lt; key_type, value_type, key_of_value, key_compare, traits, true, allocator_type &gt;::swap()</a>.</p>

</div>
</div>
<a id="a52e57d8d7e32f6d5a56227a8d1f899cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52e57d8d7e32f6d5a56227a8d1f899cf">&#9670;&nbsp;</a></span>leaf_slotmax</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned short leaf_slotmax = traits::leaf_slots</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Base B+ tree parameter: The number of key/data slots in each leaf. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l00180">180</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="abbec00fa1cdcfbf6b78482915c644dba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbec00fa1cdcfbf6b78482915c644dba">&#9670;&nbsp;</a></span>leaf_slotmin</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned short leaf_slotmin = (<a class="el" href="classtlx_1_1BTree.html#a52e57d8d7e32f6d5a56227a8d1f899cf">leaf_slotmax</a> / 2)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Computed B+ tree parameter: The minimum number of key/data slots used in a leaf. If fewer slots are used, the leaf will be merged or slots shifted from it's siblings. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l00189">189</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="aebc82407c13a86e9551f7984d2e3d356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebc82407c13a86e9551f7984d2e3d356">&#9670;&nbsp;</a></span>root_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtlx_1_1BTree_1_1node.html">node</a>* root_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to the B+ tree's root node, either leaf or inner node. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01077">1077</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="btree_8hpp_source.html#l01779">BTree&lt; key_type, value_type, key_of_value, key_compare, traits, true, allocator_type &gt;::BTree()</a>, <a class="el" href="btree_8hpp_source.html#l01755">BTree&lt; key_type, value_type, key_of_value, key_compare, traits, true, allocator_type &gt;::operator=()</a>, and <a class="el" href="btree_8hpp_source.html#l01144">BTree&lt; key_type, value_type, key_of_value, key_compare, traits, true, allocator_type &gt;::swap()</a>.</p>

</div>
</div>
<a id="a81a632bc519f850f4af56567ba404f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81a632bc519f850f4af56567ba404f4e">&#9670;&nbsp;</a></span>self_verify</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool self_verify = traits::self_verify</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Debug parameter: Enables expensive and thorough checking of the B+ tree invariants after each insert/erase operation. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l00198">198</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

</div>
</div>
<a id="aed457b19fc617a12201f09de1d885368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed457b19fc617a12201f09de1d885368">&#9670;&nbsp;</a></span>stats_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtlx_1_1BTree_1_1tree__stats.html">tree_stats</a> stats_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Other small statistics about the B+ tree. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01086">1086</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="btree_8hpp_source.html#l01755">BTree&lt; key_type, value_type, key_of_value, key_compare, traits, true, allocator_type &gt;::operator=()</a>, and <a class="el" href="btree_8hpp_source.html#l01144">BTree&lt; key_type, value_type, key_of_value, key_compare, traits, true, allocator_type &gt;::swap()</a>.</p>

</div>
</div>
<a id="a6747e195cffb9e4dbceef6a4848b3563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6747e195cffb9e4dbceef6a4848b3563">&#9670;&nbsp;</a></span>tail_leaf_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtlx_1_1BTree_1_1LeafNode.html">LeafNode</a>* tail_leaf_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to last leaf in the double linked leaf chain. </p>

<p class="definition">Definition at line <a class="el" href="btree_8hpp_source.html#l01083">1083</a> of file <a class="el" href="btree_8hpp_source.html">btree.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="btree_8hpp_source.html#l01144">BTree&lt; key_type, value_type, key_of_value, key_compare, traits, true, allocator_type &gt;::swap()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>extlib/tlx/tlx/container/<a class="el" href="btree_8hpp_source.html">btree.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacetlx.html">tlx</a></li><li class="navelem"><a class="el" href="classtlx_1_1BTree.html">BTree</a></li>
    <li class="footer">Generated on Sat Apr 4 2020 09:52:09 for Thrill by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
