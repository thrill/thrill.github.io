<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Thrill: String Algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Thrill
   &#160;<span id="projectnumber">0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__tlx__string.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">String Algorithms<div class="ingroups"><a class="el" href="group__layers.html">Thrill Layers</a> &raquo; <a class="el" href="group__tlx.html">tlx - C++ Extensions and Utilities</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1less__icase__asc.html">less_icase_asc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Case-insensitive less order relation functional class for std::map, etc.  <a href="structtlx_1_1less__icase__asc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1less__icase__desc.html">less_icase_desc</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1LevenshteinStandardICaseParameters.html">LevenshteinStandardICaseParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard parameters to Levenshtein distance function.  <a href="structtlx_1_1LevenshteinStandardICaseParameters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtlx_1_1LevenshteinStandardParameters.html">LevenshteinStandardParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard parameters to levenshtein distance function.  <a href="structtlx_1_1LevenshteinStandardParameters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7de31bec5774af4c0a81b579dd87be53"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga7de31bec5774af4c0a81b579dd87be53">appendline</a> (std::istream &amp;is, std::string &amp;str, char delim)</td></tr>
<tr class="separator:ga7de31bec5774af4c0a81b579dd87be53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a87b7f6120ebcde0c01ad293465f9d7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga7a87b7f6120ebcde0c01ad293465f9d7">compare_icase</a> (const char *a, const char *b)</td></tr>
<tr class="memdesc:ga7a87b7f6120ebcde0c01ad293465f9d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns +1/0/-1 like strcmp(a, b) but without regard for letter case  <a href="group__tlx__string.html#ga7a87b7f6120ebcde0c01ad293465f9d7">More...</a><br /></td></tr>
<tr class="separator:ga7a87b7f6120ebcde0c01ad293465f9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga061e7b66eb332d7621ef99d11b724c16"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga061e7b66eb332d7621ef99d11b724c16">compare_icase</a> (const char *a, const std::string &amp;b)</td></tr>
<tr class="memdesc:ga061e7b66eb332d7621ef99d11b724c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns +1/0/-1 like strcmp(a, b) but without regard for letter case  <a href="group__tlx__string.html#ga061e7b66eb332d7621ef99d11b724c16">More...</a><br /></td></tr>
<tr class="separator:ga061e7b66eb332d7621ef99d11b724c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6b99f43a01b6d2ff8ca49f4518297b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gad6b99f43a01b6d2ff8ca49f4518297b9">compare_icase</a> (const std::string &amp;a, const char *b)</td></tr>
<tr class="memdesc:gad6b99f43a01b6d2ff8ca49f4518297b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns +1/0/-1 like strcmp(a, b) but without regard for letter case  <a href="group__tlx__string.html#gad6b99f43a01b6d2ff8ca49f4518297b9">More...</a><br /></td></tr>
<tr class="separator:gad6b99f43a01b6d2ff8ca49f4518297b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga988bb20efc727413da0a9d9d11f488b0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga988bb20efc727413da0a9d9d11f488b0">compare_icase</a> (const std::string &amp;a, const std::string &amp;b)</td></tr>
<tr class="memdesc:ga988bb20efc727413da0a9d9d11f488b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns +1/0/-1 like strcmp(a, b) but without regard for letter case  <a href="group__tlx__string.html#ga988bb20efc727413da0a9d9d11f488b0">More...</a><br /></td></tr>
<tr class="separator:ga988bb20efc727413da0a9d9d11f488b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ff92619b9a2ae3dbbdd6ef511c1779e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga7ff92619b9a2ae3dbbdd6ef511c1779e">contains</a> (const std::string &amp;str, const std::string &amp;pattern)</td></tr>
<tr class="memdesc:ga7ff92619b9a2ae3dbbdd6ef511c1779e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests of string contains pattern.  <a href="group__tlx__string.html#ga7ff92619b9a2ae3dbbdd6ef511c1779e">More...</a><br /></td></tr>
<tr class="separator:ga7ff92619b9a2ae3dbbdd6ef511c1779e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga399719274798a8a808e8e309ab490f03"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga399719274798a8a808e8e309ab490f03">contains</a> (const std::string &amp;str, const char *pattern)</td></tr>
<tr class="memdesc:ga399719274798a8a808e8e309ab490f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests of string contains pattern.  <a href="group__tlx__string.html#ga399719274798a8a808e8e309ab490f03">More...</a><br /></td></tr>
<tr class="separator:ga399719274798a8a808e8e309ab490f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d6aca56ee9463cd116fc8e065c4c3a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga8d6aca56ee9463cd116fc8e065c4c3a0">contains</a> (const std::string &amp;str, const char ch)</td></tr>
<tr class="memdesc:ga8d6aca56ee9463cd116fc8e065c4c3a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests of string contains character.  <a href="group__tlx__string.html#ga8d6aca56ee9463cd116fc8e065c4c3a0">More...</a><br /></td></tr>
<tr class="separator:ga8d6aca56ee9463cd116fc8e065c4c3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fd07edea7502e13dbc9d2991be95f02"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga2fd07edea7502e13dbc9d2991be95f02">contains_word</a> (const std::string &amp;str, const char *word)</td></tr>
<tr class="memdesc:ga2fd07edea7502e13dbc9d2991be95f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the given string for a whitespace-delimited word.  <a href="group__tlx__string.html#ga2fd07edea7502e13dbc9d2991be95f02">More...</a><br /></td></tr>
<tr class="separator:ga2fd07edea7502e13dbc9d2991be95f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f7b2444597941650e05c1bb96b04f45"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga7f7b2444597941650e05c1bb96b04f45">contains_word</a> (const std::string &amp;str, const std::string &amp;word)</td></tr>
<tr class="memdesc:ga7f7b2444597941650e05c1bb96b04f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the given string for a whitespace-delimited word.  <a href="group__tlx__string.html#ga7f7b2444597941650e05c1bb96b04f45">More...</a><br /></td></tr>
<tr class="separator:ga7f7b2444597941650e05c1bb96b04f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2395fc6f1f7427bda18323fd38ffa1f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga2395fc6f1f7427bda18323fd38ffa1f7">ends_with</a> (const char *str, const char *match)</td></tr>
<tr class="memdesc:ga2395fc6f1f7427bda18323fd38ffa1f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the end of this string.  <a href="group__tlx__string.html#ga2395fc6f1f7427bda18323fd38ffa1f7">More...</a><br /></td></tr>
<tr class="separator:ga2395fc6f1f7427bda18323fd38ffa1f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60cf87567ef6acda6704064cf994b441"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga60cf87567ef6acda6704064cf994b441">ends_with</a> (const char *str, const std::string &amp;match)</td></tr>
<tr class="memdesc:ga60cf87567ef6acda6704064cf994b441"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the end of this string.  <a href="group__tlx__string.html#ga60cf87567ef6acda6704064cf994b441">More...</a><br /></td></tr>
<tr class="separator:ga60cf87567ef6acda6704064cf994b441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacea7b710bca17bae104e7e5eb6137fcf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gacea7b710bca17bae104e7e5eb6137fcf">ends_with</a> (const std::string &amp;str, const char *match)</td></tr>
<tr class="memdesc:gacea7b710bca17bae104e7e5eb6137fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the end of this string.  <a href="group__tlx__string.html#gacea7b710bca17bae104e7e5eb6137fcf">More...</a><br /></td></tr>
<tr class="separator:gacea7b710bca17bae104e7e5eb6137fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6eadd6e031f051ff44c5ab2935cdddfd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga6eadd6e031f051ff44c5ab2935cdddfd">ends_with</a> (const std::string &amp;str, const std::string &amp;match)</td></tr>
<tr class="memdesc:ga6eadd6e031f051ff44c5ab2935cdddfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the end of this string.  <a href="group__tlx__string.html#ga6eadd6e031f051ff44c5ab2935cdddfd">More...</a><br /></td></tr>
<tr class="separator:ga6eadd6e031f051ff44c5ab2935cdddfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7e29572ead3f33c45cd95c8d4b720d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gac7e29572ead3f33c45cd95c8d4b720d0">ends_with_icase</a> (const std::string &amp;str, const char *match)</td></tr>
<tr class="memdesc:gac7e29572ead3f33c45cd95c8d4b720d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the end of this string.  <a href="group__tlx__string.html#gac7e29572ead3f33c45cd95c8d4b720d0">More...</a><br /></td></tr>
<tr class="separator:gac7e29572ead3f33c45cd95c8d4b720d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga849ffa2f657372a30b5cfc53fe1267a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga849ffa2f657372a30b5cfc53fe1267a1">ends_with_icase</a> (const std::string &amp;str, const std::string &amp;match)</td></tr>
<tr class="memdesc:ga849ffa2f657372a30b5cfc53fe1267a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the end of this string.  <a href="group__tlx__string.html#ga849ffa2f657372a30b5cfc53fe1267a1">More...</a><br /></td></tr>
<tr class="separator:ga849ffa2f657372a30b5cfc53fe1267a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42a4d6e9f12943be811bcb6666d53493"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga42a4d6e9f12943be811bcb6666d53493">equal_icase</a> (const char *a, const char *b)</td></tr>
<tr class="memdesc:ga42a4d6e9f12943be811bcb6666d53493"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a == b without regard for letter case  <a href="group__tlx__string.html#ga42a4d6e9f12943be811bcb6666d53493">More...</a><br /></td></tr>
<tr class="separator:ga42a4d6e9f12943be811bcb6666d53493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad15c6b082515414b93a34b7ac0327df9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gad15c6b082515414b93a34b7ac0327df9">equal_icase</a> (const char *a, const std::string &amp;b)</td></tr>
<tr class="memdesc:gad15c6b082515414b93a34b7ac0327df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a == b without regard for letter case  <a href="group__tlx__string.html#gad15c6b082515414b93a34b7ac0327df9">More...</a><br /></td></tr>
<tr class="separator:gad15c6b082515414b93a34b7ac0327df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga118abe0d4d0cd1d90426121b626aeea9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga118abe0d4d0cd1d90426121b626aeea9">equal_icase</a> (const std::string &amp;a, const char *b)</td></tr>
<tr class="memdesc:ga118abe0d4d0cd1d90426121b626aeea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a == b without regard for letter case  <a href="group__tlx__string.html#ga118abe0d4d0cd1d90426121b626aeea9">More...</a><br /></td></tr>
<tr class="separator:ga118abe0d4d0cd1d90426121b626aeea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c9c153df7b49712108276c9a48fe88e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga2c9c153df7b49712108276c9a48fe88e">equal_icase</a> (const std::string &amp;a, const std::string &amp;b)</td></tr>
<tr class="memdesc:ga2c9c153df7b49712108276c9a48fe88e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a == b without regard for letter case  <a href="group__tlx__string.html#ga2c9c153df7b49712108276c9a48fe88e">More...</a><br /></td></tr>
<tr class="separator:ga2c9c153df7b49712108276c9a48fe88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa02a8cee5a6ee9d683fa5a77fda06913"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gaa02a8cee5a6ee9d683fa5a77fda06913">erase_all</a> (std::string *str, char drop=' ')</td></tr>
<tr class="memdesc:gaa02a8cee5a6ee9d683fa5a77fda06913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurrences of the given character in-place.  <a href="group__tlx__string.html#gaa02a8cee5a6ee9d683fa5a77fda06913">More...</a><br /></td></tr>
<tr class="separator:gaa02a8cee5a6ee9d683fa5a77fda06913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga290c6e7261f453c4774a0cf82586bf47"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga290c6e7261f453c4774a0cf82586bf47">erase_all</a> (std::string *str, const char *drop)</td></tr>
<tr class="memdesc:ga290c6e7261f453c4774a0cf82586bf47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurrences of the given characters in-place.  <a href="group__tlx__string.html#ga290c6e7261f453c4774a0cf82586bf47">More...</a><br /></td></tr>
<tr class="separator:ga290c6e7261f453c4774a0cf82586bf47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacefd443f50a3e6123651a031eb1701c4"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gacefd443f50a3e6123651a031eb1701c4">erase_all</a> (std::string *str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:gacefd443f50a3e6123651a031eb1701c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurrences of the given characters in-place.  <a href="group__tlx__string.html#gacefd443f50a3e6123651a031eb1701c4">More...</a><br /></td></tr>
<tr class="separator:gacefd443f50a3e6123651a031eb1701c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cd5bad774df90bb3314592e3e097ad8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga3cd5bad774df90bb3314592e3e097ad8">erase_all</a> (const std::string &amp;str, char drop=' ')</td></tr>
<tr class="memdesc:ga3cd5bad774df90bb3314592e3e097ad8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurrences of the given character, return copy of string.  <a href="group__tlx__string.html#ga3cd5bad774df90bb3314592e3e097ad8">More...</a><br /></td></tr>
<tr class="separator:ga3cd5bad774df90bb3314592e3e097ad8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c0aa5a14584e80887d4afc8c34337f8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga7c0aa5a14584e80887d4afc8c34337f8">erase_all</a> (const std::string &amp;str, const char *drop)</td></tr>
<tr class="memdesc:ga7c0aa5a14584e80887d4afc8c34337f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurrences of the given characters, return copy of string.  <a href="group__tlx__string.html#ga7c0aa5a14584e80887d4afc8c34337f8">More...</a><br /></td></tr>
<tr class="separator:ga7c0aa5a14584e80887d4afc8c34337f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09e7dd3f20d8e54c8502c81d540f9916"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga09e7dd3f20d8e54c8502c81d540f9916">erase_all</a> (const std::string &amp;str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:ga09e7dd3f20d8e54c8502c81d540f9916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurrences of the given characters, return copy of string.  <a href="group__tlx__string.html#ga09e7dd3f20d8e54c8502c81d540f9916">More...</a><br /></td></tr>
<tr class="separator:ga09e7dd3f20d8e54c8502c81d540f9916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3ec7c7d258293a6891f016878d22f09"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gaa3ec7c7d258293a6891f016878d22f09">escape_html</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:gaa3ec7c7d258293a6891f016878d22f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escape characters for inclusion in HTML documents: replaces the characters &lt;, &gt;, &amp; and " with HTML entities.  <a href="group__tlx__string.html#gaa3ec7c7d258293a6891f016878d22f09">More...</a><br /></td></tr>
<tr class="separator:gaa3ec7c7d258293a6891f016878d22f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff9bb94ad54dff0e04f12d87ba4ccd0d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gaff9bb94ad54dff0e04f12d87ba4ccd0d">escape_html</a> (const char *str)</td></tr>
<tr class="memdesc:gaff9bb94ad54dff0e04f12d87ba4ccd0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escape characters for inclusion in HTML documents: replaces the characters &lt;, &gt;, &amp; and " with HTML entities.  <a href="group__tlx__string.html#gaff9bb94ad54dff0e04f12d87ba4ccd0d">More...</a><br /></td></tr>
<tr class="separator:gaff9bb94ad54dff0e04f12d87ba4ccd0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78dd9a77d746d167e41eb91022b3bc38"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga78dd9a77d746d167e41eb91022b3bc38">escape_uri</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga78dd9a77d746d167e41eb91022b3bc38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escape a string into a URI-encoding.  <a href="group__tlx__string.html#ga78dd9a77d746d167e41eb91022b3bc38">More...</a><br /></td></tr>
<tr class="separator:ga78dd9a77d746d167e41eb91022b3bc38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga526a45d33d89b2de7c3c4a0734495332"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga526a45d33d89b2de7c3c4a0734495332">escape_uri</a> (const char *str)</td></tr>
<tr class="memdesc:ga526a45d33d89b2de7c3c4a0734495332"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escape a string into a URI-encoding.  <a href="group__tlx__string.html#ga526a45d33d89b2de7c3c4a0734495332">More...</a><br /></td></tr>
<tr class="separator:ga526a45d33d89b2de7c3c4a0734495332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3c0e542036a6b3db66c2df1592fdcd4"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gaf3c0e542036a6b3db66c2df1592fdcd4">expand_environment_variables</a> (std::string *s)</td></tr>
<tr class="memdesc:gaf3c0e542036a6b3db66c2df1592fdcd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand substrings $ABC_123 and ${ABC_123} into the corresponding environment variables.  <a href="group__tlx__string.html#gaf3c0e542036a6b3db66c2df1592fdcd4">More...</a><br /></td></tr>
<tr class="separator:gaf3c0e542036a6b3db66c2df1592fdcd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9078e1281843ab0c30230082ee244dd3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga9078e1281843ab0c30230082ee244dd3">expand_environment_variables</a> (const std::string &amp;s)</td></tr>
<tr class="memdesc:ga9078e1281843ab0c30230082ee244dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand substrings $ABC_123 and ${ABC_123} into the corresponding environment variables.  <a href="group__tlx__string.html#ga9078e1281843ab0c30230082ee244dd3">More...</a><br /></td></tr>
<tr class="separator:ga9078e1281843ab0c30230082ee244dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59e8b9ac077b7535eccf2dd2469ef792"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga59e8b9ac077b7535eccf2dd2469ef792">expand_environment_variables</a> (const char *s)</td></tr>
<tr class="memdesc:ga59e8b9ac077b7535eccf2dd2469ef792"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand substrings $ABC_123 and ${ABC_123} into the corresponding environment variables.  <a href="group__tlx__string.html#ga59e8b9ac077b7535eccf2dd2469ef792">More...</a><br /></td></tr>
<tr class="separator:ga59e8b9ac077b7535eccf2dd2469ef792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga713c5cd2e2209e379c8b79ba2cd3e398"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga713c5cd2e2209e379c8b79ba2cd3e398">extract_between</a> (const std::string &amp;str, const char *sep1, const char *sep2)</td></tr>
<tr class="memdesc:ga713c5cd2e2209e379c8b79ba2cd3e398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the string for given start and end separators and extract all characters between the both, if they are found.  <a href="group__tlx__string.html#ga713c5cd2e2209e379c8b79ba2cd3e398">More...</a><br /></td></tr>
<tr class="separator:ga713c5cd2e2209e379c8b79ba2cd3e398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1ac1e43a5ae269bdbe594c4f4f4a325"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gae1ac1e43a5ae269bdbe594c4f4f4a325">extract_between</a> (const std::string &amp;str, const char *sep1, const std::string &amp;sep2)</td></tr>
<tr class="memdesc:gae1ac1e43a5ae269bdbe594c4f4f4a325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the string for given start and end separators and extract all characters between the both, if they are found.  <a href="group__tlx__string.html#gae1ac1e43a5ae269bdbe594c4f4f4a325">More...</a><br /></td></tr>
<tr class="separator:gae1ac1e43a5ae269bdbe594c4f4f4a325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0c6e73d346e3deda660b2eb24b06c67"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gaf0c6e73d346e3deda660b2eb24b06c67">extract_between</a> (const std::string &amp;str, const std::string &amp;sep1, const char *sep2)</td></tr>
<tr class="memdesc:gaf0c6e73d346e3deda660b2eb24b06c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the string for given start and end separators and extract all characters between the both, if they are found.  <a href="group__tlx__string.html#gaf0c6e73d346e3deda660b2eb24b06c67">More...</a><br /></td></tr>
<tr class="separator:gaf0c6e73d346e3deda660b2eb24b06c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3a44aaf97230d79b6aac046331240d3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gab3a44aaf97230d79b6aac046331240d3">extract_between</a> (const std::string &amp;str, const std::string &amp;sep1, const std::string &amp;sep2)</td></tr>
<tr class="memdesc:gab3a44aaf97230d79b6aac046331240d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the string for given start and end separators and extract all characters between the both, if they are found.  <a href="group__tlx__string.html#gab3a44aaf97230d79b6aac046331240d3">More...</a><br /></td></tr>
<tr class="separator:gab3a44aaf97230d79b6aac046331240d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga937bd46650d317c28df7c7723ae84119"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga937bd46650d317c28df7c7723ae84119">format_iec_units</a> (uint64_t number, int precision)</td></tr>
<tr class="memdesc:ga937bd46650d317c28df7c7723ae84119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format number as something like 1 TiB.  <a href="group__tlx__string.html#ga937bd46650d317c28df7c7723ae84119">More...</a><br /></td></tr>
<tr class="separator:ga937bd46650d317c28df7c7723ae84119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga084c15f3eff7d1eb6018d00779486013"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga084c15f3eff7d1eb6018d00779486013">format_si_units</a> (uint64_t number, int precision)</td></tr>
<tr class="memdesc:ga084c15f3eff7d1eb6018d00779486013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format number as something like 1 TB.  <a href="group__tlx__string.html#ga084c15f3eff7d1eb6018d00779486013">More...</a><br /></td></tr>
<tr class="separator:ga084c15f3eff7d1eb6018d00779486013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d5fe504fb6456b97583d3b22e29ef15"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga7d5fe504fb6456b97583d3b22e29ef15">hash_djb2</a> (const unsigned char *str)</td></tr>
<tr class="memdesc:ga7d5fe504fb6456b97583d3b22e29ef15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple, fast, but "insecure" string hash method by Dan Bernstein from <a href="http://www.cse.yorku.ca/~oz/hash.html">http://www.cse.yorku.ca/~oz/hash.html</a>.  <a href="group__tlx__string.html#ga7d5fe504fb6456b97583d3b22e29ef15">More...</a><br /></td></tr>
<tr class="separator:ga7d5fe504fb6456b97583d3b22e29ef15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6531595513b1c5d45b7bf4a69f692eb8"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga6531595513b1c5d45b7bf4a69f692eb8">hash_djb2</a> (const char *str)</td></tr>
<tr class="memdesc:ga6531595513b1c5d45b7bf4a69f692eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple, fast, but "insecure" string hash method by Dan Bernstein from <a href="http://www.cse.yorku.ca/~oz/hash.html">http://www.cse.yorku.ca/~oz/hash.html</a>.  <a href="group__tlx__string.html#ga6531595513b1c5d45b7bf4a69f692eb8">More...</a><br /></td></tr>
<tr class="separator:ga6531595513b1c5d45b7bf4a69f692eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dc88c91798e233da55d584356208bde"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga5dc88c91798e233da55d584356208bde">hash_djb2</a> (const unsigned char *str, size_t size)</td></tr>
<tr class="memdesc:ga5dc88c91798e233da55d584356208bde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple, fast, but "insecure" string hash method by Dan Bernstein from <a href="http://www.cse.yorku.ca/~oz/hash.html">http://www.cse.yorku.ca/~oz/hash.html</a>.  <a href="group__tlx__string.html#ga5dc88c91798e233da55d584356208bde">More...</a><br /></td></tr>
<tr class="separator:ga5dc88c91798e233da55d584356208bde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbe3214eb034f80d3b0213e0f9d15d42"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gadbe3214eb034f80d3b0213e0f9d15d42">hash_djb2</a> (const char *str, size_t size)</td></tr>
<tr class="memdesc:gadbe3214eb034f80d3b0213e0f9d15d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple, fast, but "insecure" string hash method by Dan Bernstein from <a href="http://www.cse.yorku.ca/~oz/hash.html">http://www.cse.yorku.ca/~oz/hash.html</a>.  <a href="group__tlx__string.html#gadbe3214eb034f80d3b0213e0f9d15d42">More...</a><br /></td></tr>
<tr class="separator:gadbe3214eb034f80d3b0213e0f9d15d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4496533a4e1ae1eba65ca4ff2aace8b"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gab4496533a4e1ae1eba65ca4ff2aace8b">hash_djb2</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:gab4496533a4e1ae1eba65ca4ff2aace8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple, fast, but "insecure" string hash method by Dan Bernstein from <a href="http://www.cse.yorku.ca/~oz/hash.html">http://www.cse.yorku.ca/~oz/hash.html</a>.  <a href="group__tlx__string.html#gab4496533a4e1ae1eba65ca4ff2aace8b">More...</a><br /></td></tr>
<tr class="separator:gab4496533a4e1ae1eba65ca4ff2aace8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf601eabca113edcea72bd73914f575af"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gaf601eabca113edcea72bd73914f575af">hash_sdbm</a> (const unsigned char *str)</td></tr>
<tr class="memdesc:gaf601eabca113edcea72bd73914f575af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple, fast, but "insecure" string hash method by sdbm database from <a href="http://www.cse.yorku.ca/~oz/hash.html">http://www.cse.yorku.ca/~oz/hash.html</a>.  <a href="group__tlx__string.html#gaf601eabca113edcea72bd73914f575af">More...</a><br /></td></tr>
<tr class="separator:gaf601eabca113edcea72bd73914f575af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa22cee030ea7fd4250a5d62f96f44eec"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gaa22cee030ea7fd4250a5d62f96f44eec">hash_sdbm</a> (const char *str)</td></tr>
<tr class="memdesc:gaa22cee030ea7fd4250a5d62f96f44eec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple, fast, but "insecure" string hash method by sdbm database from <a href="http://www.cse.yorku.ca/~oz/hash.html">http://www.cse.yorku.ca/~oz/hash.html</a>.  <a href="group__tlx__string.html#gaa22cee030ea7fd4250a5d62f96f44eec">More...</a><br /></td></tr>
<tr class="separator:gaa22cee030ea7fd4250a5d62f96f44eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2a3262295fb0a81a969021e1ecd92fa"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gab2a3262295fb0a81a969021e1ecd92fa">hash_sdbm</a> (const unsigned char *str, size_t size)</td></tr>
<tr class="memdesc:gab2a3262295fb0a81a969021e1ecd92fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple, fast, but "insecure" string hash method by sdbm database from <a href="http://www.cse.yorku.ca/~oz/hash.html">http://www.cse.yorku.ca/~oz/hash.html</a>.  <a href="group__tlx__string.html#gab2a3262295fb0a81a969021e1ecd92fa">More...</a><br /></td></tr>
<tr class="separator:gab2a3262295fb0a81a969021e1ecd92fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b763e42bb6cd369d77917c383e15bb4"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga2b763e42bb6cd369d77917c383e15bb4">hash_sdbm</a> (const char *str, size_t size)</td></tr>
<tr class="memdesc:ga2b763e42bb6cd369d77917c383e15bb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple, fast, but "insecure" string hash method by sdbm database from <a href="http://www.cse.yorku.ca/~oz/hash.html">http://www.cse.yorku.ca/~oz/hash.html</a>.  <a href="group__tlx__string.html#ga2b763e42bb6cd369d77917c383e15bb4">More...</a><br /></td></tr>
<tr class="separator:ga2b763e42bb6cd369d77917c383e15bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbd5b48b17bb3d074f4404bce40b592d"><td class="memItemLeft" align="right" valign="top">static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gadbd5b48b17bb3d074f4404bce40b592d">hash_sdbm</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:gadbd5b48b17bb3d074f4404bce40b592d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple, fast, but "insecure" string hash method by sdbm database from <a href="http://www.cse.yorku.ca/~oz/hash.html">http://www.cse.yorku.ca/~oz/hash.html</a>.  <a href="group__tlx__string.html#gadbd5b48b17bb3d074f4404bce40b592d">More...</a><br /></td></tr>
<tr class="separator:gadbd5b48b17bb3d074f4404bce40b592d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15b290439811d07e8fc0a6134c4faa0b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga15b290439811d07e8fc0a6134c4faa0b">index_of</a> (const std::vector&lt; std::string &gt; &amp;list, const char *str)</td></tr>
<tr class="memdesc:ga15b290439811d07e8fc0a6134c4faa0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to find str in the list and return the index.  <a href="group__tlx__string.html#ga15b290439811d07e8fc0a6134c4faa0b">More...</a><br /></td></tr>
<tr class="separator:ga15b290439811d07e8fc0a6134c4faa0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5156b8029cca4a21cb3e1b14ea6526d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gac5156b8029cca4a21cb3e1b14ea6526d">index_of</a> (const std::vector&lt; std::string &gt; &amp;list, const std::string &amp;str)</td></tr>
<tr class="memdesc:gac5156b8029cca4a21cb3e1b14ea6526d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to find str in the list and return the index.  <a href="group__tlx__string.html#gac5156b8029cca4a21cb3e1b14ea6526d">More...</a><br /></td></tr>
<tr class="separator:gac5156b8029cca4a21cb3e1b14ea6526d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00bece0086ba6a8598e97e93694b713f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga00bece0086ba6a8598e97e93694b713f">index_of_icase</a> (const std::vector&lt; std::string &gt; &amp;list, const char *str)</td></tr>
<tr class="memdesc:ga00bece0086ba6a8598e97e93694b713f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to find str in the list and return the index using case-insensitive comparisons.  <a href="group__tlx__string.html#ga00bece0086ba6a8598e97e93694b713f">More...</a><br /></td></tr>
<tr class="separator:ga00bece0086ba6a8598e97e93694b713f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d3b5b0636e261f97ab3292d78f2201b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga2d3b5b0636e261f97ab3292d78f2201b">index_of_icase</a> (const std::vector&lt; std::string &gt; &amp;list, const std::string &amp;str)</td></tr>
<tr class="memdesc:ga2d3b5b0636e261f97ab3292d78f2201b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to find str in the list and return the index using case-insensitive comparisons.  <a href="group__tlx__string.html#ga2d3b5b0636e261f97ab3292d78f2201b">More...</a><br /></td></tr>
<tr class="separator:ga2d3b5b0636e261f97ab3292d78f2201b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a73759be8d7ec5778cb6192bc32c4c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga3a73759be8d7ec5778cb6192bc32c4c2">less_icase</a> (const char *a, const char *b)</td></tr>
<tr class="memdesc:ga3a73759be8d7ec5778cb6192bc32c4c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a &lt; b without regard for letter case  <a href="group__tlx__string.html#ga3a73759be8d7ec5778cb6192bc32c4c2">More...</a><br /></td></tr>
<tr class="separator:ga3a73759be8d7ec5778cb6192bc32c4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e53bb43043cc4fdf6fef5a9f017957c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga0e53bb43043cc4fdf6fef5a9f017957c">less_icase</a> (const char *a, const std::string &amp;b)</td></tr>
<tr class="memdesc:ga0e53bb43043cc4fdf6fef5a9f017957c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a &lt; b without regard for letter case  <a href="group__tlx__string.html#ga0e53bb43043cc4fdf6fef5a9f017957c">More...</a><br /></td></tr>
<tr class="separator:ga0e53bb43043cc4fdf6fef5a9f017957c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25e2629353a36fb47c587b4eef89c0d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga25e2629353a36fb47c587b4eef89c0d2">less_icase</a> (const std::string &amp;a, const char *b)</td></tr>
<tr class="memdesc:ga25e2629353a36fb47c587b4eef89c0d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a &lt; b without regard for letter case  <a href="group__tlx__string.html#ga25e2629353a36fb47c587b4eef89c0d2">More...</a><br /></td></tr>
<tr class="separator:ga25e2629353a36fb47c587b4eef89c0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fb49f152c6bf0d96ec46bfb90a38bfc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga9fb49f152c6bf0d96ec46bfb90a38bfc">less_icase</a> (const std::string &amp;a, const std::string &amp;b)</td></tr>
<tr class="memdesc:ga9fb49f152c6bf0d96ec46bfb90a38bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a &lt; b without regard for letter case  <a href="group__tlx__string.html#ga9fb49f152c6bf0d96ec46bfb90a38bfc">More...</a><br /></td></tr>
<tr class="separator:ga9fb49f152c6bf0d96ec46bfb90a38bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5097f3a710847ed15aa3cdc2bbbe857c"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga5097f3a710847ed15aa3cdc2bbbe857c">levenshtein</a> (const char *a, const char *b)</td></tr>
<tr class="memdesc:ga5097f3a710847ed15aa3cdc2bbbe857c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Levenshtein string distance between two strings.  <a href="group__tlx__string.html#ga5097f3a710847ed15aa3cdc2bbbe857c">More...</a><br /></td></tr>
<tr class="separator:ga5097f3a710847ed15aa3cdc2bbbe857c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga643fe1eebc35da109f593cdcf068d3af"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga643fe1eebc35da109f593cdcf068d3af">levenshtein</a> (const std::string &amp;a, const std::string &amp;b)</td></tr>
<tr class="memdesc:ga643fe1eebc35da109f593cdcf068d3af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Levenshtein string distance between two strings.  <a href="group__tlx__string.html#ga643fe1eebc35da109f593cdcf068d3af">More...</a><br /></td></tr>
<tr class="separator:ga643fe1eebc35da109f593cdcf068d3af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28296225d021e2ff9a1bedfa711b26fa"><td class="memTemplParams" colspan="2">template&lt;typename Param &gt; </td></tr>
<tr class="memitem:ga28296225d021e2ff9a1bedfa711b26fa"><td class="memTemplItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga28296225d021e2ff9a1bedfa711b26fa">levenshtein_algorithm</a> (const char *a, size_t a_size, const char *b, size_t b_size)</td></tr>
<tr class="memdesc:ga28296225d021e2ff9a1bedfa711b26fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Levenshtein string distance also called edit distance between two strings.  <a href="group__tlx__string.html#ga28296225d021e2ff9a1bedfa711b26fa">More...</a><br /></td></tr>
<tr class="separator:ga28296225d021e2ff9a1bedfa711b26fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga01fc1d66b4a6f822509d793576b2cce2"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga01fc1d66b4a6f822509d793576b2cce2">levenshtein_icase</a> (const char *a, const char *b)</td></tr>
<tr class="memdesc:ga01fc1d66b4a6f822509d793576b2cce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Levenshtein string distance between two strings.  <a href="group__tlx__string.html#ga01fc1d66b4a6f822509d793576b2cce2">More...</a><br /></td></tr>
<tr class="separator:ga01fc1d66b4a6f822509d793576b2cce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d20af010f11fab72744484ef67e00b6"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga0d20af010f11fab72744484ef67e00b6">levenshtein_icase</a> (const std::string &amp;a, const std::string &amp;b)</td></tr>
<tr class="memdesc:ga0d20af010f11fab72744484ef67e00b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the Levenshtein string distance between two strings.  <a href="group__tlx__string.html#ga0d20af010f11fab72744484ef67e00b6">More...</a><br /></td></tr>
<tr class="separator:ga0d20af010f11fab72744484ef67e00b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60ca8653250ad56e209887e5e7183328"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga60ca8653250ad56e209887e5e7183328">pad</a> (const std::string &amp;s, size_t len, char pad_char=' ')</td></tr>
<tr class="memdesc:ga60ca8653250ad56e209887e5e7183328"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate or pad string to exactly len characters.  <a href="group__tlx__string.html#ga60ca8653250ad56e209887e5e7183328">More...</a><br /></td></tr>
<tr class="separator:ga60ca8653250ad56e209887e5e7183328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58be0557b1b38913b28d947c935aed42"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga58be0557b1b38913b28d947c935aed42">parse_si_iec_units</a> (const char *str, uint64_t *out_size, char default_unit=0)</td></tr>
<tr class="memdesc:ga58be0557b1b38913b28d947c935aed42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a string like "343KB" or "44 GiB" into the corresponding size in bytes.  <a href="group__tlx__string.html#ga58be0557b1b38913b28d947c935aed42">More...</a><br /></td></tr>
<tr class="separator:ga58be0557b1b38913b28d947c935aed42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42a656ed3586b515140cb71b312f0f9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga42a656ed3586b515140cb71b312f0f9b">parse_si_iec_units</a> (const std::string &amp;str, uint64_t *out_size, char default_unit=0)</td></tr>
<tr class="memdesc:ga42a656ed3586b515140cb71b312f0f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a string like "343KB" or "44 GiB" into the corresponding size in bytes.  <a href="group__tlx__string.html#ga42a656ed3586b515140cb71b312f0f9b">More...</a><br /></td></tr>
<tr class="separator:ga42a656ed3586b515140cb71b312f0f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92d58b1e8b06cbb57400b5959281a4a1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga92d58b1e8b06cbb57400b5959281a4a1">split_words</a> (const std::string &amp;str, std::string::size_type limit=std::string::npos)</td></tr>
<tr class="memdesc:ga92d58b1e8b06cbb57400b5959281a4a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string by whitespaces into distinct words.  <a href="group__tlx__string.html#ga92d58b1e8b06cbb57400b5959281a4a1">More...</a><br /></td></tr>
<tr class="separator:ga92d58b1e8b06cbb57400b5959281a4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafc9efa79c49c462b0ee723e4f9b384d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gaafc9efa79c49c462b0ee723e4f9b384d">ssnprintf</a> (size_t max_size, const char *fmt,...) <a class="el" href="group__tlx__define.html#ga246a72d6938b4e4a40f11571a676b472">TLX_ATTRIBUTE_FORMAT_PRINTF</a>(2</td></tr>
<tr class="memdesc:gaafc9efa79c49c462b0ee723e4f9b384d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for return the result of a snprintf() call inside a std::string.  <a href="group__tlx__string.html#gaafc9efa79c49c462b0ee723e4f9b384d">More...</a><br /></td></tr>
<tr class="separator:gaafc9efa79c49c462b0ee723e4f9b384d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cc4f715331a96631370a8a25d6e9526"><td class="memTemplParams" colspan="2">template&lt;typename String  = std::string&gt; </td></tr>
<tr class="memitem:ga1cc4f715331a96631370a8a25d6e9526"><td class="memTemplItemLeft" align="right" valign="top">String&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga1cc4f715331a96631370a8a25d6e9526">ssnprintf_generic</a> (size_t max_size, const char *fmt,...) <a class="el" href="group__tlx__define.html#ga246a72d6938b4e4a40f11571a676b472">TLX_ATTRIBUTE_FORMAT_PRINTF</a>(2</td></tr>
<tr class="memdesc:ga1cc4f715331a96631370a8a25d6e9526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for return the result of a snprintf() call inside a string object.  <a href="group__tlx__string.html#ga1cc4f715331a96631370a8a25d6e9526">More...</a><br /></td></tr>
<tr class="separator:ga1cc4f715331a96631370a8a25d6e9526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5a94b0f02730f1df3009eb5ce67eb17"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gae5a94b0f02730f1df3009eb5ce67eb17">ssprintf</a> (const char *fmt,...) <a class="el" href="group__tlx__define.html#ga246a72d6938b4e4a40f11571a676b472">TLX_ATTRIBUTE_FORMAT_PRINTF</a>(1</td></tr>
<tr class="memdesc:gae5a94b0f02730f1df3009eb5ce67eb17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for return the result of a sprintf() call inside a std::string.  <a href="group__tlx__string.html#gae5a94b0f02730f1df3009eb5ce67eb17">More...</a><br /></td></tr>
<tr class="separator:gae5a94b0f02730f1df3009eb5ce67eb17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa45e4c8639177f5deb682313a572c32b"><td class="memTemplParams" colspan="2">template&lt;typename String  = std::string&gt; </td></tr>
<tr class="memitem:gaa45e4c8639177f5deb682313a572c32b"><td class="memTemplItemLeft" align="right" valign="top">String&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gaa45e4c8639177f5deb682313a572c32b">ssprintf_generic</a> (const char *fmt,...) <a class="el" href="group__tlx__define.html#ga246a72d6938b4e4a40f11571a676b472">TLX_ATTRIBUTE_FORMAT_PRINTF</a>(1</td></tr>
<tr class="memdesc:gaa45e4c8639177f5deb682313a572c32b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper for return the result of a sprintf() call inside a string object.  <a href="group__tlx__string.html#gaa45e4c8639177f5deb682313a572c32b">More...</a><br /></td></tr>
<tr class="separator:gaa45e4c8639177f5deb682313a572c32b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga77af8ef839dcd6f90d26bcb68413df1b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga77af8ef839dcd6f90d26bcb68413df1b">starts_with</a> (const char *str, const char *match)</td></tr>
<tr class="memdesc:ga77af8ef839dcd6f90d26bcb68413df1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the start of this string.  <a href="group__tlx__string.html#ga77af8ef839dcd6f90d26bcb68413df1b">More...</a><br /></td></tr>
<tr class="separator:ga77af8ef839dcd6f90d26bcb68413df1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabdd7c8689c583acd1e58e5b87b18ae4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gaabdd7c8689c583acd1e58e5b87b18ae4">starts_with</a> (const char *str, const std::string &amp;match)</td></tr>
<tr class="memdesc:gaabdd7c8689c583acd1e58e5b87b18ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the start of this string.  <a href="group__tlx__string.html#gaabdd7c8689c583acd1e58e5b87b18ae4">More...</a><br /></td></tr>
<tr class="separator:gaabdd7c8689c583acd1e58e5b87b18ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga125efbe989d08402389613766af825b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga125efbe989d08402389613766af825b5">starts_with</a> (const std::string &amp;str, const char *match)</td></tr>
<tr class="memdesc:ga125efbe989d08402389613766af825b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the start of this string.  <a href="group__tlx__string.html#ga125efbe989d08402389613766af825b5">More...</a><br /></td></tr>
<tr class="separator:ga125efbe989d08402389613766af825b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc5cce7e8c7fd30078b9129a7ae1d74b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gadc5cce7e8c7fd30078b9129a7ae1d74b">starts_with</a> (const std::string &amp;str, const std::string &amp;match)</td></tr>
<tr class="memdesc:gadc5cce7e8c7fd30078b9129a7ae1d74b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the start of this string.  <a href="group__tlx__string.html#gadc5cce7e8c7fd30078b9129a7ae1d74b">More...</a><br /></td></tr>
<tr class="separator:gadc5cce7e8c7fd30078b9129a7ae1d74b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ca04814cbc556649adfd9fa2dbb40e6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga9ca04814cbc556649adfd9fa2dbb40e6">starts_with_icase</a> (const char *str, const char *match)</td></tr>
<tr class="memdesc:ga9ca04814cbc556649adfd9fa2dbb40e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the start of this string.  <a href="group__tlx__string.html#ga9ca04814cbc556649adfd9fa2dbb40e6">More...</a><br /></td></tr>
<tr class="separator:ga9ca04814cbc556649adfd9fa2dbb40e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f3acf713798426fde1285f5ccab8922"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga9f3acf713798426fde1285f5ccab8922">starts_with_icase</a> (const char *str, const std::string &amp;match)</td></tr>
<tr class="memdesc:ga9f3acf713798426fde1285f5ccab8922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the start of this string.  <a href="group__tlx__string.html#ga9f3acf713798426fde1285f5ccab8922">More...</a><br /></td></tr>
<tr class="separator:ga9f3acf713798426fde1285f5ccab8922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6d169441d65d96bceb7c936e88afc67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gab6d169441d65d96bceb7c936e88afc67">starts_with_icase</a> (const std::string &amp;str, const char *match)</td></tr>
<tr class="memdesc:gab6d169441d65d96bceb7c936e88afc67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the start of this string.  <a href="group__tlx__string.html#gab6d169441d65d96bceb7c936e88afc67">More...</a><br /></td></tr>
<tr class="separator:gab6d169441d65d96bceb7c936e88afc67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbcdc1f2a056e954b197ce9c1d236522"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gadbcdc1f2a056e954b197ce9c1d236522">starts_with_icase</a> (const std::string &amp;str, const std::string &amp;match)</td></tr>
<tr class="memdesc:gadbcdc1f2a056e954b197ce9c1d236522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the start of this string.  <a href="group__tlx__string.html#gadbcdc1f2a056e954b197ce9c1d236522">More...</a><br /></td></tr>
<tr class="separator:gadbcdc1f2a056e954b197ce9c1d236522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga355a332620f8220ecbb0dc5a0aa67350"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga355a332620f8220ecbb0dc5a0aa67350">to_lower</a> (char ch)</td></tr>
<tr class="memdesc:ga355a332620f8220ecbb0dc5a0aa67350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform the given character to lower case without any localization.  <a href="group__tlx__string.html#ga355a332620f8220ecbb0dc5a0aa67350">More...</a><br /></td></tr>
<tr class="separator:ga355a332620f8220ecbb0dc5a0aa67350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ec240b74b77e3ce42f8d67079dea430"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga4ec240b74b77e3ce42f8d67079dea430">to_lower</a> (std::string *str)</td></tr>
<tr class="memdesc:ga4ec240b74b77e3ce42f8d67079dea430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the given string to lowercase and returns a reference to it.  <a href="group__tlx__string.html#ga4ec240b74b77e3ce42f8d67079dea430">More...</a><br /></td></tr>
<tr class="separator:ga4ec240b74b77e3ce42f8d67079dea430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga647f5157d00473cf9bf37c92044bd9a8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga647f5157d00473cf9bf37c92044bd9a8">to_lower</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga647f5157d00473cf9bf37c92044bd9a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the given string converted to lowercase.  <a href="group__tlx__string.html#ga647f5157d00473cf9bf37c92044bd9a8">More...</a><br /></td></tr>
<tr class="separator:ga647f5157d00473cf9bf37c92044bd9a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa00b5d705507da8f74f1ba3874174d8d"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gaa00b5d705507da8f74f1ba3874174d8d">to_upper</a> (char ch)</td></tr>
<tr class="memdesc:gaa00b5d705507da8f74f1ba3874174d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform the given character to upper case without any localization.  <a href="group__tlx__string.html#gaa00b5d705507da8f74f1ba3874174d8d">More...</a><br /></td></tr>
<tr class="separator:gaa00b5d705507da8f74f1ba3874174d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d9edcc3303203825126d7d422e8ab75"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga7d9edcc3303203825126d7d422e8ab75">to_upper</a> (std::string *str)</td></tr>
<tr class="memdesc:ga7d9edcc3303203825126d7d422e8ab75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the given string to uppercase and returns a reference to it.  <a href="group__tlx__string.html#ga7d9edcc3303203825126d7d422e8ab75">More...</a><br /></td></tr>
<tr class="separator:ga7d9edcc3303203825126d7d422e8ab75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2be559f6e498862bec070f122feb6e14"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga2be559f6e498862bec070f122feb6e14">to_upper</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga2be559f6e498862bec070f122feb6e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the given string converted to uppercase.  <a href="group__tlx__string.html#ga2be559f6e498862bec070f122feb6e14">More...</a><br /></td></tr>
<tr class="separator:ga2be559f6e498862bec070f122feb6e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39619db78c7e916bff3544fb07cbe462"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga39619db78c7e916bff3544fb07cbe462">union_words</a> (const std::string &amp;wordsA, const std::string &amp;wordsB)</td></tr>
<tr class="memdesc:ga39619db78c7e916bff3544fb07cbe462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return union of two keyword sets.  <a href="group__tlx__string.html#ga39619db78c7e916bff3544fb07cbe462">More...</a><br /></td></tr>
<tr class="separator:ga39619db78c7e916bff3544fb07cbe462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d0ada76ddce7fc09d770fa512780839"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga2d0ada76ddce7fc09d770fa512780839">word_wrap</a> (const std::string &amp;str, unsigned int wrap=80)</td></tr>
<tr class="memdesc:ga2d0ada76ddce7fc09d770fa512780839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to wrap a string to 80 columns without split words.  <a href="group__tlx__string.html#ga2d0ada76ddce7fc09d770fa512780839">More...</a><br /></td></tr>
<tr class="separator:ga2d0ada76ddce7fc09d770fa512780839"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Base64 Encoding and Decoding</h2></td></tr>
<tr class="memitem:ga691477f59c8496eec65e994ce3f6e6e5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga691477f59c8496eec65e994ce3f6e6e5">base64_encode</a> (const void *data, size_t size, size_t line_break=0)</td></tr>
<tr class="memdesc:ga691477f59c8496eec65e994ce3f6e6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode the given binary data into base64 representation as described in RFC 2045 or RFC 3548.  <a href="group__tlx__string.html#ga691477f59c8496eec65e994ce3f6e6e5">More...</a><br /></td></tr>
<tr class="separator:ga691477f59c8496eec65e994ce3f6e6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16a12f591febaeddffd2ffca031c8bf4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga16a12f591febaeddffd2ffca031c8bf4">base64_encode</a> (const std::string &amp;str, size_t line_break=0)</td></tr>
<tr class="memdesc:ga16a12f591febaeddffd2ffca031c8bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode the given binary string into base64 representation as described in RFC 2045 or RFC 3548.  <a href="group__tlx__string.html#ga16a12f591febaeddffd2ffca031c8bf4">More...</a><br /></td></tr>
<tr class="separator:ga16a12f591febaeddffd2ffca031c8bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2775fbea220f27325aba0f8af1cc9a8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gac2775fbea220f27325aba0f8af1cc9a8">base64_decode</a> (const void *data, size_t size, bool strict=true)</td></tr>
<tr class="memdesc:gac2775fbea220f27325aba0f8af1cc9a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a string in base64 representation as described in RFC 2045 or RFC 3548 and return the original data.  <a href="group__tlx__string.html#gac2775fbea220f27325aba0f8af1cc9a8">More...</a><br /></td></tr>
<tr class="separator:gac2775fbea220f27325aba0f8af1cc9a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe1e973cd3a2d5b7e55544d4c616da49"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gabe1e973cd3a2d5b7e55544d4c616da49">base64_decode</a> (const std::string &amp;str, bool strict=true)</td></tr>
<tr class="memdesc:gabe1e973cd3a2d5b7e55544d4c616da49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a string in base64 representation as described in RFC 2045 or RFC 3548 and return the original data.  <a href="group__tlx__string.html#gabe1e973cd3a2d5b7e55544d4c616da49">More...</a><br /></td></tr>
<tr class="separator:gabe1e973cd3a2d5b7e55544d4c616da49"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Bitdump Methods</h2></td></tr>
<tr class="memitem:ga00c0a01f04e50e69dadc483dee4b7b08"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga00c0a01f04e50e69dadc483dee4b7b08">bitdump_le8</a> (const void *const data, size_t size)</td></tr>
<tr class="memdesc:ga00c0a01f04e50e69dadc483dee4b7b08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) string as a sequence of 8-bit little-endian bytes.  <a href="group__tlx__string.html#ga00c0a01f04e50e69dadc483dee4b7b08">More...</a><br /></td></tr>
<tr class="separator:ga00c0a01f04e50e69dadc483dee4b7b08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6d05a55439476040242e61a1474b9b9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gae6d05a55439476040242e61a1474b9b9">bitdump_le8</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:gae6d05a55439476040242e61a1474b9b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) string as a sequence of 8-bit little-endian bytes.  <a href="group__tlx__string.html#gae6d05a55439476040242e61a1474b9b9">More...</a><br /></td></tr>
<tr class="separator:gae6d05a55439476040242e61a1474b9b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfc711557532d311aa3ced8de036f623"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:gacfc711557532d311aa3ced8de036f623"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gacfc711557532d311aa3ced8de036f623">bitdump_le8_type</a> (const Type &amp;t)</td></tr>
<tr class="memdesc:gacfc711557532d311aa3ced8de036f623"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) item as a sequence of 8-bit little-endian bytes.  <a href="group__tlx__string.html#gacfc711557532d311aa3ced8de036f623">More...</a><br /></td></tr>
<tr class="separator:gacfc711557532d311aa3ced8de036f623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacfad4094f21f5a7ee748330d56764c13"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gacfad4094f21f5a7ee748330d56764c13">bitdump_be8</a> (const void *const data, size_t size)</td></tr>
<tr class="memdesc:gacfad4094f21f5a7ee748330d56764c13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) string as a sequence of 8-bit big-endian bytes.  <a href="group__tlx__string.html#gacfad4094f21f5a7ee748330d56764c13">More...</a><br /></td></tr>
<tr class="separator:gacfad4094f21f5a7ee748330d56764c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05d04f64b0d1ec8b2277b2236106e3b4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga05d04f64b0d1ec8b2277b2236106e3b4">bitdump_be8</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga05d04f64b0d1ec8b2277b2236106e3b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) string as a sequence of 8-bit big-endian bytes.  <a href="group__tlx__string.html#ga05d04f64b0d1ec8b2277b2236106e3b4">More...</a><br /></td></tr>
<tr class="separator:ga05d04f64b0d1ec8b2277b2236106e3b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae0fea123d8861a6d2c11c746741dd524"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:gae0fea123d8861a6d2c11c746741dd524"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gae0fea123d8861a6d2c11c746741dd524">bitdump_be8_type</a> (const Type &amp;t)</td></tr>
<tr class="memdesc:gae0fea123d8861a6d2c11c746741dd524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) item as a sequence of 8-bit big-endian bytes.  <a href="group__tlx__string.html#gae0fea123d8861a6d2c11c746741dd524">More...</a><br /></td></tr>
<tr class="separator:gae0fea123d8861a6d2c11c746741dd524"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Hexdump Methods</h2></td></tr>
<tr class="memitem:gab4c0ada9ff7b0d905361e60050316899"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gab4c0ada9ff7b0d905361e60050316899">hexdump</a> (const void *const data, size_t size)</td></tr>
<tr class="memdesc:gab4c0ada9ff7b0d905361e60050316899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) string as a sequence of uppercase hexadecimal pairs.  <a href="group__tlx__string.html#gab4c0ada9ff7b0d905361e60050316899">More...</a><br /></td></tr>
<tr class="separator:gab4c0ada9ff7b0d905361e60050316899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0757bf9871dc4e2526ab48e4cde28e1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gaa0757bf9871dc4e2526ab48e4cde28e1">hexdump</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:gaa0757bf9871dc4e2526ab48e4cde28e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) string as a sequence of uppercase hexadecimal pairs.  <a href="group__tlx__string.html#gaa0757bf9871dc4e2526ab48e4cde28e1">More...</a><br /></td></tr>
<tr class="separator:gaa0757bf9871dc4e2526ab48e4cde28e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2a485134f5e618b846abb630d44ec6f"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:gae2a485134f5e618b846abb630d44ec6f"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gae2a485134f5e618b846abb630d44ec6f">hexdump_type</a> (const Type &amp;t)</td></tr>
<tr class="memdesc:gae2a485134f5e618b846abb630d44ec6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) item as a sequence of uppercase hexadecimal pairs.  <a href="group__tlx__string.html#gae2a485134f5e618b846abb630d44ec6f">More...</a><br /></td></tr>
<tr class="separator:gae2a485134f5e618b846abb630d44ec6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15c83e3e2055412b0440758c98b3f148"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga15c83e3e2055412b0440758c98b3f148">hexdump</a> (const std::vector&lt; char &gt; &amp;data)</td></tr>
<tr class="memdesc:ga15c83e3e2055412b0440758c98b3f148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a char vector as a sequence of uppercase hexadecimal pairs.  <a href="group__tlx__string.html#ga15c83e3e2055412b0440758c98b3f148">More...</a><br /></td></tr>
<tr class="separator:ga15c83e3e2055412b0440758c98b3f148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c6446ce9a61a434b3a10345cbf3ebed"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga6c6446ce9a61a434b3a10345cbf3ebed">hexdump</a> (const std::vector&lt; uint8_t &gt; &amp;data)</td></tr>
<tr class="memdesc:ga6c6446ce9a61a434b3a10345cbf3ebed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a uint8_t vector as a sequence of uppercase hexadecimal pairs.  <a href="group__tlx__string.html#ga6c6446ce9a61a434b3a10345cbf3ebed">More...</a><br /></td></tr>
<tr class="separator:ga6c6446ce9a61a434b3a10345cbf3ebed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab10f91fa3b24c787e4e0d88c009ac298"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gab10f91fa3b24c787e4e0d88c009ac298">hexdump_sourcecode</a> (const std::string &amp;str, const std::string &amp;var_name=&quot;name&quot;)</td></tr>
<tr class="memdesc:gab10f91fa3b24c787e4e0d88c009ac298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) string into a C source code snippet.  <a href="group__tlx__string.html#gab10f91fa3b24c787e4e0d88c009ac298">More...</a><br /></td></tr>
<tr class="separator:gab10f91fa3b24c787e4e0d88c009ac298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c47a216e0abcdf9a88fc50bb79c98ba"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga0c47a216e0abcdf9a88fc50bb79c98ba">hexdump_lc</a> (const void *const data, size_t size)</td></tr>
<tr class="memdesc:ga0c47a216e0abcdf9a88fc50bb79c98ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) string as a sequence of lowercase hexadecimal pairs.  <a href="group__tlx__string.html#ga0c47a216e0abcdf9a88fc50bb79c98ba">More...</a><br /></td></tr>
<tr class="separator:ga0c47a216e0abcdf9a88fc50bb79c98ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60e8912db4511738cfdbf3e97ff6dbbf"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga60e8912db4511738cfdbf3e97ff6dbbf">hexdump_lc</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga60e8912db4511738cfdbf3e97ff6dbbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) string as a sequence of lowercase hexadecimal pairs.  <a href="group__tlx__string.html#ga60e8912db4511738cfdbf3e97ff6dbbf">More...</a><br /></td></tr>
<tr class="separator:ga60e8912db4511738cfdbf3e97ff6dbbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b2f444830d8f7b1b0eaf93b5f514bf7"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ga0b2f444830d8f7b1b0eaf93b5f514bf7"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga0b2f444830d8f7b1b0eaf93b5f514bf7">hexdump_lc_type</a> (const Type &amp;t)</td></tr>
<tr class="memdesc:ga0b2f444830d8f7b1b0eaf93b5f514bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) item as a sequence of lowercase hexadecimal pairs.  <a href="group__tlx__string.html#ga0b2f444830d8f7b1b0eaf93b5f514bf7">More...</a><br /></td></tr>
<tr class="separator:ga0b2f444830d8f7b1b0eaf93b5f514bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae749cedcfc25af4f829d70e8febba7a1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gae749cedcfc25af4f829d70e8febba7a1">hexdump_lc</a> (const std::vector&lt; char &gt; &amp;data)</td></tr>
<tr class="memdesc:gae749cedcfc25af4f829d70e8febba7a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a char vector as a sequence of lowercase hexadecimal pairs.  <a href="group__tlx__string.html#gae749cedcfc25af4f829d70e8febba7a1">More...</a><br /></td></tr>
<tr class="separator:gae749cedcfc25af4f829d70e8febba7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b35bd68e5974e78327fce13e0e2eaf6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga0b35bd68e5974e78327fce13e0e2eaf6">hexdump_lc</a> (const std::vector&lt; uint8_t &gt; &amp;data)</td></tr>
<tr class="memdesc:ga0b35bd68e5974e78327fce13e0e2eaf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a uint8_t vector as a sequence of lowercase hexadecimal pairs.  <a href="group__tlx__string.html#ga0b35bd68e5974e78327fce13e0e2eaf6">More...</a><br /></td></tr>
<tr class="separator:ga0b35bd68e5974e78327fce13e0e2eaf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81809bc5e0b69034f39659303baa4bf9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga81809bc5e0b69034f39659303baa4bf9">parse_hexdump</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga81809bc5e0b69034f39659303baa4bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a string as a sequence of hexadecimal pairs.  <a href="group__tlx__string.html#ga81809bc5e0b69034f39659303baa4bf9">More...</a><br /></td></tr>
<tr class="separator:ga81809bc5e0b69034f39659303baa4bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Split and Join</h2></td></tr>
<tr class="memitem:gad383d32ace209b51abe936d256d0bb1e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gad383d32ace209b51abe936d256d0bb1e">join</a> (char glue, const std::vector&lt; std::string &gt; &amp;parts)</td></tr>
<tr class="memdesc:gad383d32ace209b51abe936d256d0bb1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a vector of strings by some glue character between each pair from the sequence.  <a href="group__tlx__string.html#gad383d32ace209b51abe936d256d0bb1e">More...</a><br /></td></tr>
<tr class="separator:gad383d32ace209b51abe936d256d0bb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cb20ee53f25c37880faf1b5e5ac3619"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga0cb20ee53f25c37880faf1b5e5ac3619">join</a> (const char *glue, const std::vector&lt; std::string &gt; &amp;parts)</td></tr>
<tr class="memdesc:ga0cb20ee53f25c37880faf1b5e5ac3619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a vector of strings by some glue string between each pair from the sequence.  <a href="group__tlx__string.html#ga0cb20ee53f25c37880faf1b5e5ac3619">More...</a><br /></td></tr>
<tr class="separator:ga0cb20ee53f25c37880faf1b5e5ac3619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga206c170915b483387448714300d311c1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga206c170915b483387448714300d311c1">join</a> (const std::string &amp;glue, const std::vector&lt; std::string &gt; &amp;parts)</td></tr>
<tr class="memdesc:ga206c170915b483387448714300d311c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a vector of strings by some glue string between each pair from the sequence.  <a href="group__tlx__string.html#ga206c170915b483387448714300d311c1">More...</a><br /></td></tr>
<tr class="separator:ga206c170915b483387448714300d311c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1af0448079469f224ea8905c34dc1868"><td class="memTemplParams" colspan="2">template&lt;typename Glue , typename Iterator &gt; </td></tr>
<tr class="memitem:ga1af0448079469f224ea8905c34dc1868"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga1af0448079469f224ea8905c34dc1868">join</a> (Glue glue, Iterator first, Iterator last)</td></tr>
<tr class="memdesc:ga1af0448079469f224ea8905c34dc1868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a sequence of strings by some glue string between each pair from the sequence.  <a href="group__tlx__string.html#ga1af0448079469f224ea8905c34dc1868">More...</a><br /></td></tr>
<tr class="separator:ga1af0448079469f224ea8905c34dc1868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a96227b0edd6c65800124ba1dac82cf"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:ga4a96227b0edd6c65800124ba1dac82cf"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga4a96227b0edd6c65800124ba1dac82cf">join</a> (char glue, const Container &amp;parts)</td></tr>
<tr class="memdesc:ga4a96227b0edd6c65800124ba1dac82cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a Container of strings by some glue character between each pair from the sequence.  <a href="group__tlx__string.html#ga4a96227b0edd6c65800124ba1dac82cf">More...</a><br /></td></tr>
<tr class="separator:ga4a96227b0edd6c65800124ba1dac82cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffea57c0c1e61aa8c9bc50e1ec2f9fe2"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:gaffea57c0c1e61aa8c9bc50e1ec2f9fe2"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gaffea57c0c1e61aa8c9bc50e1ec2f9fe2">join</a> (const char *glue, const Container &amp;parts)</td></tr>
<tr class="memdesc:gaffea57c0c1e61aa8c9bc50e1ec2f9fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a Container of strings by some glue string between each pair from the sequence.  <a href="group__tlx__string.html#gaffea57c0c1e61aa8c9bc50e1ec2f9fe2">More...</a><br /></td></tr>
<tr class="separator:gaffea57c0c1e61aa8c9bc50e1ec2f9fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e35ca12bd4564ba470e3bf4f6a91798"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:ga2e35ca12bd4564ba470e3bf4f6a91798"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga2e35ca12bd4564ba470e3bf4f6a91798">join</a> (const std::string &amp;glue, const Container &amp;parts)</td></tr>
<tr class="memdesc:ga2e35ca12bd4564ba470e3bf4f6a91798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a Container of strings by some glue string between each pair from the sequence.  <a href="group__tlx__string.html#ga2e35ca12bd4564ba470e3bf4f6a91798">More...</a><br /></td></tr>
<tr class="separator:ga2e35ca12bd4564ba470e3bf4f6a91798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabceb162540e1d7f3f6bef9304fdd6ef9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gabceb162540e1d7f3f6bef9304fdd6ef9">join_quoted</a> (const std::vector&lt; std::string &gt; &amp;str, char sep, char quote, char escape)</td></tr>
<tr class="memdesc:gabceb162540e1d7f3f6bef9304fdd6ef9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a vector of strings using a separator character.  <a href="group__tlx__string.html#gabceb162540e1d7f3f6bef9304fdd6ef9">More...</a><br /></td></tr>
<tr class="separator:gabceb162540e1d7f3f6bef9304fdd6ef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga71e61af2f5c2aea97806490bc4e89b17"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga71e61af2f5c2aea97806490bc4e89b17">join_quoted</a> (const std::vector&lt; std::string &gt; &amp;str)</td></tr>
<tr class="memdesc:ga71e61af2f5c2aea97806490bc4e89b17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a vector of strings using spaces as separator character.  <a href="group__tlx__string.html#ga71e61af2f5c2aea97806490bc4e89b17">More...</a><br /></td></tr>
<tr class="separator:ga71e61af2f5c2aea97806490bc4e89b17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fb56b145f00428be03f74257c61f1cc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga4fb56b145f00428be03f74257c61f1cc">split</a> (char sep, const std::string &amp;str, std::string::size_type limit=std::string::npos)</td></tr>
<tr class="memdesc:ga4fb56b145f00428be03f74257c61f1cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator character into distinct substrings.  <a href="group__tlx__string.html#ga4fb56b145f00428be03f74257c61f1cc">More...</a><br /></td></tr>
<tr class="separator:ga4fb56b145f00428be03f74257c61f1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad838882b8fc992742b09450925758b32"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gad838882b8fc992742b09450925758b32">split</a> (const char *sep, const std::string &amp;str, std::string::size_type limit=std::string::npos)</td></tr>
<tr class="memdesc:gad838882b8fc992742b09450925758b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator string into distinct substrings.  <a href="group__tlx__string.html#gad838882b8fc992742b09450925758b32">More...</a><br /></td></tr>
<tr class="separator:gad838882b8fc992742b09450925758b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d57e8e6ac19e94787bf3cd44a79c1fe"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga0d57e8e6ac19e94787bf3cd44a79c1fe">split</a> (const std::string &amp;sep, const std::string &amp;str, std::string::size_type limit=std::string::npos)</td></tr>
<tr class="memdesc:ga0d57e8e6ac19e94787bf3cd44a79c1fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator string into distinct substrings.  <a href="group__tlx__string.html#ga0d57e8e6ac19e94787bf3cd44a79c1fe">More...</a><br /></td></tr>
<tr class="separator:ga0d57e8e6ac19e94787bf3cd44a79c1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00c921a6a793d9c4e59e380b2bb32fca"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga00c921a6a793d9c4e59e380b2bb32fca">split</a> (char sep, const std::string &amp;str, std::string::size_type min_fields, std::string::size_type limit)</td></tr>
<tr class="memdesc:ga00c921a6a793d9c4e59e380b2bb32fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator character into distinct substrings.  <a href="group__tlx__string.html#ga00c921a6a793d9c4e59e380b2bb32fca">More...</a><br /></td></tr>
<tr class="separator:ga00c921a6a793d9c4e59e380b2bb32fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5fb737c26e5fa4d63467b0ded2a1b90"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gac5fb737c26e5fa4d63467b0ded2a1b90">split</a> (const char *sep, const std::string &amp;str, std::string::size_type min_fields, std::string::size_type limit)</td></tr>
<tr class="memdesc:gac5fb737c26e5fa4d63467b0ded2a1b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator string into distinct substrings.  <a href="group__tlx__string.html#gac5fb737c26e5fa4d63467b0ded2a1b90">More...</a><br /></td></tr>
<tr class="separator:gac5fb737c26e5fa4d63467b0ded2a1b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a0a5d581ecd362eaae43bdee50b3896"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga7a0a5d581ecd362eaae43bdee50b3896">split</a> (const std::string &amp;sep, const std::string &amp;str, std::string::size_type min_fields, std::string::size_type limit)</td></tr>
<tr class="memdesc:ga7a0a5d581ecd362eaae43bdee50b3896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator string into distinct substrings.  <a href="group__tlx__string.html#ga7a0a5d581ecd362eaae43bdee50b3896">More...</a><br /></td></tr>
<tr class="separator:ga7a0a5d581ecd362eaae43bdee50b3896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17fd4a3698ca54702b30dddc232bf903"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga17fd4a3698ca54702b30dddc232bf903">split</a> (std::vector&lt; std::string &gt; *into, char sep, const std::string &amp;str, std::string::size_type limit=std::string::npos)</td></tr>
<tr class="memdesc:ga17fd4a3698ca54702b30dddc232bf903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator character into distinct substrings.  <a href="group__tlx__string.html#ga17fd4a3698ca54702b30dddc232bf903">More...</a><br /></td></tr>
<tr class="separator:ga17fd4a3698ca54702b30dddc232bf903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga177a8fd78d5cc4e0fd8dc50810967d89"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga177a8fd78d5cc4e0fd8dc50810967d89">split</a> (std::vector&lt; std::string &gt; *into, const char *sep, const std::string &amp;str, std::string::size_type limit=std::string::npos)</td></tr>
<tr class="memdesc:ga177a8fd78d5cc4e0fd8dc50810967d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator string into distinct substrings.  <a href="group__tlx__string.html#ga177a8fd78d5cc4e0fd8dc50810967d89">More...</a><br /></td></tr>
<tr class="separator:ga177a8fd78d5cc4e0fd8dc50810967d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga431c048d40a30f531e2e419e26582e4c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga431c048d40a30f531e2e419e26582e4c">split</a> (std::vector&lt; std::string &gt; *into, const std::string &amp;sep, const std::string &amp;str, std::string::size_type limit=std::string::npos)</td></tr>
<tr class="memdesc:ga431c048d40a30f531e2e419e26582e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator string into distinct substrings.  <a href="group__tlx__string.html#ga431c048d40a30f531e2e419e26582e4c">More...</a><br /></td></tr>
<tr class="separator:ga431c048d40a30f531e2e419e26582e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4997fcbeb1c6a97d23bce8ea590b3ce3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga4997fcbeb1c6a97d23bce8ea590b3ce3">split</a> (std::vector&lt; std::string &gt; *into, char sep, const std::string &amp;str, std::string::size_type min_fields, std::string::size_type limit)</td></tr>
<tr class="memdesc:ga4997fcbeb1c6a97d23bce8ea590b3ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator character into distinct substrings.  <a href="group__tlx__string.html#ga4997fcbeb1c6a97d23bce8ea590b3ce3">More...</a><br /></td></tr>
<tr class="separator:ga4997fcbeb1c6a97d23bce8ea590b3ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40222e4ae7f552a3d6f8d485ced3d91d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga40222e4ae7f552a3d6f8d485ced3d91d">split</a> (std::vector&lt; std::string &gt; *into, const char *sep, const std::string &amp;str, std::string::size_type min_fields, std::string::size_type limit)</td></tr>
<tr class="memdesc:ga40222e4ae7f552a3d6f8d485ced3d91d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator string into distinct substrings.  <a href="group__tlx__string.html#ga40222e4ae7f552a3d6f8d485ced3d91d">More...</a><br /></td></tr>
<tr class="separator:ga40222e4ae7f552a3d6f8d485ced3d91d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4aa7e0fb9bd81e31214087d3d85367a3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga4aa7e0fb9bd81e31214087d3d85367a3">split</a> (std::vector&lt; std::string &gt; *into, const std::string &amp;sep, const std::string &amp;str, std::string::size_type min_fields, std::string::size_type limit)</td></tr>
<tr class="memdesc:ga4aa7e0fb9bd81e31214087d3d85367a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator string into distinct substrings.  <a href="group__tlx__string.html#ga4aa7e0fb9bd81e31214087d3d85367a3">More...</a><br /></td></tr>
<tr class="separator:ga4aa7e0fb9bd81e31214087d3d85367a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafc48ce717ba77df6c6f395fb07bc8a1e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gafc48ce717ba77df6c6f395fb07bc8a1e">split_quoted</a> (const std::string &amp;str, char sep, char quote, char escape)</td></tr>
<tr class="memdesc:gafc48ce717ba77df6c6f395fb07bc8a1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator character into distinct substrings.  <a href="group__tlx__string.html#gafc48ce717ba77df6c6f395fb07bc8a1e">More...</a><br /></td></tr>
<tr class="separator:gafc48ce717ba77df6c6f395fb07bc8a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0210d995cdc4df9aafcd09c005571449"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga0210d995cdc4df9aafcd09c005571449">split_quoted</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga0210d995cdc4df9aafcd09c005571449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each space into distinct substrings.  <a href="group__tlx__string.html#ga0210d995cdc4df9aafcd09c005571449">More...</a><br /></td></tr>
<tr class="separator:ga0210d995cdc4df9aafcd09c005571449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c9fac87ddaeb902c500f4854af69bec"><td class="memTemplParams" colspan="2">template&lt;typename Functor &gt; </td></tr>
<tr class="memitem:ga6c9fac87ddaeb902c500f4854af69bec"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga6c9fac87ddaeb902c500f4854af69bec">split_view</a> (char sep, const std::string &amp;str, Functor &amp;&amp;callback, std::string::size_type limit=std::string::npos)</td></tr>
<tr class="memdesc:ga6c9fac87ddaeb902c500f4854af69bec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator character into distinct substrings, and call the given callback with a <a class="el" href="classtlx_1_1StringView.html" title="StringView is a reference to a part of a string, consisting of only a char pointer and a length...">StringView</a> for each substring.  <a href="group__tlx__string.html#ga6c9fac87ddaeb902c500f4854af69bec">More...</a><br /></td></tr>
<tr class="separator:ga6c9fac87ddaeb902c500f4854af69bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Search and Replace</h2></td></tr>
<tr class="memitem:gaca0aeb9a74105ec849e939229d47970b"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gaca0aeb9a74105ec849e939229d47970b">replace_first</a> (std::string *str, const std::string &amp;needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:gaca0aeb9a74105ec849e939229d47970b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="group__tlx__string.html#gaca0aeb9a74105ec849e939229d47970b">More...</a><br /></td></tr>
<tr class="separator:gaca0aeb9a74105ec849e939229d47970b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32d2a706e20d6e5b07cbb677c340deba"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga32d2a706e20d6e5b07cbb677c340deba">replace_first</a> (std::string *str, const std::string &amp;needle, const char *instead)</td></tr>
<tr class="memdesc:ga32d2a706e20d6e5b07cbb677c340deba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="group__tlx__string.html#ga32d2a706e20d6e5b07cbb677c340deba">More...</a><br /></td></tr>
<tr class="separator:ga32d2a706e20d6e5b07cbb677c340deba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2b83d93d49145437aec2964f30e4cd1"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gab2b83d93d49145437aec2964f30e4cd1">replace_first</a> (std::string *str, const char *needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:gab2b83d93d49145437aec2964f30e4cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="group__tlx__string.html#gab2b83d93d49145437aec2964f30e4cd1">More...</a><br /></td></tr>
<tr class="separator:gab2b83d93d49145437aec2964f30e4cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ed49bc3eebffeefeff05f84ffbcc086"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga6ed49bc3eebffeefeff05f84ffbcc086">replace_first</a> (std::string *str, const char *needle, const char *instead)</td></tr>
<tr class="memdesc:ga6ed49bc3eebffeefeff05f84ffbcc086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="group__tlx__string.html#ga6ed49bc3eebffeefeff05f84ffbcc086">More...</a><br /></td></tr>
<tr class="separator:ga6ed49bc3eebffeefeff05f84ffbcc086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4865798a465a43845804dda0fe21f888"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga4865798a465a43845804dda0fe21f888">replace_first</a> (std::string *str, char needle, char instead)</td></tr>
<tr class="memdesc:ga4865798a465a43845804dda0fe21f888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="group__tlx__string.html#ga4865798a465a43845804dda0fe21f888">More...</a><br /></td></tr>
<tr class="separator:ga4865798a465a43845804dda0fe21f888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b0092a333e84d0c4eaae50955bc5a71"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga8b0092a333e84d0c4eaae50955bc5a71">replace_first</a> (const std::string &amp;str, const std::string &amp;needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:ga8b0092a333e84d0c4eaae50955bc5a71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="group__tlx__string.html#ga8b0092a333e84d0c4eaae50955bc5a71">More...</a><br /></td></tr>
<tr class="separator:ga8b0092a333e84d0c4eaae50955bc5a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6b1e9aa3d513c96cd5973e50551d6b5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gab6b1e9aa3d513c96cd5973e50551d6b5">replace_first</a> (const std::string &amp;str, const std::string &amp;needle, const char *instead)</td></tr>
<tr class="memdesc:gab6b1e9aa3d513c96cd5973e50551d6b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="group__tlx__string.html#gab6b1e9aa3d513c96cd5973e50551d6b5">More...</a><br /></td></tr>
<tr class="separator:gab6b1e9aa3d513c96cd5973e50551d6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7e6db7b1dfe54efc4b195f27df5ed71"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gae7e6db7b1dfe54efc4b195f27df5ed71">replace_first</a> (const std::string &amp;str, const char *needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:gae7e6db7b1dfe54efc4b195f27df5ed71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="group__tlx__string.html#gae7e6db7b1dfe54efc4b195f27df5ed71">More...</a><br /></td></tr>
<tr class="separator:gae7e6db7b1dfe54efc4b195f27df5ed71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga711f2f36ac6d9cb35a6a63672e47a47c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga711f2f36ac6d9cb35a6a63672e47a47c">replace_first</a> (const std::string &amp;str, const char *needle, const char *instead)</td></tr>
<tr class="memdesc:ga711f2f36ac6d9cb35a6a63672e47a47c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="group__tlx__string.html#ga711f2f36ac6d9cb35a6a63672e47a47c">More...</a><br /></td></tr>
<tr class="separator:ga711f2f36ac6d9cb35a6a63672e47a47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga276e1110c0ea48a01ef5a84f8ff40f37"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga276e1110c0ea48a01ef5a84f8ff40f37">replace_first</a> (const std::string &amp;str, char needle, char instead)</td></tr>
<tr class="memdesc:ga276e1110c0ea48a01ef5a84f8ff40f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="group__tlx__string.html#ga276e1110c0ea48a01ef5a84f8ff40f37">More...</a><br /></td></tr>
<tr class="separator:ga276e1110c0ea48a01ef5a84f8ff40f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7021d36930f4bd434b2082dce8bd43cf"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga7021d36930f4bd434b2082dce8bd43cf">replace_all</a> (std::string *str, const std::string &amp;needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:ga7021d36930f4bd434b2082dce8bd43cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="group__tlx__string.html#ga7021d36930f4bd434b2082dce8bd43cf">More...</a><br /></td></tr>
<tr class="separator:ga7021d36930f4bd434b2082dce8bd43cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd5bd9f9a887fa20b4a8ebaf987fd5de"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gadd5bd9f9a887fa20b4a8ebaf987fd5de">replace_all</a> (std::string *str, const std::string &amp;needle, const char *instead)</td></tr>
<tr class="memdesc:gadd5bd9f9a887fa20b4a8ebaf987fd5de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="group__tlx__string.html#gadd5bd9f9a887fa20b4a8ebaf987fd5de">More...</a><br /></td></tr>
<tr class="separator:gadd5bd9f9a887fa20b4a8ebaf987fd5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b4b8117690af529b7051a3c10c382ff"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga6b4b8117690af529b7051a3c10c382ff">replace_all</a> (std::string *str, const char *needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:ga6b4b8117690af529b7051a3c10c382ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="group__tlx__string.html#ga6b4b8117690af529b7051a3c10c382ff">More...</a><br /></td></tr>
<tr class="separator:ga6b4b8117690af529b7051a3c10c382ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d7d14badd05473e5a5c847b3f91b9e9"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga0d7d14badd05473e5a5c847b3f91b9e9">replace_all</a> (std::string *str, const char *needle, const char *instead)</td></tr>
<tr class="memdesc:ga0d7d14badd05473e5a5c847b3f91b9e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="group__tlx__string.html#ga0d7d14badd05473e5a5c847b3f91b9e9">More...</a><br /></td></tr>
<tr class="separator:ga0d7d14badd05473e5a5c847b3f91b9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga768d59e5cc6d2c91f25a441ab4d265a6"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga768d59e5cc6d2c91f25a441ab4d265a6">replace_all</a> (std::string *str, char needle, char instead)</td></tr>
<tr class="memdesc:ga768d59e5cc6d2c91f25a441ab4d265a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="group__tlx__string.html#ga768d59e5cc6d2c91f25a441ab4d265a6">More...</a><br /></td></tr>
<tr class="separator:ga768d59e5cc6d2c91f25a441ab4d265a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac001aff0fa6c3bee2e9755e3ddd516f9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gac001aff0fa6c3bee2e9755e3ddd516f9">replace_all</a> (const std::string &amp;str, const std::string &amp;needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:gac001aff0fa6c3bee2e9755e3ddd516f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="group__tlx__string.html#gac001aff0fa6c3bee2e9755e3ddd516f9">More...</a><br /></td></tr>
<tr class="separator:gac001aff0fa6c3bee2e9755e3ddd516f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfe9c066393585d1a769cbd55e9f9960"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gadfe9c066393585d1a769cbd55e9f9960">replace_all</a> (const std::string &amp;str, const std::string &amp;needle, const char *instead)</td></tr>
<tr class="memdesc:gadfe9c066393585d1a769cbd55e9f9960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="group__tlx__string.html#gadfe9c066393585d1a769cbd55e9f9960">More...</a><br /></td></tr>
<tr class="separator:gadfe9c066393585d1a769cbd55e9f9960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e3b406ea495a236fff401c3585d8814"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga4e3b406ea495a236fff401c3585d8814">replace_all</a> (const std::string &amp;str, const char *needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:ga4e3b406ea495a236fff401c3585d8814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="group__tlx__string.html#ga4e3b406ea495a236fff401c3585d8814">More...</a><br /></td></tr>
<tr class="separator:ga4e3b406ea495a236fff401c3585d8814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14cfa75fa579e1d4943855455d9e605d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga14cfa75fa579e1d4943855455d9e605d">replace_all</a> (const std::string &amp;str, const char *needle, const char *instead)</td></tr>
<tr class="memdesc:ga14cfa75fa579e1d4943855455d9e605d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="group__tlx__string.html#ga14cfa75fa579e1d4943855455d9e605d">More...</a><br /></td></tr>
<tr class="separator:ga14cfa75fa579e1d4943855455d9e605d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae87b40ae8e461c110fffcb7a12b066d5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gae87b40ae8e461c110fffcb7a12b066d5">replace_all</a> (const std::string &amp;str, char needle, char instead)</td></tr>
<tr class="memdesc:gae87b40ae8e461c110fffcb7a12b066d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="group__tlx__string.html#gae87b40ae8e461c110fffcb7a12b066d5">More...</a><br /></td></tr>
<tr class="separator:gae87b40ae8e461c110fffcb7a12b066d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Trim</h2></td></tr>
<tr class="memitem:gac44946abf6c2e869d57d1ce3d2c9a7e8"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gac44946abf6c2e869d57d1ce3d2c9a7e8">trim</a> (std::string *str)</td></tr>
<tr class="memdesc:gac44946abf6c2e869d57d1ce3d2c9a7e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place on the left and right.  <a href="group__tlx__string.html#gac44946abf6c2e869d57d1ce3d2c9a7e8">More...</a><br /></td></tr>
<tr class="separator:gac44946abf6c2e869d57d1ce3d2c9a7e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga033f3fec1db85f0203f9f33ef0cfe271"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga033f3fec1db85f0203f9f33ef0cfe271">trim</a> (std::string *str, const char *drop)</td></tr>
<tr class="memdesc:ga033f3fec1db85f0203f9f33ef0cfe271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place on the left and right.  <a href="group__tlx__string.html#ga033f3fec1db85f0203f9f33ef0cfe271">More...</a><br /></td></tr>
<tr class="separator:ga033f3fec1db85f0203f9f33ef0cfe271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f5067eb83515704232300be374b2857"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga9f5067eb83515704232300be374b2857">trim</a> (std::string *str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:ga9f5067eb83515704232300be374b2857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place on the left and right.  <a href="group__tlx__string.html#ga9f5067eb83515704232300be374b2857">More...</a><br /></td></tr>
<tr class="separator:ga9f5067eb83515704232300be374b2857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5a01f705cc7b4a7317a57f6bf41aef25"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga5a01f705cc7b4a7317a57f6bf41aef25">trim</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga5a01f705cc7b4a7317a57f6bf41aef25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place on the left and right.  <a href="group__tlx__string.html#ga5a01f705cc7b4a7317a57f6bf41aef25">More...</a><br /></td></tr>
<tr class="separator:ga5a01f705cc7b4a7317a57f6bf41aef25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadf066d809b088ceda29675da3420c3c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gaadf066d809b088ceda29675da3420c3c">trim</a> (const std::string &amp;str, const char *drop)</td></tr>
<tr class="memdesc:gaadf066d809b088ceda29675da3420c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place on the left and right.  <a href="group__tlx__string.html#gaadf066d809b088ceda29675da3420c3c">More...</a><br /></td></tr>
<tr class="separator:gaadf066d809b088ceda29675da3420c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7aacbd967bfb76fcb4b4d977b4f5d838"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga7aacbd967bfb76fcb4b4d977b4f5d838">trim</a> (const std::string &amp;str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:ga7aacbd967bfb76fcb4b4d977b4f5d838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place on the left and right.  <a href="group__tlx__string.html#ga7aacbd967bfb76fcb4b4d977b4f5d838">More...</a><br /></td></tr>
<tr class="separator:ga7aacbd967bfb76fcb4b4d977b4f5d838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga387d6e51cf1f77b7ac7111e8f0ed7d48"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga387d6e51cf1f77b7ac7111e8f0ed7d48">trim_right</a> (std::string *str)</td></tr>
<tr class="memdesc:ga387d6e51cf1f77b7ac7111e8f0ed7d48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place only on the right.  <a href="group__tlx__string.html#ga387d6e51cf1f77b7ac7111e8f0ed7d48">More...</a><br /></td></tr>
<tr class="separator:ga387d6e51cf1f77b7ac7111e8f0ed7d48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1480a3758759216e8206fc9bbb58c0da"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga1480a3758759216e8206fc9bbb58c0da">trim_right</a> (std::string *str, const char *drop)</td></tr>
<tr class="memdesc:ga1480a3758759216e8206fc9bbb58c0da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place only on the right.  <a href="group__tlx__string.html#ga1480a3758759216e8206fc9bbb58c0da">More...</a><br /></td></tr>
<tr class="separator:ga1480a3758759216e8206fc9bbb58c0da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff5e9a8a1501b420ae5a5f8eca2a2f01"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gaff5e9a8a1501b420ae5a5f8eca2a2f01">trim_right</a> (std::string *str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:gaff5e9a8a1501b420ae5a5f8eca2a2f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place only on the right.  <a href="group__tlx__string.html#gaff5e9a8a1501b420ae5a5f8eca2a2f01">More...</a><br /></td></tr>
<tr class="separator:gaff5e9a8a1501b420ae5a5f8eca2a2f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fb8db490eae39cfd9819b407e8655ee"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga9fb8db490eae39cfd9819b407e8655ee">trim_right</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga9fb8db490eae39cfd9819b407e8655ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string only on the right.  <a href="group__tlx__string.html#ga9fb8db490eae39cfd9819b407e8655ee">More...</a><br /></td></tr>
<tr class="separator:ga9fb8db490eae39cfd9819b407e8655ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga232bc2341b09eea7c6229b7b548f4f8f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga232bc2341b09eea7c6229b7b548f4f8f">trim_right</a> (const std::string &amp;str, const char *drop)</td></tr>
<tr class="memdesc:ga232bc2341b09eea7c6229b7b548f4f8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string only on the right.  <a href="group__tlx__string.html#ga232bc2341b09eea7c6229b7b548f4f8f">More...</a><br /></td></tr>
<tr class="separator:ga232bc2341b09eea7c6229b7b548f4f8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b761b3a20c3f400f4f3451511016a07"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga4b761b3a20c3f400f4f3451511016a07">trim_right</a> (const std::string &amp;str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:ga4b761b3a20c3f400f4f3451511016a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string only on the right.  <a href="group__tlx__string.html#ga4b761b3a20c3f400f4f3451511016a07">More...</a><br /></td></tr>
<tr class="separator:ga4b761b3a20c3f400f4f3451511016a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd01f5ea03e1d4a21ee26d2f3e20206f"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#gacd01f5ea03e1d4a21ee26d2f3e20206f">trim_left</a> (std::string *str)</td></tr>
<tr class="memdesc:gacd01f5ea03e1d4a21ee26d2f3e20206f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place only on the left.  <a href="group__tlx__string.html#gacd01f5ea03e1d4a21ee26d2f3e20206f">More...</a><br /></td></tr>
<tr class="separator:gacd01f5ea03e1d4a21ee26d2f3e20206f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga059d265ada554d8653d877a28d4d518d"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga059d265ada554d8653d877a28d4d518d">trim_left</a> (std::string *str, const char *drop)</td></tr>
<tr class="memdesc:ga059d265ada554d8653d877a28d4d518d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place only on the left.  <a href="group__tlx__string.html#ga059d265ada554d8653d877a28d4d518d">More...</a><br /></td></tr>
<tr class="separator:ga059d265ada554d8653d877a28d4d518d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9db0b1db4ab3774221363c2fafa8bbdf"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga9db0b1db4ab3774221363c2fafa8bbdf">trim_left</a> (std::string *str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:ga9db0b1db4ab3774221363c2fafa8bbdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place only on the left.  <a href="group__tlx__string.html#ga9db0b1db4ab3774221363c2fafa8bbdf">More...</a><br /></td></tr>
<tr class="separator:ga9db0b1db4ab3774221363c2fafa8bbdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58107ce115061cb45873f46778bfe836"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga58107ce115061cb45873f46778bfe836">trim_left</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga58107ce115061cb45873f46778bfe836"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string only on the left.  <a href="group__tlx__string.html#ga58107ce115061cb45873f46778bfe836">More...</a><br /></td></tr>
<tr class="separator:ga58107ce115061cb45873f46778bfe836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1bc881fad43aa1c573d47d459ed2a721"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga1bc881fad43aa1c573d47d459ed2a721">trim_left</a> (const std::string &amp;str, const char *drop)</td></tr>
<tr class="memdesc:ga1bc881fad43aa1c573d47d459ed2a721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string only on the left.  <a href="group__tlx__string.html#ga1bc881fad43aa1c573d47d459ed2a721">More...</a><br /></td></tr>
<tr class="separator:ga1bc881fad43aa1c573d47d459ed2a721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f870dbf0b1602d063de42caefde8b68"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__string.html#ga9f870dbf0b1602d063de42caefde8b68">trim_left</a> (const std::string &amp;str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:ga9f870dbf0b1602d063de42caefde8b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string only on the left.  <a href="group__tlx__string.html#ga9f870dbf0b1602d063de42caefde8b68">More...</a><br /></td></tr>
<tr class="separator:ga9f870dbf0b1602d063de42caefde8b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Simple string manipulations </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga7de31bec5774af4c0a81b579dd87be53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7de31bec5774af4c0a81b579dd87be53">&#9670;&nbsp;</a></span>appendline()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; appendline </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>delim</em> = <code>'\n'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>like std::getline(istream, string, delim) except that it appends to the string, possibly reusing buffer capacity. </p>

<p class="definition">Definition at line <a class="el" href="appendline_8cpp_source.html#l00017">17</a> of file <a class="el" href="appendline_8cpp_source.html">appendline.cpp</a>.</p>

<p class="reference">References <a class="el" href="extlib_2foxxll_2foxxll_2common_2uint__types_8hpp_source.html#l00226">max()</a>.</p>

</div>
</div>
<a id="gac2775fbea220f27325aba0f8af1cc9a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2775fbea220f27325aba0f8af1cc9a8">&#9670;&nbsp;</a></span>base64_decode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string base64_decode </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a string in base64 representation as described in RFC 2045 or RFC 3548 and return the original data. </p>
<p>If a non-whitespace invalid base64 character is encountered <em>and</em> the parameter "strict" is true, then this function will throw a std::runtime_error. If "strict" is false, the character is silently ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>input data to decode </td></tr>
    <tr><td class="paramname">size</td><td>size of input data to decode </td></tr>
    <tr><td class="paramname">strict</td><td>throw exception on invalid character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>decoded binary data </dd></dl>

<p class="definition">Definition at line <a class="el" href="base64_8cpp_source.html#l00108">108</a> of file <a class="el" href="base64_8cpp_source.html">base64.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="base64_8cpp_source.html#l00203">tlx::base64_decode()</a>.</p>

</div>
</div>
<a id="gabe1e973cd3a2d5b7e55544d4c616da49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe1e973cd3a2d5b7e55544d4c616da49">&#9670;&nbsp;</a></span>base64_decode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string base64_decode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a string in base64 representation as described in RFC 2045 or RFC 3548 and return the original data. </p>
<p>If a non-whitespace invalid base64 character is encountered <em>and</em> the parameter "strict" is true, then this function will throw a std::runtime_error. If "strict" is false, the character is silently ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>input string to encode </td></tr>
    <tr><td class="paramname">strict</td><td>throw exception on invalid character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>decoded binary data </dd></dl>

<p class="definition">Definition at line <a class="el" href="base64_8cpp_source.html#l00203">203</a> of file <a class="el" href="base64_8cpp_source.html">base64.cpp</a>.</p>

<p class="reference">References <a class="el" href="base64_8cpp_source.html#l00108">tlx::base64_decode()</a>.</p>

</div>
</div>
<a id="ga691477f59c8496eec65e994ce3f6e6e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga691477f59c8496eec65e994ce3f6e6e5">&#9670;&nbsp;</a></span>base64_encode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string base64_encode </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>line_break</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode the given binary data into base64 representation as described in RFC 2045 or RFC 3548. </p>
<p>The output string contains only characters [A-Za-z0-9+/] and is roughly 33% longer than the input. The output string can be broken into lines after n characters, where n must be a multiple of 4.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>input data to encode </td></tr>
    <tr><td class="paramname">size</td><td>size of input data to encode </td></tr>
    <tr><td class="paramname">line_break</td><td>break the output string every n characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>base64 encoded string </dd></dl>

<p class="definition">Definition at line <a class="el" href="base64_8cpp_source.html#l00025">25</a> of file <a class="el" href="base64_8cpp_source.html">base64.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="base64_8cpp_source.html#l00102">tlx::base64_encode()</a>.</p>

</div>
</div>
<a id="ga16a12f591febaeddffd2ffca031c8bf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga16a12f591febaeddffd2ffca031c8bf4">&#9670;&nbsp;</a></span>base64_encode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string base64_encode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>line_break</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode the given binary string into base64 representation as described in RFC 2045 or RFC 3548. </p>
<p>The output string contains only characters [A-Za-z0-9+/] and is roughly 33% longer than the input. The output string can be broken into lines after n characters, where n must be a multiple of 4.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>input string to encode </td></tr>
    <tr><td class="paramname">line_break</td><td>break the output string every n characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>base64 encoded string </dd></dl>

<p class="definition">Definition at line <a class="el" href="base64_8cpp_source.html#l00102">102</a> of file <a class="el" href="base64_8cpp_source.html">base64.cpp</a>.</p>

<p class="reference">References <a class="el" href="base64_8cpp_source.html#l00025">tlx::base64_encode()</a>.</p>

</div>
</div>
<a id="gacfad4094f21f5a7ee748330d56764c13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfad4094f21f5a7ee748330d56764c13">&#9670;&nbsp;</a></span>bitdump_be8() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string bitdump_be8 </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a (binary) string as a sequence of 8-bit big-endian bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>binary data to output as bits </td></tr>
    <tr><td class="paramname">size</td><td>length of binary data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of binary digits </dd></dl>

<p class="definition">Definition at line <a class="el" href="bitdump_8cpp_source.html#l00051">51</a> of file <a class="el" href="bitdump_8cpp_source.html">bitdump.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="bitdump_8cpp_source.html#l00077">tlx::bitdump_be8()</a>, <a class="el" href="bitdump_8hpp_source.html#l00081">tlx::bitdump_be8_type()</a>, and <a class="el" href="bitdump_8hpp_source.html#l00051">tlx::bitdump_le8_type()</a>.</p>

</div>
</div>
<a id="ga05d04f64b0d1ec8b2277b2236106e3b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05d04f64b0d1ec8b2277b2236106e3b4">&#9670;&nbsp;</a></span>bitdump_be8() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string bitdump_be8 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a (binary) string as a sequence of 8-bit big-endian bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>binary data to output as bits </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of binary digits </dd></dl>

<p class="definition">Definition at line <a class="el" href="bitdump_8cpp_source.html#l00077">77</a> of file <a class="el" href="bitdump_8cpp_source.html">bitdump.cpp</a>.</p>

<p class="reference">References <a class="el" href="bitdump_8cpp_source.html#l00051">tlx::bitdump_be8()</a>.</p>

</div>
</div>
<a id="gae0fea123d8861a6d2c11c746741dd524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae0fea123d8861a6d2c11c746741dd524">&#9670;&nbsp;</a></span>bitdump_be8_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::bitdump_be8_type </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a (binary) item as a sequence of 8-bit big-endian bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>binary data to output as bits </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of binary digits </dd></dl>

<p class="definition">Definition at line <a class="el" href="bitdump_8hpp_source.html#l00081">81</a> of file <a class="el" href="bitdump_8hpp_source.html">bitdump.hpp</a>.</p>

<p class="reference">References <a class="el" href="bitdump_8cpp_source.html#l00051">tlx::bitdump_be8()</a>.</p>

</div>
</div>
<a id="ga00c0a01f04e50e69dadc483dee4b7b08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00c0a01f04e50e69dadc483dee4b7b08">&#9670;&nbsp;</a></span>bitdump_le8() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string bitdump_le8 </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a (binary) string as a sequence of 8-bit little-endian bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>binary data to output as bits </td></tr>
    <tr><td class="paramname">size</td><td>length of binary data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of binary digits </dd></dl>

<p class="definition">Definition at line <a class="el" href="bitdump_8cpp_source.html#l00018">18</a> of file <a class="el" href="bitdump_8cpp_source.html">bitdump.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="bitdump_8cpp_source.html#l00044">tlx::bitdump_le8()</a>, and <a class="el" href="bitdump_8hpp_source.html#l00051">tlx::bitdump_le8_type()</a>.</p>

</div>
</div>
<a id="gae6d05a55439476040242e61a1474b9b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6d05a55439476040242e61a1474b9b9">&#9670;&nbsp;</a></span>bitdump_le8() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string bitdump_le8 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a (binary) string as a sequence of 8-bit little-endian bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>binary data to output as bits </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of binary digits </dd></dl>

<p class="definition">Definition at line <a class="el" href="bitdump_8cpp_source.html#l00044">44</a> of file <a class="el" href="bitdump_8cpp_source.html">bitdump.cpp</a>.</p>

<p class="reference">References <a class="el" href="bitdump_8cpp_source.html#l00018">tlx::bitdump_le8()</a>.</p>

</div>
</div>
<a id="gacfc711557532d311aa3ced8de036f623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacfc711557532d311aa3ced8de036f623">&#9670;&nbsp;</a></span>bitdump_le8_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::bitdump_le8_type </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a (binary) item as a sequence of 8-bit little-endian bytes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>binary data to output as bits </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of binary digits </dd></dl>

<p class="definition">Definition at line <a class="el" href="bitdump_8hpp_source.html#l00051">51</a> of file <a class="el" href="bitdump_8hpp_source.html">bitdump.hpp</a>.</p>

<p class="reference">References <a class="el" href="bitdump_8cpp_source.html#l00051">tlx::bitdump_be8()</a>, and <a class="el" href="bitdump_8cpp_source.html#l00018">tlx::bitdump_le8()</a>.</p>

</div>
</div>
<a id="ga7a87b7f6120ebcde0c01ad293465f9d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a87b7f6120ebcde0c01ad293465f9d7">&#9670;&nbsp;</a></span>compare_icase() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int compare_icase </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns +1/0/-1 like strcmp(a, b) but without regard for letter case </p>

<p class="definition">Definition at line <a class="el" href="compare__icase_8cpp_source.html#l00018">18</a> of file <a class="el" href="compare__icase_8cpp_source.html">compare_icase.cpp</a>.</p>

<p class="reference">References <a class="el" href="to__lower_8cpp_source.html#l00017">tlx::to_lower()</a>.</p>

</div>
</div>
<a id="ga061e7b66eb332d7621ef99d11b724c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga061e7b66eb332d7621ef99d11b724c16">&#9670;&nbsp;</a></span>compare_icase() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int compare_icase </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns +1/0/-1 like strcmp(a, b) but without regard for letter case </p>

<p class="definition">Definition at line <a class="el" href="compare__icase_8cpp_source.html#l00035">35</a> of file <a class="el" href="compare__icase_8cpp_source.html">compare_icase.cpp</a>.</p>

<p class="reference">References <a class="el" href="to__lower_8cpp_source.html#l00017">tlx::to_lower()</a>.</p>

</div>
</div>
<a id="gad6b99f43a01b6d2ff8ca49f4518297b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6b99f43a01b6d2ff8ca49f4518297b9">&#9670;&nbsp;</a></span>compare_icase() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int compare_icase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns +1/0/-1 like strcmp(a, b) but without regard for letter case </p>

<p class="definition">Definition at line <a class="el" href="compare__icase_8cpp_source.html#l00054">54</a> of file <a class="el" href="compare__icase_8cpp_source.html">compare_icase.cpp</a>.</p>

<p class="reference">References <a class="el" href="to__lower_8cpp_source.html#l00017">tlx::to_lower()</a>.</p>

</div>
</div>
<a id="ga988bb20efc727413da0a9d9d11f488b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga988bb20efc727413da0a9d9d11f488b0">&#9670;&nbsp;</a></span>compare_icase() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int compare_icase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns +1/0/-1 like strcmp(a, b) but without regard for letter case </p>

<p class="definition">Definition at line <a class="el" href="compare__icase_8cpp_source.html#l00072">72</a> of file <a class="el" href="compare__icase_8cpp_source.html">compare_icase.cpp</a>.</p>

<p class="reference">References <a class="el" href="to__lower_8cpp_source.html#l00017">tlx::to_lower()</a>.</p>

</div>
</div>
<a id="ga7ff92619b9a2ae3dbbdd6ef511c1779e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7ff92619b9a2ae3dbbdd6ef511c1779e">&#9670;&nbsp;</a></span>contains() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool contains </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests of string contains pattern. </p>

<p class="definition">Definition at line <a class="el" href="contains_8cpp_source.html#l00015">15</a> of file <a class="el" href="contains_8cpp_source.html">contains.cpp</a>.</p>

</div>
</div>
<a id="ga399719274798a8a808e8e309ab490f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga399719274798a8a808e8e309ab490f03">&#9670;&nbsp;</a></span>contains() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool contains </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests of string contains pattern. </p>

<p class="definition">Definition at line <a class="el" href="contains_8cpp_source.html#l00019">19</a> of file <a class="el" href="contains_8cpp_source.html">contains.cpp</a>.</p>

</div>
</div>
<a id="ga8d6aca56ee9463cd116fc8e065c4c3a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d6aca56ee9463cd116fc8e065c4c3a0">&#9670;&nbsp;</a></span>contains() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool contains </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests of string contains character. </p>

<p class="definition">Definition at line <a class="el" href="contains_8cpp_source.html#l00023">23</a> of file <a class="el" href="contains_8cpp_source.html">contains.cpp</a>.</p>

</div>
</div>
<a id="ga2fd07edea7502e13dbc9d2991be95f02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2fd07edea7502e13dbc9d2991be95f02">&#9670;&nbsp;</a></span>contains_word() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool contains_word </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>word</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search the given string for a whitespace-delimited word. </p>
<p>It works as if the str was <a class="el" href="group__tlx__string.html#ga92d58b1e8b06cbb57400b5959281a4a1" title="Split the given string by whitespaces into distinct words. ">split_words()</a> and the resulting vector checked for a given word. However this function does not create a vector, it scans the string directly. Whitespace is space, tab, newline or carriage-return.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>whitespace-delimited string to check </td></tr>
    <tr><td class="paramname">word</td><td>word to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the word was found </dd></dl>

<p class="definition">Definition at line <a class="el" href="contains__word_8cpp_source.html#l00019">19</a> of file <a class="el" href="contains__word_8cpp_source.html">contains_word.cpp</a>.</p>

<p class="reference">References <a class="el" href="contains__word_8cpp_source.html#l00015">tlx::is_white()</a>.</p>

<p class="reference">Referenced by <a class="el" href="union__words_8cpp_source.html#l00016">tlx::union_words()</a>.</p>

</div>
</div>
<a id="ga7f7b2444597941650e05c1bb96b04f45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f7b2444597941650e05c1bb96b04f45">&#9670;&nbsp;</a></span>contains_word() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool contains_word </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>word</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search the given string for a whitespace-delimited word. </p>
<p>It works as if the str was <a class="el" href="group__tlx__string.html#ga92d58b1e8b06cbb57400b5959281a4a1" title="Split the given string by whitespaces into distinct words. ">split_words()</a> and the resulting vector checked for a given word. However this function does not create a vector, it scans the string directly. Whitespace is space, tab, newline or carriage-return.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>whitespace-delimited string to check </td></tr>
    <tr><td class="paramname">word</td><td>word to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the word was found </dd></dl>

<p class="definition">Definition at line <a class="el" href="contains__word_8cpp_source.html#l00055">55</a> of file <a class="el" href="contains__word_8cpp_source.html">contains_word.cpp</a>.</p>

<p class="reference">References <a class="el" href="contains__word_8cpp_source.html#l00015">tlx::is_white()</a>.</p>

</div>
</div>
<a id="ga2395fc6f1f7427bda18323fd38ffa1f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2395fc6f1f7427bda18323fd38ffa1f7">&#9670;&nbsp;</a></span>ends_with() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ends_with </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given match string is located at the end of this string. </p>

<p class="definition">Definition at line <a class="el" href="ends__with_8cpp_source.html#l00022">22</a> of file <a class="el" href="ends__with_8cpp_source.html">ends_with.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="file__io_8cpp_source.html#l00047">thrill::vfs::IsCompressed()</a>, <a class="el" href="file__io_8cpp_source.html#l00180">thrill::vfs::OpenReadStream()</a>, <a class="el" href="file__io_8cpp_source.html#l00211">thrill::vfs::OpenWriteStream()</a>, <a class="el" href="sys__file_8cpp_source.html#l00323">thrill::vfs::SysOpenReadStream()</a>, and <a class="el" href="sys__file_8cpp_source.html#l00414">thrill::vfs::SysOpenWriteStream()</a>.</p>

</div>
</div>
<a id="ga60cf87567ef6acda6704064cf994b441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60cf87567ef6acda6704064cf994b441">&#9670;&nbsp;</a></span>ends_with() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ends_with </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given match string is located at the end of this string. </p>

<p class="definition">Definition at line <a class="el" href="ends__with_8cpp_source.html#l00038">38</a> of file <a class="el" href="ends__with_8cpp_source.html">ends_with.cpp</a>.</p>

</div>
</div>
<a id="gacea7b710bca17bae104e7e5eb6137fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacea7b710bca17bae104e7e5eb6137fcf">&#9670;&nbsp;</a></span>ends_with() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ends_with </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given match string is located at the end of this string. </p>

<p class="definition">Definition at line <a class="el" href="ends__with_8cpp_source.html#l00053">53</a> of file <a class="el" href="ends__with_8cpp_source.html">ends_with.cpp</a>.</p>

</div>
</div>
<a id="ga6eadd6e031f051ff44c5ab2935cdddfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6eadd6e031f051ff44c5ab2935cdddfd">&#9670;&nbsp;</a></span>ends_with() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ends_with </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given match string is located at the end of this string. </p>

<p class="definition">Definition at line <a class="el" href="ends__with_8cpp_source.html#l00066">66</a> of file <a class="el" href="ends__with_8cpp_source.html">ends_with.cpp</a>.</p>

</div>
</div>
<a id="gac7e29572ead3f33c45cd95c8d4b720d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac7e29572ead3f33c45cd95c8d4b720d0">&#9670;&nbsp;</a></span>ends_with_icase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ends_with_icase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given match string is located at the end of this string. </p>
<p>Compares the characters case-insensitively.</p>
<p>Checks if the given match string is located at the end of this string. Compares the characters case-insensitively.</p>
<p>Checks if the given match string is located at the end of this string. Compares the characters case-insensitively. </p>

<p class="definition">Definition at line <a class="el" href="ends__with_8cpp_source.html#l00106">106</a> of file <a class="el" href="ends__with_8cpp_source.html">ends_with.cpp</a>.</p>

<p class="reference">References <a class="el" href="to__lower_8cpp_source.html#l00017">tlx::to_lower()</a>.</p>

</div>
</div>
<a id="ga849ffa2f657372a30b5cfc53fe1267a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga849ffa2f657372a30b5cfc53fe1267a1">&#9670;&nbsp;</a></span>ends_with_icase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ends_with_icase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given match string is located at the end of this string. </p>
<p>Compares the characters case-insensitively. </p>

<p class="definition">Definition at line <a class="el" href="ends__with_8cpp_source.html#l00119">119</a> of file <a class="el" href="ends__with_8cpp_source.html">ends_with.cpp</a>.</p>

<p class="reference">References <a class="el" href="to__lower_8cpp_source.html#l00017">tlx::to_lower()</a>.</p>

</div>
</div>
<a id="ga42a4d6e9f12943be811bcb6666d53493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42a4d6e9f12943be811bcb6666d53493">&#9670;&nbsp;</a></span>equal_icase() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool equal_icase </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if a == b without regard for letter case </p>

<p class="definition">Definition at line <a class="el" href="equal__icase_8cpp_source.html#l00018">18</a> of file <a class="el" href="equal__icase_8cpp_source.html">equal_icase.cpp</a>.</p>

<p class="reference">References <a class="el" href="to__lower_8cpp_source.html#l00017">tlx::to_lower()</a>.</p>

<p class="reference">Referenced by <a class="el" href="index__of_8cpp_source.html#l00039">tlx::index_of_icase()</a>.</p>

</div>
</div>
<a id="gad15c6b082515414b93a34b7ac0327df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad15c6b082515414b93a34b7ac0327df9">&#9670;&nbsp;</a></span>equal_icase() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool equal_icase </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if a == b without regard for letter case </p>

<p class="definition">Definition at line <a class="el" href="equal__icase_8cpp_source.html#l00026">26</a> of file <a class="el" href="equal__icase_8cpp_source.html">equal_icase.cpp</a>.</p>

<p class="reference">References <a class="el" href="to__lower_8cpp_source.html#l00017">tlx::to_lower()</a>.</p>

</div>
</div>
<a id="ga118abe0d4d0cd1d90426121b626aeea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga118abe0d4d0cd1d90426121b626aeea9">&#9670;&nbsp;</a></span>equal_icase() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool equal_icase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if a == b without regard for letter case </p>

<p class="definition">Definition at line <a class="el" href="equal__icase_8cpp_source.html#l00035">35</a> of file <a class="el" href="equal__icase_8cpp_source.html">equal_icase.cpp</a>.</p>

<p class="reference">References <a class="el" href="to__lower_8cpp_source.html#l00017">tlx::to_lower()</a>.</p>

</div>
</div>
<a id="ga2c9c153df7b49712108276c9a48fe88e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c9c153df7b49712108276c9a48fe88e">&#9670;&nbsp;</a></span>equal_icase() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool equal_icase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if a == b without regard for letter case </p>

<p class="definition">Definition at line <a class="el" href="equal__icase_8cpp_source.html#l00044">44</a> of file <a class="el" href="equal__icase_8cpp_source.html">equal_icase.cpp</a>.</p>

<p class="reference">References <a class="el" href="to__lower_8cpp_source.html#l00017">tlx::to_lower()</a>.</p>

</div>
</div>
<a id="gaa02a8cee5a6ee9d683fa5a77fda06913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa02a8cee5a6ee9d683fa5a77fda06913">&#9670;&nbsp;</a></span>erase_all() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; erase_all </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>drop</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all occurrences of the given character in-place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove this character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p class="definition">Definition at line <a class="el" href="erase__all_8cpp_source.html#l00018">18</a> of file <a class="el" href="erase__all_8cpp_source.html">erase_all.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="erase__all_8cpp_source.html#l00050">tlx::erase_all()</a>.</p>

</div>
</div>
<a id="ga290c6e7261f453c4774a0cf82586bf47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga290c6e7261f453c4774a0cf82586bf47">&#9670;&nbsp;</a></span>erase_all() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; erase_all </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all occurrences of the given characters in-place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p class="definition">Definition at line <a class="el" href="erase__all_8cpp_source.html#l00034">34</a> of file <a class="el" href="erase__all_8cpp_source.html">erase_all.cpp</a>.</p>

</div>
</div>
<a id="gacefd443f50a3e6123651a031eb1701c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacefd443f50a3e6123651a031eb1701c4">&#9670;&nbsp;</a></span>erase_all() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; erase_all </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all occurrences of the given characters in-place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p class="definition">Definition at line <a class="el" href="erase__all_8cpp_source.html#l00050">50</a> of file <a class="el" href="erase__all_8cpp_source.html">erase_all.cpp</a>.</p>

<p class="reference">References <a class="el" href="erase__all_8cpp_source.html#l00018">tlx::erase_all()</a>.</p>

</div>
</div>
<a id="ga3cd5bad774df90bb3314592e3e097ad8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cd5bad774df90bb3314592e3e097ad8">&#9670;&nbsp;</a></span>erase_all() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string erase_all </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>drop</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all occurrences of the given character, return copy of string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove this character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with less characters </dd></dl>

<p class="definition">Definition at line <a class="el" href="erase__all_8cpp_source.html#l00057">57</a> of file <a class="el" href="erase__all_8cpp_source.html">erase_all.cpp</a>.</p>

</div>
</div>
<a id="ga7c0aa5a14584e80887d4afc8c34337f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c0aa5a14584e80887d4afc8c34337f8">&#9670;&nbsp;</a></span>erase_all() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string erase_all </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all occurrences of the given characters, return copy of string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with less characters </dd></dl>

<p class="definition">Definition at line <a class="el" href="erase__all_8cpp_source.html#l00071">71</a> of file <a class="el" href="erase__all_8cpp_source.html">erase_all.cpp</a>.</p>

</div>
</div>
<a id="ga09e7dd3f20d8e54c8502c81d540f9916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09e7dd3f20d8e54c8502c81d540f9916">&#9670;&nbsp;</a></span>erase_all() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string erase_all </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all occurrences of the given characters, return copy of string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with less characters </dd></dl>

<p class="definition">Definition at line <a class="el" href="erase__all_8cpp_source.html#l00092">92</a> of file <a class="el" href="erase__all_8cpp_source.html">erase_all.cpp</a>.</p>

<p class="reference">References <a class="el" href="erase__all_8cpp_source.html#l00018">tlx::erase_all()</a>.</p>

</div>
</div>
<a id="gaa3ec7c7d258293a6891f016878d22f09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa3ec7c7d258293a6891f016878d22f09">&#9670;&nbsp;</a></span>escape_html() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string escape_html </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Escape characters for inclusion in HTML documents: replaces the characters &lt;, &gt;, &amp; and " with HTML entities. </p>

<p class="definition">Definition at line <a class="el" href="escape__html_8cpp_source.html#l00017">17</a> of file <a class="el" href="escape__html_8cpp_source.html">escape_html.cpp</a>.</p>

</div>
</div>
<a id="gaff9bb94ad54dff0e04f12d87ba4ccd0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff9bb94ad54dff0e04f12d87ba4ccd0d">&#9670;&nbsp;</a></span>escape_html() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string escape_html </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Escape characters for inclusion in HTML documents: replaces the characters &lt;, &gt;, &amp; and " with HTML entities. </p>

<p class="definition">Definition at line <a class="el" href="escape__html_8cpp_source.html#l00033">33</a> of file <a class="el" href="escape__html_8cpp_source.html">escape_html.cpp</a>.</p>

</div>
</div>
<a id="ga78dd9a77d746d167e41eb91022b3bc38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78dd9a77d746d167e41eb91022b3bc38">&#9670;&nbsp;</a></span>escape_uri() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string escape_uri </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Escape a string into a URI-encoding. </p>
<p>This maps all non A-Z0-9 characters to HH hex representation. </p>

<p class="definition">Definition at line <a class="el" href="escape__uri_8cpp_source.html#l00017">17</a> of file <a class="el" href="escape__uri_8cpp_source.html">escape_uri.cpp</a>.</p>

</div>
</div>
<a id="ga526a45d33d89b2de7c3c4a0734495332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga526a45d33d89b2de7c3c4a0734495332">&#9670;&nbsp;</a></span>escape_uri() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string escape_uri </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Escape a string into a URI-encoding. </p>
<p>This maps all non A-Z0-9 characters to HH hex representation. </p>

<p class="definition">Definition at line <a class="el" href="escape__uri_8cpp_source.html#l00057">57</a> of file <a class="el" href="escape__uri_8cpp_source.html">escape_uri.cpp</a>.</p>

</div>
</div>
<a id="gaf3c0e542036a6b3db66c2df1592fdcd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf3c0e542036a6b3db66c2df1592fdcd4">&#9670;&nbsp;</a></span>expand_environment_variables() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; expand_environment_variables </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand substrings $ABC_123 and ${ABC_123} into the corresponding environment variables. </p>
<p>Matches all substrings "$[a-zA-Z_][a-zA-Z0-9_]*" and "${[^}]*}". Replaces all substrings in-place. </p>

<p class="definition">Definition at line <a class="el" href="expand__environment__variables_8cpp_source.html#l00019">19</a> of file <a class="el" href="expand__environment__variables_8cpp_source.html">expand_environment_variables.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="expand__environment__variables_8cpp_source.html#l00080">tlx::expand_environment_variables()</a>, and <a class="el" href="config_8cpp_source.html#l00336">disk_config::parse_line()</a>.</p>

</div>
</div>
<a id="ga9078e1281843ab0c30230082ee244dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9078e1281843ab0c30230082ee244dd3">&#9670;&nbsp;</a></span>expand_environment_variables() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string expand_environment_variables </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand substrings $ABC_123 and ${ABC_123} into the corresponding environment variables. </p>
<p>Matches all substrings "$[a-zA-Z_][a-zA-Z0-9_]*" and "${[^}]*}". Returns a copy of the string with all substrings replaced. </p>

<p class="definition">Definition at line <a class="el" href="expand__environment__variables_8cpp_source.html#l00080">80</a> of file <a class="el" href="expand__environment__variables_8cpp_source.html">expand_environment_variables.cpp</a>.</p>

<p class="reference">References <a class="el" href="expand__environment__variables_8cpp_source.html#l00019">tlx::expand_environment_variables()</a>.</p>

</div>
</div>
<a id="ga59e8b9ac077b7535eccf2dd2469ef792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59e8b9ac077b7535eccf2dd2469ef792">&#9670;&nbsp;</a></span>expand_environment_variables() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string expand_environment_variables </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand substrings $ABC_123 and ${ABC_123} into the corresponding environment variables. </p>
<p>Matches all substrings "$[a-zA-Z_][a-zA-Z0-9_]*" and "${[^}]*}". Returns a copy of the string with all substrings replaced. </p>

<p class="definition">Definition at line <a class="el" href="expand__environment__variables_8cpp_source.html#l00086">86</a> of file <a class="el" href="expand__environment__variables_8cpp_source.html">expand_environment_variables.cpp</a>.</p>

<p class="reference">References <a class="el" href="expand__environment__variables_8cpp_source.html#l00019">tlx::expand_environment_variables()</a>.</p>

</div>
</div>
<a id="ga713c5cd2e2209e379c8b79ba2cd3e398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga713c5cd2e2209e379c8b79ba2cd3e398">&#9670;&nbsp;</a></span>extract_between() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string extract_between </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sep1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sep2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search the string for given start and end separators and extract all characters between the both, if they are found. </p>
<p>Otherwise return an empty string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to search in </td></tr>
    <tr><td class="paramname">sep1</td><td>start boundary </td></tr>
    <tr><td class="paramname">sep2</td><td>end boundary </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="extract__between_8cpp_source.html#l00037">37</a> of file <a class="el" href="extract__between_8cpp_source.html">extract_between.cpp</a>.</p>

<p class="reference">References <a class="el" href="extract__between_8cpp_source.html#l00019">tlx::extract_between_template()</a>.</p>

</div>
</div>
<a id="gae1ac1e43a5ae269bdbe594c4f4f4a325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1ac1e43a5ae269bdbe594c4f4f4a325">&#9670;&nbsp;</a></span>extract_between() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string extract_between </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sep1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sep2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search the string for given start and end separators and extract all characters between the both, if they are found. </p>
<p>Otherwise return an empty string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to search in </td></tr>
    <tr><td class="paramname">sep1</td><td>start boundary </td></tr>
    <tr><td class="paramname">sep2</td><td>end boundary </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="extract__between_8cpp_source.html#l00042">42</a> of file <a class="el" href="extract__between_8cpp_source.html">extract_between.cpp</a>.</p>

<p class="reference">References <a class="el" href="extract__between_8cpp_source.html#l00019">tlx::extract_between_template()</a>.</p>

</div>
</div>
<a id="gaf0c6e73d346e3deda660b2eb24b06c67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf0c6e73d346e3deda660b2eb24b06c67">&#9670;&nbsp;</a></span>extract_between() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string extract_between </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sep1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sep2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search the string for given start and end separators and extract all characters between the both, if they are found. </p>
<p>Otherwise return an empty string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to search in </td></tr>
    <tr><td class="paramname">sep1</td><td>start boundary </td></tr>
    <tr><td class="paramname">sep2</td><td>end boundary </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="extract__between_8cpp_source.html#l00047">47</a> of file <a class="el" href="extract__between_8cpp_source.html">extract_between.cpp</a>.</p>

<p class="reference">References <a class="el" href="extract__between_8cpp_source.html#l00019">tlx::extract_between_template()</a>.</p>

</div>
</div>
<a id="gab3a44aaf97230d79b6aac046331240d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3a44aaf97230d79b6aac046331240d3">&#9670;&nbsp;</a></span>extract_between() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string extract_between </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sep1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sep2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search the string for given start and end separators and extract all characters between the both, if they are found. </p>
<p>Otherwise return an empty string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to search in </td></tr>
    <tr><td class="paramname">sep1</td><td>start boundary </td></tr>
    <tr><td class="paramname">sep2</td><td>end boundary </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="extract__between_8cpp_source.html#l00052">52</a> of file <a class="el" href="extract__between_8cpp_source.html">extract_between.cpp</a>.</p>

<p class="reference">References <a class="el" href="extract__between_8cpp_source.html#l00019">tlx::extract_between_template()</a>.</p>

</div>
</div>
<a id="ga937bd46650d317c28df7c7723ae84119"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga937bd46650d317c28df7c7723ae84119">&#9670;&nbsp;</a></span>format_iec_units()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string format_iec_units </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>precision</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format number as something like 1 TiB. </p>
<p>Format a byte size using IEC (Ki, Mi, Gi, Ti) suffixes (powers of two). Returns "123 Ki" or similar. </p>

<p class="definition">Definition at line <a class="el" href="format__si__iec__units_8cpp_source.html#l00038">38</a> of file <a class="el" href="format__si__iec__units_8cpp_source.html">format_si_iec_units.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="iostats_8hpp_source.html#l00643">foxxll::add_IEC_binary_multiplier()</a>, <a class="el" href="context_8cpp_source.html#l01275">Context::Launch()</a>, <a class="el" href="just__sort_8cpp_source.html#l00076">main()</a>, <a class="el" href="context_8cpp_source.html#l01107">MemoryConfig::print()</a>, <a class="el" href="iostats_8cpp_source.html#l00813">scoped_print_iostats::report()</a>, and <a class="el" href="timer_8hpp_source.html#l00247">scoped_print_timer::~scoped_print_timer()</a>.</p>

</div>
</div>
<a id="ga084c15f3eff7d1eb6018d00779486013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga084c15f3eff7d1eb6018d00779486013">&#9670;&nbsp;</a></span>format_si_units()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string format_si_units </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>precision</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format number as something like 1 TB. </p>
<p>Format a byte size using SI (K, M, G, T) suffixes (powers of ten). Returns "123 M" or similar. </p>

<p class="definition">Definition at line <a class="el" href="format__si__iec__units_8cpp_source.html#l00019">19</a> of file <a class="el" href="format__si__iec__units_8cpp_source.html">format_si_iec_units.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="iostats_8hpp_source.html#l00650">foxxll::add_SI_multiplier()</a>.</p>

</div>
</div>
<a id="ga7d5fe504fb6456b97583d3b22e29ef15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d5fe504fb6456b97583d3b22e29ef15">&#9670;&nbsp;</a></span>hash_djb2() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t tlx::hash_djb2 </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple, fast, but "insecure" string hash method by Dan Bernstein from <a href="http://www.cse.yorku.ca/~oz/hash.html">http://www.cse.yorku.ca/~oz/hash.html</a>. </p>

<p class="definition">Definition at line <a class="el" href="hash__djb2_8hpp_source.html#l00026">26</a> of file <a class="el" href="hash__djb2_8hpp_source.html">hash_djb2.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="multi__timer_8cpp_source.html#l00052">MultiTimer::find_or_create()</a>, <a class="el" href="hash__djb2_8hpp_source.html#l00041">tlx::hash_djb2()</a>, <a class="el" href="string__view_8hpp_source.html#l00181">hash&lt; tlx::StringView &gt;::operator()()</a>, and <a class="el" href="multi__timer_8cpp_source.html#l00066">MultiTimer::start()</a>.</p>

</div>
</div>
<a id="ga6531595513b1c5d45b7bf4a69f692eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6531595513b1c5d45b7bf4a69f692eb8">&#9670;&nbsp;</a></span>hash_djb2() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t tlx::hash_djb2 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple, fast, but "insecure" string hash method by Dan Bernstein from <a href="http://www.cse.yorku.ca/~oz/hash.html">http://www.cse.yorku.ca/~oz/hash.html</a>. </p>

<p class="definition">Definition at line <a class="el" href="hash__djb2_8hpp_source.html#l00041">41</a> of file <a class="el" href="hash__djb2_8hpp_source.html">hash_djb2.hpp</a>.</p>

<p class="reference">References <a class="el" href="hash__djb2_8hpp_source.html#l00026">tlx::hash_djb2()</a>.</p>

</div>
</div>
<a id="ga5dc88c91798e233da55d584356208bde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5dc88c91798e233da55d584356208bde">&#9670;&nbsp;</a></span>hash_djb2() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t tlx::hash_djb2 </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple, fast, but "insecure" string hash method by Dan Bernstein from <a href="http://www.cse.yorku.ca/~oz/hash.html">http://www.cse.yorku.ca/~oz/hash.html</a>. </p>

<p class="definition">Definition at line <a class="el" href="hash__djb2_8hpp_source.html#l00050">50</a> of file <a class="el" href="hash__djb2_8hpp_source.html">hash_djb2.hpp</a>.</p>

</div>
</div>
<a id="gadbe3214eb034f80d3b0213e0f9d15d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbe3214eb034f80d3b0213e0f9d15d42">&#9670;&nbsp;</a></span>hash_djb2() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t tlx::hash_djb2 </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple, fast, but "insecure" string hash method by Dan Bernstein from <a href="http://www.cse.yorku.ca/~oz/hash.html">http://www.cse.yorku.ca/~oz/hash.html</a>. </p>

<p class="definition">Definition at line <a class="el" href="hash__djb2_8hpp_source.html#l00064">64</a> of file <a class="el" href="hash__djb2_8hpp_source.html">hash_djb2.hpp</a>.</p>

<p class="reference">References <a class="el" href="hash__djb2_8hpp_source.html#l00026">tlx::hash_djb2()</a>.</p>

</div>
</div>
<a id="gab4496533a4e1ae1eba65ca4ff2aace8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4496533a4e1ae1eba65ca4ff2aace8b">&#9670;&nbsp;</a></span>hash_djb2() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t tlx::hash_djb2 </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple, fast, but "insecure" string hash method by Dan Bernstein from <a href="http://www.cse.yorku.ca/~oz/hash.html">http://www.cse.yorku.ca/~oz/hash.html</a>. </p>

<p class="definition">Definition at line <a class="el" href="hash__djb2_8hpp_source.html#l00073">73</a> of file <a class="el" href="hash__djb2_8hpp_source.html">hash_djb2.hpp</a>.</p>

<p class="reference">References <a class="el" href="hash__djb2_8hpp_source.html#l00026">tlx::hash_djb2()</a>.</p>

</div>
</div>
<a id="gaf601eabca113edcea72bd73914f575af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf601eabca113edcea72bd73914f575af">&#9670;&nbsp;</a></span>hash_sdbm() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t tlx::hash_sdbm </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple, fast, but "insecure" string hash method by sdbm database from <a href="http://www.cse.yorku.ca/~oz/hash.html">http://www.cse.yorku.ca/~oz/hash.html</a>. </p>

<p class="definition">Definition at line <a class="el" href="hash__sdbm_8hpp_source.html#l00026">26</a> of file <a class="el" href="hash__sdbm_8hpp_source.html">hash_sdbm.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="hash__sdbm_8hpp_source.html#l00040">tlx::hash_sdbm()</a>.</p>

</div>
</div>
<a id="gaa22cee030ea7fd4250a5d62f96f44eec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa22cee030ea7fd4250a5d62f96f44eec">&#9670;&nbsp;</a></span>hash_sdbm() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t tlx::hash_sdbm </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple, fast, but "insecure" string hash method by sdbm database from <a href="http://www.cse.yorku.ca/~oz/hash.html">http://www.cse.yorku.ca/~oz/hash.html</a>. </p>

<p class="definition">Definition at line <a class="el" href="hash__sdbm_8hpp_source.html#l00040">40</a> of file <a class="el" href="hash__sdbm_8hpp_source.html">hash_sdbm.hpp</a>.</p>

<p class="reference">References <a class="el" href="hash__sdbm_8hpp_source.html#l00026">tlx::hash_sdbm()</a>.</p>

</div>
</div>
<a id="gab2a3262295fb0a81a969021e1ecd92fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2a3262295fb0a81a969021e1ecd92fa">&#9670;&nbsp;</a></span>hash_sdbm() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t tlx::hash_sdbm </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple, fast, but "insecure" string hash method by sdbm database from <a href="http://www.cse.yorku.ca/~oz/hash.html">http://www.cse.yorku.ca/~oz/hash.html</a>. </p>

<p class="definition">Definition at line <a class="el" href="hash__sdbm_8hpp_source.html#l00049">49</a> of file <a class="el" href="hash__sdbm_8hpp_source.html">hash_sdbm.hpp</a>.</p>

</div>
</div>
<a id="ga2b763e42bb6cd369d77917c383e15bb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b763e42bb6cd369d77917c383e15bb4">&#9670;&nbsp;</a></span>hash_sdbm() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t tlx::hash_sdbm </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple, fast, but "insecure" string hash method by sdbm database from <a href="http://www.cse.yorku.ca/~oz/hash.html">http://www.cse.yorku.ca/~oz/hash.html</a>. </p>

<p class="definition">Definition at line <a class="el" href="hash__sdbm_8hpp_source.html#l00063">63</a> of file <a class="el" href="hash__sdbm_8hpp_source.html">hash_sdbm.hpp</a>.</p>

<p class="reference">References <a class="el" href="hash__sdbm_8hpp_source.html#l00026">tlx::hash_sdbm()</a>.</p>

</div>
</div>
<a id="gadbd5b48b17bb3d074f4404bce40b592d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbd5b48b17bb3d074f4404bce40b592d">&#9670;&nbsp;</a></span>hash_sdbm() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t tlx::hash_sdbm </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple, fast, but "insecure" string hash method by sdbm database from <a href="http://www.cse.yorku.ca/~oz/hash.html">http://www.cse.yorku.ca/~oz/hash.html</a>. </p>

<p class="definition">Definition at line <a class="el" href="hash__sdbm_8hpp_source.html#l00072">72</a> of file <a class="el" href="hash__sdbm_8hpp_source.html">hash_sdbm.hpp</a>.</p>

<p class="reference">References <a class="el" href="hash__sdbm_8hpp_source.html#l00026">tlx::hash_sdbm()</a>.</p>

</div>
</div>
<a id="gab4c0ada9ff7b0d905361e60050316899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4c0ada9ff7b0d905361e60050316899">&#9670;&nbsp;</a></span>hexdump() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string hexdump </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a (binary) string as a sequence of uppercase hexadecimal pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>binary data to output in hex </td></tr>
    <tr><td class="paramname">size</td><td>length of binary data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hexadecimal pairs </dd></dl>

<p class="definition">Definition at line <a class="el" href="hexdump_8cpp_source.html#l00021">21</a> of file <a class="el" href="hexdump_8cpp_source.html">hexdump.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="stream__sink_8cpp_source.html#l00162">StreamSink::AppendPinnedBlock()</a>, <a class="el" href="md5_8cpp_source.html#l00265">MD5::digest_hex_uc()</a>, <a class="el" href="sha1_8cpp_source.html#l00216">SHA1::digest_hex_uc()</a>, <a class="el" href="sha512_8cpp_source.html#l00251">SHA512::digest_hex_uc()</a>, <a class="el" href="sha256_8cpp_source.html#l00232">SHA256::digest_hex_uc()</a>, <a class="el" href="hexdump_8cpp_source.html#l00042">tlx::hexdump()</a>, <a class="el" href="hexdump_8hpp_source.html#l00052">tlx::hexdump_type()</a>, <a class="el" href="mock_2group_8cpp_source.html#l00181">Group::MaybeHexdump()</a>, <a class="el" href="socket_8hpp_source.html#l00609">Socket::MaybeHexdump()</a>, and <a class="el" href="cat__stream_8cpp_source.html#l00243">CatStreamData::OnStreamBlock()</a>.</p>

</div>
</div>
<a id="gaa0757bf9871dc4e2526ab48e4cde28e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0757bf9871dc4e2526ab48e4cde28e1">&#9670;&nbsp;</a></span>hexdump() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string hexdump </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a (binary) string as a sequence of uppercase hexadecimal pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>binary data to output in hex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hexadecimal pairs </dd></dl>

<p class="definition">Definition at line <a class="el" href="hexdump_8cpp_source.html#l00042">42</a> of file <a class="el" href="hexdump_8cpp_source.html">hexdump.cpp</a>.</p>

<p class="reference">References <a class="el" href="hexdump_8cpp_source.html#l00021">tlx::hexdump()</a>.</p>

</div>
</div>
<a id="ga15c83e3e2055412b0440758c98b3f148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15c83e3e2055412b0440758c98b3f148">&#9670;&nbsp;</a></span>hexdump() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string hexdump </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a char vector as a sequence of uppercase hexadecimal pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>binary data to output in hex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hexadecimal pairs </dd></dl>

<p class="definition">Definition at line <a class="el" href="hexdump_8cpp_source.html#l00046">46</a> of file <a class="el" href="hexdump_8cpp_source.html">hexdump.cpp</a>.</p>

<p class="reference">References <a class="el" href="hexdump_8cpp_source.html#l00021">tlx::hexdump()</a>.</p>

</div>
</div>
<a id="ga6c6446ce9a61a434b3a10345cbf3ebed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c6446ce9a61a434b3a10345cbf3ebed">&#9670;&nbsp;</a></span>hexdump() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string hexdump </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a uint8_t vector as a sequence of uppercase hexadecimal pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>binary data to output in hex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hexadecimal pairs </dd></dl>

<p class="definition">Definition at line <a class="el" href="hexdump_8cpp_source.html#l00050">50</a> of file <a class="el" href="hexdump_8cpp_source.html">hexdump.cpp</a>.</p>

<p class="reference">References <a class="el" href="hexdump_8cpp_source.html#l00021">tlx::hexdump()</a>.</p>

</div>
</div>
<a id="ga0c47a216e0abcdf9a88fc50bb79c98ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c47a216e0abcdf9a88fc50bb79c98ba">&#9670;&nbsp;</a></span>hexdump_lc() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string hexdump_lc </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a (binary) string as a sequence of lowercase hexadecimal pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>binary data to output in hex </td></tr>
    <tr><td class="paramname">size</td><td>length of binary data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hexadecimal pairs </dd></dl>

<p class="definition">Definition at line <a class="el" href="hexdump_8cpp_source.html#l00095">95</a> of file <a class="el" href="hexdump_8cpp_source.html">hexdump.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="md5_8cpp_source.html#l00259">MD5::digest_hex()</a>, <a class="el" href="sha1_8cpp_source.html#l00210">SHA1::digest_hex()</a>, <a class="el" href="sha512_8cpp_source.html#l00245">SHA512::digest_hex()</a>, <a class="el" href="sha256_8cpp_source.html#l00226">SHA256::digest_hex()</a>, <a class="el" href="hexdump_8cpp_source.html#l00116">tlx::hexdump_lc()</a>, <a class="el" href="hexdump_8hpp_source.html#l00110">tlx::hexdump_lc_type()</a>, and <a class="el" href="hexdump_8hpp_source.html#l00052">tlx::hexdump_type()</a>.</p>

</div>
</div>
<a id="ga60e8912db4511738cfdbf3e97ff6dbbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60e8912db4511738cfdbf3e97ff6dbbf">&#9670;&nbsp;</a></span>hexdump_lc() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string hexdump_lc </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a (binary) string as a sequence of lowercase hexadecimal pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>binary data to output in hex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hexadecimal pairs </dd></dl>

<p class="definition">Definition at line <a class="el" href="hexdump_8cpp_source.html#l00116">116</a> of file <a class="el" href="hexdump_8cpp_source.html">hexdump.cpp</a>.</p>

<p class="reference">References <a class="el" href="hexdump_8cpp_source.html#l00095">tlx::hexdump_lc()</a>.</p>

</div>
</div>
<a id="gae749cedcfc25af4f829d70e8febba7a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae749cedcfc25af4f829d70e8febba7a1">&#9670;&nbsp;</a></span>hexdump_lc() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string hexdump_lc </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a char vector as a sequence of lowercase hexadecimal pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>binary data to output in hex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hexadecimal pairs </dd></dl>

<p class="definition">Definition at line <a class="el" href="hexdump_8cpp_source.html#l00120">120</a> of file <a class="el" href="hexdump_8cpp_source.html">hexdump.cpp</a>.</p>

<p class="reference">References <a class="el" href="hexdump_8cpp_source.html#l00095">tlx::hexdump_lc()</a>.</p>

</div>
</div>
<a id="ga0b35bd68e5974e78327fce13e0e2eaf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b35bd68e5974e78327fce13e0e2eaf6">&#9670;&nbsp;</a></span>hexdump_lc() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string hexdump_lc </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a uint8_t vector as a sequence of lowercase hexadecimal pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>binary data to output in hex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hexadecimal pairs </dd></dl>

<p class="definition">Definition at line <a class="el" href="hexdump_8cpp_source.html#l00124">124</a> of file <a class="el" href="hexdump_8cpp_source.html">hexdump.cpp</a>.</p>

<p class="reference">References <a class="el" href="hexdump_8cpp_source.html#l00095">tlx::hexdump_lc()</a>.</p>

</div>
</div>
<a id="ga0b2f444830d8f7b1b0eaf93b5f514bf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b2f444830d8f7b1b0eaf93b5f514bf7">&#9670;&nbsp;</a></span>hexdump_lc_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::hexdump_lc_type </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a (binary) item as a sequence of lowercase hexadecimal pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>binary data to output in hex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hexadecimal pairs </dd></dl>

<p class="definition">Definition at line <a class="el" href="hexdump_8hpp_source.html#l00110">110</a> of file <a class="el" href="hexdump_8hpp_source.html">hexdump.hpp</a>.</p>

<p class="reference">References <a class="el" href="hexdump_8cpp_source.html#l00095">tlx::hexdump_lc()</a>, and <a class="el" href="hexdump_8cpp_source.html#l00131">tlx::parse_hexdump()</a>.</p>

</div>
</div>
<a id="gab10f91fa3b24c787e4e0d88c009ac298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab10f91fa3b24c787e4e0d88c009ac298">&#9670;&nbsp;</a></span>hexdump_sourcecode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string hexdump_sourcecode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var_name</em> = <code>&quot;name&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a (binary) string into a C source code snippet. </p>
<p>The snippet defines an array of const uint8_t* holding the data of the string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to output as C source array </td></tr>
    <tr><td class="paramname">var_name</td><td>name of the array variable in the outputted code snippet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string holding C source snippet </dd></dl>

<p class="definition">Definition at line <a class="el" href="hexdump_8cpp_source.html#l00054">54</a> of file <a class="el" href="hexdump_8cpp_source.html">hexdump.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="hexdump_8hpp_source.html#l00052">tlx::hexdump_type()</a>.</p>

</div>
</div>
<a id="gae2a485134f5e618b846abb630d44ec6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2a485134f5e618b846abb630d44ec6f">&#9670;&nbsp;</a></span>hexdump_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::hexdump_type </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a (binary) item as a sequence of uppercase hexadecimal pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>binary data to output in hex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hexadecimal pairs </dd></dl>

<p class="definition">Definition at line <a class="el" href="hexdump_8hpp_source.html#l00052">52</a> of file <a class="el" href="hexdump_8hpp_source.html">hexdump.hpp</a>.</p>

<p class="reference">References <a class="el" href="hexdump_8cpp_source.html#l00021">tlx::hexdump()</a>, <a class="el" href="hexdump_8cpp_source.html#l00095">tlx::hexdump_lc()</a>, and <a class="el" href="hexdump_8cpp_source.html#l00054">tlx::hexdump_sourcecode()</a>.</p>

<p class="reference">Referenced by <a class="el" href="block__reader_8hpp_source.html#l00089">BlockReader&lt; CatBlockSource &gt;::Next()</a>, <a class="el" href="sample__sort__tools_8hpp_source.html#l00150">SSTreeBuilderPreAndLevelOrder&lt; key_type, num_splitters &gt;::recurse()</a>, and <a class="el" href="sample__sort__tools_8hpp_source.html#l00258">SSTreeBuilderLevelOrder&lt; key_type, num_splitters &gt;::recurse()</a>.</p>

</div>
</div>
<a id="ga15b290439811d07e8fc0a6134c4faa0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15b290439811d07e8fc0a6134c4faa0b">&#9670;&nbsp;</a></span>index_of() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t index_of </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to find str in the list and return the index. </p>
<p>Throws a std::runtime_error if it is not found. </p>

<p class="definition">Definition at line <a class="el" href="index__of_8cpp_source.html#l00019">19</a> of file <a class="el" href="index__of_8cpp_source.html">index_of.cpp</a>.</p>

</div>
</div>
<a id="gac5156b8029cca4a21cb3e1b14ea6526d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5156b8029cca4a21cb3e1b14ea6526d">&#9670;&nbsp;</a></span>index_of() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t index_of </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to find str in the list and return the index. </p>
<p>Throws a std::runtime_error if it is not found. </p>

<p class="definition">Definition at line <a class="el" href="index__of_8cpp_source.html#l00029">29</a> of file <a class="el" href="index__of_8cpp_source.html">index_of.cpp</a>.</p>

</div>
</div>
<a id="ga00bece0086ba6a8598e97e93694b713f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00bece0086ba6a8598e97e93694b713f">&#9670;&nbsp;</a></span>index_of_icase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t index_of_icase </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to find str in the list and return the index using case-insensitive comparisons. </p>
<p>Throws a std::runtime_error if it is not found. </p>

<p class="definition">Definition at line <a class="el" href="index__of_8cpp_source.html#l00039">39</a> of file <a class="el" href="index__of_8cpp_source.html">index_of.cpp</a>.</p>

<p class="reference">References <a class="el" href="equal__icase_8cpp_source.html#l00018">tlx::equal_icase()</a>.</p>

</div>
</div>
<a id="ga2d3b5b0636e261f97ab3292d78f2201b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d3b5b0636e261f97ab3292d78f2201b">&#9670;&nbsp;</a></span>index_of_icase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t index_of_icase </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to find str in the list and return the index using case-insensitive comparisons. </p>
<p>Throws a std::runtime_error if it is not found. </p>

<p class="definition">Definition at line <a class="el" href="index__of_8cpp_source.html#l00050">50</a> of file <a class="el" href="index__of_8cpp_source.html">index_of.cpp</a>.</p>

<p class="reference">References <a class="el" href="equal__icase_8cpp_source.html#l00018">tlx::equal_icase()</a>.</p>

</div>
</div>
<a id="gad383d32ace209b51abe936d256d0bb1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad383d32ace209b51abe936d256d0bb1e">&#9670;&nbsp;</a></span>join() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string join </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>glue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join a vector of strings by some glue character between each pair from the sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">glue</td><td>character for glue </td></tr>
    <tr><td class="paramname">parts</td><td>the vector of strings to join </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string constructed from the vector with the glue between two strings </dd></dl>

<p class="definition">Definition at line <a class="el" href="join_8cpp_source.html#l00016">16</a> of file <a class="el" href="join_8cpp_source.html">join.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="join_8cpp_source.html#l00020">tlx::join()</a>, <a class="el" href="block__pool_8cpp_source.html#l00216">thrill::data::operator&lt;&lt;()</a>, <a class="el" href="page__rank_8hpp_source.html#l00071">examples::page_rank::PageRank()</a>, <a class="el" href="page__rank_8hpp_source.html#l00142">examples::page_rank::PageRankJoin()</a>, <a class="el" href="parallel__multiway__merge_8hpp_source.html#l00068">tlx::parallel_multiway_merge_base()</a>, <a class="el" href="byte__block_8cpp_source.html#l00063">ByteBlock::pin_count_str()</a>, <a class="el" href="read__binary_8hpp_source.html#l00082">ReadBinaryNode&lt; ValueType &gt;::ReadBinaryNode()</a>, <a class="el" href="read__lines_8hpp_source.html#l00050">ReadLinesNode::ReadLinesNode()</a>, and <a class="el" href="thread__pool_8cpp_source.html#l00025">ThreadPool::~ThreadPool()</a>.</p>

</div>
</div>
<a id="ga0cb20ee53f25c37880faf1b5e5ac3619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0cb20ee53f25c37880faf1b5e5ac3619">&#9670;&nbsp;</a></span>join() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string join </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>glue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join a vector of strings by some glue string between each pair from the sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">glue</td><td>string to glue </td></tr>
    <tr><td class="paramname">parts</td><td>the vector of strings to join </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string constructed from the vector with the glue between two strings </dd></dl>

<p class="definition">Definition at line <a class="el" href="join_8cpp_source.html#l00020">20</a> of file <a class="el" href="join_8cpp_source.html">join.cpp</a>.</p>

<p class="reference">References <a class="el" href="join_8cpp_source.html#l00016">tlx::join()</a>.</p>

</div>
</div>
<a id="ga206c170915b483387448714300d311c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga206c170915b483387448714300d311c1">&#9670;&nbsp;</a></span>join() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string join </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>glue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join a vector of strings by some glue string between each pair from the sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">glue</td><td>string to glue </td></tr>
    <tr><td class="paramname">parts</td><td>the vector of strings to join </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string constructed from the vector with the glue between two strings </dd></dl>

<p class="definition">Definition at line <a class="el" href="join_8cpp_source.html#l00024">24</a> of file <a class="el" href="join_8cpp_source.html">join.cpp</a>.</p>

<p class="reference">References <a class="el" href="join_8cpp_source.html#l00016">tlx::join()</a>.</p>

</div>
</div>
<a id="ga1af0448079469f224ea8905c34dc1868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1af0448079469f224ea8905c34dc1868">&#9670;&nbsp;</a></span>join() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string tlx::join </td>
          <td>(</td>
          <td class="paramtype">Glue&#160;</td>
          <td class="paramname"><em>glue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Join a sequence of strings by some glue string between each pair from the sequence. </p>
<p>The sequence in given as a range between two iterators.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">glue</td><td>string to glue </td></tr>
    <tr><td class="paramname">first</td><td>the beginning iterator of the range to join </td></tr>
    <tr><td class="paramname">last</td><td>the ending iterator of the range to join </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string constructed from the range with the glue between two strings. </dd></dl>

<p class="definition">Definition at line <a class="el" href="join__generic_8hpp_source.html#l00035">35</a> of file <a class="el" href="join__generic_8hpp_source.html">join_generic.hpp</a>.</p>

</div>
</div>
<a id="ga4a96227b0edd6c65800124ba1dac82cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a96227b0edd6c65800124ba1dac82cf">&#9670;&nbsp;</a></span>join() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string tlx::join </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>glue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Join a Container of strings by some glue character between each pair from the sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">glue</td><td>character for glue </td></tr>
    <tr><td class="paramname">parts</td><td>the vector of strings to join </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string constructed from the vector with the glue between two strings </dd></dl>

<p class="definition">Definition at line <a class="el" href="join__generic_8hpp_source.html#l00062">62</a> of file <a class="el" href="join__generic_8hpp_source.html">join_generic.hpp</a>.</p>

<p class="reference">References <a class="el" href="join_8cpp_source.html#l00016">tlx::join()</a>.</p>

</div>
</div>
<a id="gaffea57c0c1e61aa8c9bc50e1ec2f9fe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffea57c0c1e61aa8c9bc50e1ec2f9fe2">&#9670;&nbsp;</a></span>join() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string tlx::join </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>glue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Join a Container of strings by some glue string between each pair from the sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">glue</td><td>string to glue </td></tr>
    <tr><td class="paramname">parts</td><td>the vector of strings to join </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string constructed from the vector with the glue between two strings </dd></dl>

<p class="definition">Definition at line <a class="el" href="join__generic_8hpp_source.html#l00076">76</a> of file <a class="el" href="join__generic_8hpp_source.html">join_generic.hpp</a>.</p>

<p class="reference">References <a class="el" href="join_8cpp_source.html#l00016">tlx::join()</a>.</p>

</div>
</div>
<a id="ga2e35ca12bd4564ba470e3bf4f6a91798"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e35ca12bd4564ba470e3bf4f6a91798">&#9670;&nbsp;</a></span>join() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string tlx::join </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>glue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Join a Container of strings by some glue string between each pair from the sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">glue</td><td>string to glue </td></tr>
    <tr><td class="paramname">parts</td><td>the vector of strings to join </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string constructed from the vector with the glue between two strings </dd></dl>

<p class="definition">Definition at line <a class="el" href="join__generic_8hpp_source.html#l00090">90</a> of file <a class="el" href="join__generic_8hpp_source.html">join_generic.hpp</a>.</p>

<p class="reference">References <a class="el" href="join_8cpp_source.html#l00016">tlx::join()</a>.</p>

</div>
</div>
<a id="gabceb162540e1d7f3f6bef9304fdd6ef9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabceb162540e1d7f3f6bef9304fdd6ef9">&#9670;&nbsp;</a></span>join_quoted() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string join_quoted </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>quote</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>escape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join a vector of strings using a separator character. </p>
<p>If any string contains the separator, quote the field. In the quoted string, escape all quotes, escapes, \n, \r, \t sequences. This is the opposite of <a class="el" href="group__tlx__string.html#gafc48ce717ba77df6c6f395fb07bc8a1e" title="Split the given string at each separator character into distinct substrings. ">split_quoted()</a>. </p>

<p class="definition">Definition at line <a class="el" href="join__quoted_8cpp_source.html#l00015">15</a> of file <a class="el" href="join__quoted_8cpp_source.html">join_quoted.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="join__quoted_8cpp_source.html#l00055">tlx::join_quoted()</a>.</p>

</div>
</div>
<a id="ga71e61af2f5c2aea97806490bc4e89b17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga71e61af2f5c2aea97806490bc4e89b17">&#9670;&nbsp;</a></span>join_quoted() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string join_quoted </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join a vector of strings using spaces as separator character. </p>
<p>If any string contains a space, quote the field. In the quoted string, escape all quotes, escapes, \n, \r, \t sequences. This is the opposite of <a class="el" href="group__tlx__string.html#gafc48ce717ba77df6c6f395fb07bc8a1e" title="Split the given string at each separator character into distinct substrings. ">split_quoted()</a>. </p>

<p class="definition">Definition at line <a class="el" href="join__quoted_8cpp_source.html#l00055">55</a> of file <a class="el" href="join__quoted_8cpp_source.html">join_quoted.cpp</a>.</p>

<p class="reference">References <a class="el" href="join__quoted_8cpp_source.html#l00015">tlx::join_quoted()</a>.</p>

</div>
</div>
<a id="ga3a73759be8d7ec5778cb6192bc32c4c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3a73759be8d7ec5778cb6192bc32c4c2">&#9670;&nbsp;</a></span>less_icase() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool less_icase </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if a &lt; b without regard for letter case </p>

<p class="definition">Definition at line <a class="el" href="less__icase_8cpp_source.html#l00018">18</a> of file <a class="el" href="less__icase_8cpp_source.html">less_icase.cpp</a>.</p>

<p class="reference">References <a class="el" href="to__lower_8cpp_source.html#l00017">tlx::to_lower()</a>.</p>

<p class="reference">Referenced by <a class="el" href="less__icase_8hpp_source.html#l00041">less_icase_asc::operator()()</a>, and <a class="el" href="less__icase_8hpp_source.html#l00049">less_icase_desc::operator()()</a>.</p>

</div>
</div>
<a id="ga0e53bb43043cc4fdf6fef5a9f017957c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0e53bb43043cc4fdf6fef5a9f017957c">&#9670;&nbsp;</a></span>less_icase() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool less_icase </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if a &lt; b without regard for letter case </p>

<p class="definition">Definition at line <a class="el" href="less__icase_8cpp_source.html#l00033">33</a> of file <a class="el" href="less__icase_8cpp_source.html">less_icase.cpp</a>.</p>

<p class="reference">References <a class="el" href="to__lower_8cpp_source.html#l00017">tlx::to_lower()</a>.</p>

</div>
</div>
<a id="ga25e2629353a36fb47c587b4eef89c0d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25e2629353a36fb47c587b4eef89c0d2">&#9670;&nbsp;</a></span>less_icase() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool less_icase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if a &lt; b without regard for letter case </p>

<p class="definition">Definition at line <a class="el" href="less__icase_8cpp_source.html#l00049">49</a> of file <a class="el" href="less__icase_8cpp_source.html">less_icase.cpp</a>.</p>

<p class="reference">References <a class="el" href="to__lower_8cpp_source.html#l00017">tlx::to_lower()</a>.</p>

</div>
</div>
<a id="ga9fb49f152c6bf0d96ec46bfb90a38bfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fb49f152c6bf0d96ec46bfb90a38bfc">&#9670;&nbsp;</a></span>less_icase() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool less_icase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if a &lt; b without regard for letter case </p>

<p class="definition">Definition at line <a class="el" href="less__icase_8cpp_source.html#l00065">65</a> of file <a class="el" href="less__icase_8cpp_source.html">less_icase.cpp</a>.</p>

<p class="reference">References <a class="el" href="to__lower_8cpp_source.html#l00017">tlx::to_lower()</a>.</p>

</div>
</div>
<a id="ga5097f3a710847ed15aa3cdc2bbbe857c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5097f3a710847ed15aa3cdc2bbbe857c">&#9670;&nbsp;</a></span>levenshtein() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t tlx::levenshtein </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the Levenshtein string distance between two strings. </p>
<p>The distance is the minimum number of replacements/inserts/deletes needed to change one string into the other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first string </td></tr>
    <tr><td class="paramname">b</td><td>second string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Levenshtein distance </dd></dl>

<p class="definition">Definition at line <a class="el" href="levenshtein_8hpp_source.html#l00128">128</a> of file <a class="el" href="levenshtein_8hpp_source.html">levenshtein.hpp</a>.</p>

</div>
</div>
<a id="ga643fe1eebc35da109f593cdcf068d3af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga643fe1eebc35da109f593cdcf068d3af">&#9670;&nbsp;</a></span>levenshtein() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t tlx::levenshtein </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the Levenshtein string distance between two strings. </p>
<p>The distance is the minimum number of replacements/inserts/deletes needed to change one string into the other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first string </td></tr>
    <tr><td class="paramname">b</td><td>second string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Levenshtein distance </dd></dl>

<p class="definition">Definition at line <a class="el" href="levenshtein_8hpp_source.html#l00156">156</a> of file <a class="el" href="levenshtein_8hpp_source.html">levenshtein.hpp</a>.</p>

</div>
</div>
<a id="ga28296225d021e2ff9a1bedfa711b26fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28296225d021e2ff9a1bedfa711b26fa">&#9670;&nbsp;</a></span>levenshtein_algorithm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t tlx::levenshtein_algorithm </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>a_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>b_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the Levenshtein string distance also called edit distance between two strings. </p>
<p>The distance is the minimum number of replacements/inserts/deletes needed to change one string into the other. Implemented with time complexity O(|n|+|m|) and memory complexity O(2*max(|n|,|m|))</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first string </td></tr>
    <tr><td class="paramname">a_size</td><td>size of first string </td></tr>
    <tr><td class="paramname">b</td><td>second string </td></tr>
    <tr><td class="paramname">b_size</td><td>size of second string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Levenshtein distance </dd></dl>

<p class="definition">Definition at line <a class="el" href="levenshtein_8hpp_source.html#l00067">67</a> of file <a class="el" href="levenshtein_8hpp_source.html">levenshtein.hpp</a>.</p>

<p class="reference">References <a class="el" href="extlib_2foxxll_2foxxll_2common_2uint__types_8hpp_source.html#l00217">min()</a>, and <a class="el" href="counting__ptr_8hpp_source.html#l00320">tlx::swap()</a>.</p>

</div>
</div>
<a id="ga01fc1d66b4a6f822509d793576b2cce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga01fc1d66b4a6f822509d793576b2cce2">&#9670;&nbsp;</a></span>levenshtein_icase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t tlx::levenshtein_icase </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the Levenshtein string distance between two strings. </p>
<p>The distance is the minimum number of replacements/inserts/deletes needed to change one string into the other.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first string </td></tr>
    <tr><td class="paramname">b</td><td>second string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Levenshtein distance </dd></dl>

<p class="definition">Definition at line <a class="el" href="levenshtein_8hpp_source.html#l00142">142</a> of file <a class="el" href="levenshtein_8hpp_source.html">levenshtein.hpp</a>.</p>

</div>
</div>
<a id="ga0d20af010f11fab72744484ef67e00b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d20af010f11fab72744484ef67e00b6">&#9670;&nbsp;</a></span>levenshtein_icase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t tlx::levenshtein_icase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the Levenshtein string distance between two strings. </p>
<p>The distance is the minimum number of replacements/inserts/deletes needed to change one string into the other. Character comparison is done case-insensitively.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first string </td></tr>
    <tr><td class="paramname">b</td><td>second string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Levenshtein distance </dd></dl>

<p class="definition">Definition at line <a class="el" href="levenshtein_8hpp_source.html#l00171">171</a> of file <a class="el" href="levenshtein_8hpp_source.html">levenshtein.hpp</a>.</p>

</div>
</div>
<a id="ga60ca8653250ad56e209887e5e7183328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga60ca8653250ad56e209887e5e7183328">&#9670;&nbsp;</a></span>pad()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string pad </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>pad_char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Truncate or pad string to exactly len characters. </p>

<p class="definition">Definition at line <a class="el" href="pad_8cpp_source.html#l00015">15</a> of file <a class="el" href="pad_8cpp_source.html">pad.cpp</a>.</p>

</div>
</div>
<a id="ga81809bc5e0b69034f39659303baa4bf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81809bc5e0b69034f39659303baa4bf9">&#9670;&nbsp;</a></span>parse_hexdump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string parse_hexdump </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a string as a sequence of hexadecimal pairs. </p>
<p>Converts each pair of hexadecimal digits into a byte of the output string. Throws std::runtime_error() if an unknown letter is encountered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to parse as hex digits </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of read bytes </dd></dl>

<p class="definition">Definition at line <a class="el" href="hexdump_8cpp_source.html#l00131">131</a> of file <a class="el" href="hexdump_8cpp_source.html">hexdump.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="hexdump_8hpp_source.html#l00110">tlx::hexdump_lc_type()</a>.</p>

</div>
</div>
<a id="ga58be0557b1b38913b28d947c935aed42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58be0557b1b38913b28d947c935aed42">&#9670;&nbsp;</a></span>parse_si_iec_units() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parse_si_iec_units </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>out_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>default_unit</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a string like "343KB" or "44 GiB" into the corresponding size in bytes. </p>
<p>Returns the number of bytes and sets ok = true if the string could be parsed correctly. If no units indicator is given, use def_unit in k/m/g/t/p (powers of ten) or in K/M/G/T/P (power of two). </p>

<p class="definition">Definition at line <a class="el" href="parse__si__iec__units_8cpp_source.html#l00017">17</a> of file <a class="el" href="parse__si__iec__units_8cpp_source.html">parse_si_iec_units.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="terasort_8cpp_source.html#l00120">main()</a>, <a class="el" href="config_8cpp_source.html#l00336">disk_config::parse_line()</a>, <a class="el" href="parse__si__iec__units_8cpp_source.html#l00088">tlx::parse_si_iec_units()</a>, and <a class="el" href="context_8cpp_source.html#l01023">MemoryConfig::setup_detect()</a>.</p>

</div>
</div>
<a id="ga42a656ed3586b515140cb71b312f0f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42a656ed3586b515140cb71b312f0f9b">&#9670;&nbsp;</a></span>parse_si_iec_units() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parse_si_iec_units </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>out_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>default_unit</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a string like "343KB" or "44 GiB" into the corresponding size in bytes. </p>
<p>Returns the number of bytes and sets ok = true if the string could be parsed correctly. If no units indicator is given, use def_unit in k/m/g/t/p (powers of ten) or in K/M/G/T/P (power of two). </p>

<p class="definition">Definition at line <a class="el" href="parse__si__iec__units_8cpp_source.html#l00088">88</a> of file <a class="el" href="parse__si__iec__units_8cpp_source.html">parse_si_iec_units.cpp</a>.</p>

<p class="reference">References <a class="el" href="parse__si__iec__units_8cpp_source.html#l00017">tlx::parse_si_iec_units()</a>.</p>

</div>
</div>
<a id="ga7021d36930f4bd434b2082dce8bd43cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7021d36930f4bd434b2082dce8bd43cf">&#9670;&nbsp;</a></span>replace_all() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; replace_all </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of needle in str. </p>
<p>Each needle will be replaced with instead, if found. The replacement is done in the given string and a reference to the same is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to str </dd></dl>

<p class="definition">Definition at line <a class="el" href="replace_8cpp_source.html#l00141">141</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="porting_8cpp_source.html#l00068">thrill::common::LogCmdlineParams()</a>.</p>

</div>
</div>
<a id="gadd5bd9f9a887fa20b4a8ebaf987fd5de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd5bd9f9a887fa20b4a8ebaf987fd5de">&#9670;&nbsp;</a></span>replace_all() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; replace_all </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of needle in str. </p>
<p>Each needle will be replaced with instead, if found. The replacement is done in the given string and a reference to the same is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to str </dd></dl>

<p class="definition">Definition at line <a class="el" href="replace_8cpp_source.html#l00154">154</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a id="ga6b4b8117690af529b7051a3c10c382ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b4b8117690af529b7051a3c10c382ff">&#9670;&nbsp;</a></span>replace_all() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; replace_all </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of needle in str. </p>
<p>Each needle will be replaced with instead, if found. The replacement is done in the given string and a reference to the same is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to str </dd></dl>

<p class="definition">Definition at line <a class="el" href="replace_8cpp_source.html#l00168">168</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a id="ga0d7d14badd05473e5a5c847b3f91b9e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d7d14badd05473e5a5c847b3f91b9e9">&#9670;&nbsp;</a></span>replace_all() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; replace_all </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of needle in str. </p>
<p>Each needle will be replaced with instead, if found. The replacement is done in the given string and a reference to the same is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to str </dd></dl>

<p class="definition">Definition at line <a class="el" href="replace_8cpp_source.html#l00182">182</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a id="ga768d59e5cc6d2c91f25a441ab4d265a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga768d59e5cc6d2c91f25a441ab4d265a6">&#9670;&nbsp;</a></span>replace_all() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; replace_all </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of needle in str. </p>
<p>Each needle will be replaced with instead, if found. The replacement is done in the given string and a reference to the same is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>character to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to str </dd></dl>

<p class="definition">Definition at line <a class="el" href="replace_8cpp_source.html#l00197">197</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a id="gac001aff0fa6c3bee2e9755e3ddd516f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac001aff0fa6c3bee2e9755e3ddd516f9">&#9670;&nbsp;</a></span>replace_all() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string replace_all </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of needle in str. </p>
<p>Each needle will be replaced with instead, if found. Returns a copy of the string with possible replacements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with replacements </dd></dl>

<p class="definition">Definition at line <a class="el" href="replace_8cpp_source.html#l00212">212</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a id="gadfe9c066393585d1a769cbd55e9f9960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadfe9c066393585d1a769cbd55e9f9960">&#9670;&nbsp;</a></span>replace_all() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string replace_all </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of needle in str. </p>
<p>Each needle will be replaced with instead, if found. Returns a copy of the string with possible replacements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with replacements </dd></dl>

<p class="definition">Definition at line <a class="el" href="replace_8cpp_source.html#l00227">227</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a id="ga4e3b406ea495a236fff401c3585d8814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4e3b406ea495a236fff401c3585d8814">&#9670;&nbsp;</a></span>replace_all() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string replace_all </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of needle in str. </p>
<p>Each needle will be replaced with instead, if found. Returns a copy of the string with possible replacements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with replacements </dd></dl>

<p class="definition">Definition at line <a class="el" href="replace_8cpp_source.html#l00242">242</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a id="ga14cfa75fa579e1d4943855455d9e605d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14cfa75fa579e1d4943855455d9e605d">&#9670;&nbsp;</a></span>replace_all() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string replace_all </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of needle in str. </p>
<p>Each needle will be replaced with instead, if found. Returns a copy of the string with possible replacements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with replacements </dd></dl>

<p class="definition">Definition at line <a class="el" href="replace_8cpp_source.html#l00257">257</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a id="gae87b40ae8e461c110fffcb7a12b066d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae87b40ae8e461c110fffcb7a12b066d5">&#9670;&nbsp;</a></span>replace_all() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string replace_all </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of needle in str. </p>
<p>Each needle will be replaced with instead, if found. Returns a copy of the string with possible replacements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>character to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with replacements </dd></dl>

<p class="definition">Definition at line <a class="el" href="replace_8cpp_source.html#l00273">273</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a id="gaca0aeb9a74105ec849e939229d47970b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca0aeb9a74105ec849e939229d47970b">&#9670;&nbsp;</a></span>replace_first() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; replace_first </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace only the first occurrence of needle in str. </p>
<p>The needle will be replaced with instead, if found. The replacement is done in the given string and a reference to the same is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to str </dd></dl>

<p class="definition">Definition at line <a class="el" href="replace_8cpp_source.html#l00021">21</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a id="ga32d2a706e20d6e5b07cbb677c340deba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga32d2a706e20d6e5b07cbb677c340deba">&#9670;&nbsp;</a></span>replace_first() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; replace_first </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace only the first occurrence of needle in str. </p>
<p>The needle will be replaced with instead, if found. The replacement is done in the given string and a reference to the same is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to str </dd></dl>

<p class="definition">Definition at line <a class="el" href="replace_8cpp_source.html#l00032">32</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a id="gab2b83d93d49145437aec2964f30e4cd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2b83d93d49145437aec2964f30e4cd1">&#9670;&nbsp;</a></span>replace_first() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; replace_first </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace only the first occurrence of needle in str. </p>
<p>The needle will be replaced with instead, if found. The replacement is done in the given string and a reference to the same is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to str </dd></dl>

<p class="definition">Definition at line <a class="el" href="replace_8cpp_source.html#l00043">43</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a id="ga6ed49bc3eebffeefeff05f84ffbcc086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ed49bc3eebffeefeff05f84ffbcc086">&#9670;&nbsp;</a></span>replace_first() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; replace_first </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace only the first occurrence of needle in str. </p>
<p>The needle will be replaced with instead, if found. The replacement is done in the given string and a reference to the same is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to str </dd></dl>

<p class="definition">Definition at line <a class="el" href="replace_8cpp_source.html#l00054">54</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a id="ga4865798a465a43845804dda0fe21f888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4865798a465a43845804dda0fe21f888">&#9670;&nbsp;</a></span>replace_first() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; replace_first </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace only the first occurrence of needle in str. </p>
<p>The needle will be replaced with instead, if found. The replacement is done in the given string and a reference to the same is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>character to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to str </dd></dl>

<p class="definition">Definition at line <a class="el" href="replace_8cpp_source.html#l00065">65</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a id="ga8b0092a333e84d0c4eaae50955bc5a71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b0092a333e84d0c4eaae50955bc5a71">&#9670;&nbsp;</a></span>replace_first() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string replace_first </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace only the first occurrence of needle in str. </p>
<p>The needle will be replaced with instead, if found. Returns a copy of the string with the possible replacement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with replacement </dd></dl>

<p class="definition">Definition at line <a class="el" href="replace_8cpp_source.html#l00078">78</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a id="gab6b1e9aa3d513c96cd5973e50551d6b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6b1e9aa3d513c96cd5973e50551d6b5">&#9670;&nbsp;</a></span>replace_first() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string replace_first </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace only the first occurrence of needle in str. </p>
<p>The needle will be replaced with instead, if found. Returns a copy of the string with the possible replacement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with replacement </dd></dl>

<p class="definition">Definition at line <a class="el" href="replace_8cpp_source.html#l00091">91</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a id="gae7e6db7b1dfe54efc4b195f27df5ed71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7e6db7b1dfe54efc4b195f27df5ed71">&#9670;&nbsp;</a></span>replace_first() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string replace_first </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace only the first occurrence of needle in str. </p>
<p>The needle will be replaced with instead, if found. Returns a copy of the string with the possible replacement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with replacement </dd></dl>

<p class="definition">Definition at line <a class="el" href="replace_8cpp_source.html#l00103">103</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a id="ga711f2f36ac6d9cb35a6a63672e47a47c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga711f2f36ac6d9cb35a6a63672e47a47c">&#9670;&nbsp;</a></span>replace_first() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string replace_first </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace only the first occurrence of needle in str. </p>
<p>The needle will be replaced with instead, if found. Returns a copy of the string with the possible replacement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with replacement </dd></dl>

<p class="definition">Definition at line <a class="el" href="replace_8cpp_source.html#l00115">115</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a id="ga276e1110c0ea48a01ef5a84f8ff40f37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga276e1110c0ea48a01ef5a84f8ff40f37">&#9670;&nbsp;</a></span>replace_first() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string replace_first </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace only the first occurrence of needle in str. </p>
<p>The needle will be replaced with instead, if found. Returns a copy of the string with the possible replacement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>character to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with replacement </dd></dl>

<p class="definition">Definition at line <a class="el" href="replace_8cpp_source.html#l00127">127</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a id="ga4fb56b145f00428be03f74257c61f1cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4fb56b145f00428be03f74257c61f1cc">&#9670;&nbsp;</a></span>split() <span class="overload">[1/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; split </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em> = <code>std::string::npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given string at each separator character into distinct substrings. </p>
<p>Multiple consecutive separators are considered individually and will result in empty split substrings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sep</td><td>separator character </td></tr>
    <tr><td class="paramname">str</td><td>string to split </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of parts returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing each split substring </dd></dl>

<p class="definition">Definition at line <a class="el" href="split_8cpp_source.html#l00020">20</a> of file <a class="el" href="split_8cpp_source.html">split.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="multiway__merge__splitting_8hpp_source.html#l00057">tlx::multiway_merge_detail::equally_split()</a>, <a class="el" href="btree_8hpp_source.html#l01928">BTree&lt; key_type, value_type, key_of_value, key_compare, traits, true, allocator_type &gt;::insert_descend()</a>, <a class="el" href="tpch__run_8cpp_source.html#l00167">JoinTPCH4()</a>, <a class="el" href="parallel__mergesort_8hpp_source.html#l00280">tlx::parallel_mergesort_base()</a>, <a class="el" href="config_8cpp_source.html#l00403">disk_config::parse_fileio()</a>, <a class="el" href="config_8cpp_source.html#l00336">disk_config::parse_line()</a>, <a class="el" href="percentiles_8cpp_source.html#l00031">Percentiles()</a>, <a class="el" href="extlib_2tlx_2tlx_2algorithm_2multiway__merge_8hpp_source.html#l00232">tlx::multiway_merge_detail::prepare_unguarded()</a>, <a class="el" href="extlib_2tlx_2tlx_2algorithm_2multiway__merge_8hpp_source.html#l00310">tlx::multiway_merge_detail::prepare_unguarded_sentinel()</a>, <a class="el" href="context_8cpp_source.html#l00419">thrill::api::RunBackendLoopback()</a>, and <a class="el" href="split_8cpp_source.html#l00028">tlx::split()</a>.</p>

</div>
</div>
<a id="gad838882b8fc992742b09450925758b32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad838882b8fc992742b09450925758b32">&#9670;&nbsp;</a></span>split() <span class="overload">[2/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; split </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em> = <code>std::string::npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given string at each separator string into distinct substrings. </p>
<p>Multiple consecutive separators are considered individually and will result in empty split substrings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sep</td><td>separator string </td></tr>
    <tr><td class="paramname">str</td><td>string to split </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of parts returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing each split substring </dd></dl>

<p class="definition">Definition at line <a class="el" href="split_8cpp_source.html#l00028">28</a> of file <a class="el" href="split_8cpp_source.html">split.cpp</a>.</p>

<p class="reference">References <a class="el" href="split_8cpp_source.html#l00020">tlx::split()</a>.</p>

</div>
</div>
<a id="ga0d57e8e6ac19e94787bf3cd44a79c1fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0d57e8e6ac19e94787bf3cd44a79c1fe">&#9670;&nbsp;</a></span>split() <span class="overload">[3/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em> = <code>std::string::npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given string at each separator string into distinct substrings. </p>
<p>Multiple consecutive separators are considered individually and will result in empty split substrings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sep</td><td>separator string </td></tr>
    <tr><td class="paramname">str</td><td>string to split </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of parts returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing each split substring </dd></dl>

<p class="definition">Definition at line <a class="el" href="split_8cpp_source.html#l00036">36</a> of file <a class="el" href="split_8cpp_source.html">split.cpp</a>.</p>

<p class="reference">References <a class="el" href="split_8cpp_source.html#l00020">tlx::split()</a>.</p>

</div>
</div>
<a id="ga00c921a6a793d9c4e59e380b2bb32fca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00c921a6a793d9c4e59e380b2bb32fca">&#9670;&nbsp;</a></span>split() <span class="overload">[4/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; split </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>min_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given string at each separator character into distinct substrings. </p>
<p>Multiple consecutive separators are considered individually and will result in empty split substrings. Returns a vector of strings with at least min_fields and at most limit_fields, empty fields are added if needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sep</td><td>separator string </td></tr>
    <tr><td class="paramname">str</td><td>string to split </td></tr>
    <tr><td class="paramname">min_fields</td><td>minimum number of parts returned </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of parts returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing each split substring </dd></dl>

<p class="definition">Definition at line <a class="el" href="split_8cpp_source.html#l00047">47</a> of file <a class="el" href="split_8cpp_source.html">split.cpp</a>.</p>

<p class="reference">References <a class="el" href="split_8cpp_source.html#l00020">tlx::split()</a>.</p>

</div>
</div>
<a id="gac5fb737c26e5fa4d63467b0ded2a1b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5fb737c26e5fa4d63467b0ded2a1b90">&#9670;&nbsp;</a></span>split() <span class="overload">[5/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; split </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>min_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given string at each separator string into distinct substrings. </p>
<p>Multiple consecutive separators are considered individually and will result in empty split substrings. Returns a vector of strings with at least min_fields and at most limit_fields, empty fields are added if needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sep</td><td>separator string </td></tr>
    <tr><td class="paramname">str</td><td>string to split </td></tr>
    <tr><td class="paramname">min_fields</td><td>minimum number of parts returned </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of parts returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing each split substring </dd></dl>

<p class="definition">Definition at line <a class="el" href="split_8cpp_source.html#l00056">56</a> of file <a class="el" href="split_8cpp_source.html">split.cpp</a>.</p>

<p class="reference">References <a class="el" href="split_8cpp_source.html#l00020">tlx::split()</a>.</p>

</div>
</div>
<a id="ga7a0a5d581ecd362eaae43bdee50b3896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a0a5d581ecd362eaae43bdee50b3896">&#9670;&nbsp;</a></span>split() <span class="overload">[6/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>min_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given string at each separator string into distinct substrings. </p>
<p>Multiple consecutive separators are considered individually and will result in empty split substrings. Returns a vector of strings with at least min_fields and at most limit_fields, empty fields are added if needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sep</td><td>separator string </td></tr>
    <tr><td class="paramname">str</td><td>string to split </td></tr>
    <tr><td class="paramname">min_fields</td><td>minimum number of parts returned </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of parts returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing each split substring </dd></dl>

<p class="definition">Definition at line <a class="el" href="split_8cpp_source.html#l00065">65</a> of file <a class="el" href="split_8cpp_source.html">split.cpp</a>.</p>

<p class="reference">References <a class="el" href="split_8cpp_source.html#l00020">tlx::split()</a>.</p>

</div>
</div>
<a id="ga17fd4a3698ca54702b30dddc232bf903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17fd4a3698ca54702b30dddc232bf903">&#9670;&nbsp;</a></span>split() <span class="overload">[7/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; &amp; split </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; *&#160;</td>
          <td class="paramname"><em>into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em> = <code>std::string::npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given string at each separator character into distinct substrings. </p>
<p>Multiple consecutive separators are considered individually and will result in empty split substrings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">into</td><td>destination std::vector </td></tr>
    <tr><td class="paramname">sep</td><td>separator character </td></tr>
    <tr><td class="paramname">str</td><td>string to split </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of parts returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing each split substring </dd></dl>

<p class="definition">Definition at line <a class="el" href="split_8cpp_source.html#l00077">77</a> of file <a class="el" href="split_8cpp_source.html">split.cpp</a>.</p>

</div>
</div>
<a id="ga177a8fd78d5cc4e0fd8dc50810967d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga177a8fd78d5cc4e0fd8dc50810967d89">&#9670;&nbsp;</a></span>split() <span class="overload">[8/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; &amp; split </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; *&#160;</td>
          <td class="paramname"><em>into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em> = <code>std::string::npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given string at each separator string into distinct substrings. </p>
<p>Multiple consecutive separators are considered individually and will result in empty split substrings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">into</td><td>destination std::vector </td></tr>
    <tr><td class="paramname">sep</td><td>separator string </td></tr>
    <tr><td class="paramname">str</td><td>string to split </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of parts returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing each split substring </dd></dl>

<p class="definition">Definition at line <a class="el" href="split_8cpp_source.html#l00147">147</a> of file <a class="el" href="split_8cpp_source.html">split.cpp</a>.</p>

<p class="reference">References <a class="el" href="split_8cpp_source.html#l00020">tlx::split()</a>.</p>

</div>
</div>
<a id="ga431c048d40a30f531e2e419e26582e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga431c048d40a30f531e2e419e26582e4c">&#9670;&nbsp;</a></span>split() <span class="overload">[9/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; &amp; split </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; *&#160;</td>
          <td class="paramname"><em>into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em> = <code>std::string::npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given string at each separator string into distinct substrings. </p>
<p>Multiple consecutive separators are considered individually and will result in empty split substrings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">into</td><td>destination std::vector </td></tr>
    <tr><td class="paramname">sep</td><td>separator string </td></tr>
    <tr><td class="paramname">str</td><td>string to split </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of parts returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing each split substring </dd></dl>

<p class="definition">Definition at line <a class="el" href="split_8cpp_source.html#l00155">155</a> of file <a class="el" href="split_8cpp_source.html">split.cpp</a>.</p>

<p class="reference">References <a class="el" href="split_8cpp_source.html#l00020">tlx::split()</a>.</p>

</div>
</div>
<a id="ga4997fcbeb1c6a97d23bce8ea590b3ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4997fcbeb1c6a97d23bce8ea590b3ce3">&#9670;&nbsp;</a></span>split() <span class="overload">[10/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; &amp; split </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; *&#160;</td>
          <td class="paramname"><em>into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>min_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given string at each separator character into distinct substrings. </p>
<p>Multiple consecutive separators are considered individually and will result in empty split substrings. Returns a vector of strings with at least min_fields and at most limit_fields, empty fields are added if needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">into</td><td>destination std::vector </td></tr>
    <tr><td class="paramname">sep</td><td>separator character </td></tr>
    <tr><td class="paramname">str</td><td>string to split </td></tr>
    <tr><td class="paramname">min_fields</td><td>minimum number of parts returned </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of parts returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing each split substring </dd></dl>

<p class="definition">Definition at line <a class="el" href="split_8cpp_source.html#l00166">166</a> of file <a class="el" href="split_8cpp_source.html">split.cpp</a>.</p>

<p class="reference">References <a class="el" href="split_8cpp_source.html#l00020">tlx::split()</a>.</p>

</div>
</div>
<a id="ga40222e4ae7f552a3d6f8d485ced3d91d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga40222e4ae7f552a3d6f8d485ced3d91d">&#9670;&nbsp;</a></span>split() <span class="overload">[11/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; &amp; split </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; *&#160;</td>
          <td class="paramname"><em>into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>min_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given string at each separator string into distinct substrings. </p>
<p>Multiple consecutive separators are considered individually and will result in empty split substrings. Returns a vector of strings with at least min_fields and at most limit_fields, empty fields are added if needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">into</td><td>destination std::vector </td></tr>
    <tr><td class="paramname">sep</td><td>separator string </td></tr>
    <tr><td class="paramname">str</td><td>string to split </td></tr>
    <tr><td class="paramname">min_fields</td><td>minimum number of parts returned </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of parts returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing each split substring </dd></dl>

<p class="definition">Definition at line <a class="el" href="split_8cpp_source.html#l00179">179</a> of file <a class="el" href="split_8cpp_source.html">split.cpp</a>.</p>

<p class="reference">References <a class="el" href="split_8cpp_source.html#l00020">tlx::split()</a>.</p>

</div>
</div>
<a id="ga4aa7e0fb9bd81e31214087d3d85367a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4aa7e0fb9bd81e31214087d3d85367a3">&#9670;&nbsp;</a></span>split() <span class="overload">[12/12]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; &amp; split </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; *&#160;</td>
          <td class="paramname"><em>into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>min_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given string at each separator string into distinct substrings. </p>
<p>Multiple consecutive separators are considered individually and will result in empty split substrings. Returns a vector of strings with at least min_fields and at most limit_fields, empty fields are added if needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">into</td><td>destination std::vector </td></tr>
    <tr><td class="paramname">sep</td><td>separator string </td></tr>
    <tr><td class="paramname">str</td><td>string to split </td></tr>
    <tr><td class="paramname">min_fields</td><td>minimum number of parts returned </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of parts returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing each split substring </dd></dl>

<p class="definition">Definition at line <a class="el" href="split_8cpp_source.html#l00192">192</a> of file <a class="el" href="split_8cpp_source.html">split.cpp</a>.</p>

<p class="reference">References <a class="el" href="split_8cpp_source.html#l00020">tlx::split()</a>.</p>

</div>
</div>
<a id="gafc48ce717ba77df6c6f395fb07bc8a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafc48ce717ba77df6c6f395fb07bc8a1e">&#9670;&nbsp;</a></span>split_quoted() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; split_quoted </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>quote</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>escape</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given string at each separator character into distinct substrings. </p>
<p>Multiple separators are joined and will not result in empty split substrings. Quoted fields extend to the next quote. Quoted fields may containg escaped quote, and \n \r \t \\ sequences. </p>

<p class="definition">Definition at line <a class="el" href="split__quoted_8cpp_source.html#l00018">18</a> of file <a class="el" href="split__quoted_8cpp_source.html">split_quoted.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="split__quoted_8cpp_source.html#l00122">tlx::split_quoted()</a>.</p>

</div>
</div>
<a id="ga0210d995cdc4df9aafcd09c005571449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0210d995cdc4df9aafcd09c005571449">&#9670;&nbsp;</a></span>split_quoted() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; split_quoted </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given string at each space into distinct substrings. </p>
<p>Multiple spaces are joined and will not result in empty split substrings. Quoted fields extend to the next quote. Quoted fields may containg escaped quote, and \n \r \t \\ sequences. </p>

<p class="definition">Definition at line <a class="el" href="split__quoted_8cpp_source.html#l00122">122</a> of file <a class="el" href="split__quoted_8cpp_source.html">split_quoted.cpp</a>.</p>

<p class="reference">References <a class="el" href="split__quoted_8cpp_source.html#l00018">tlx::split_quoted()</a>.</p>

</div>
</div>
<a id="ga6c9fac87ddaeb902c500f4854af69bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c9fac87ddaeb902c500f4854af69bec">&#9670;&nbsp;</a></span>split_view()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void tlx::split_view </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Functor &amp;&amp;&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em> = <code>std::string::npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Split the given string at each separator character into distinct substrings, and call the given callback with a <a class="el" href="classtlx_1_1StringView.html" title="StringView is a reference to a part of a string, consisting of only a char pointer and a length...">StringView</a> for each substring. </p>
<p>Multiple consecutive separators are considered individually and will result in empty split substrings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to split </td></tr>
    <tr><td class="paramname">sep</td><td>separator character </td></tr>
    <tr><td class="paramname">callback</td><td>callback taking <a class="el" href="classtlx_1_1StringView.html" title="StringView is a reference to a part of a string, consisting of only a char pointer and a length...">StringView</a> of substring </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of parts returned </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="split__view_8hpp_source.html#l00038">38</a> of file <a class="el" href="split__view_8hpp_source.html">split_view.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="word__count_8hpp_source.html#l00074">examples::word_count::HashWordCountExample()</a>, <a class="el" href="word__count__sequential_8cpp_source.html#l00023">main()</a>, <a class="el" href="word__count__simple_8cpp_source.html#l00020">WordCount()</a>, and <a class="el" href="word__count_8hpp_source.html#l00035">examples::word_count::WordCount()</a>.</p>

</div>
</div>
<a id="ga92d58b1e8b06cbb57400b5959281a4a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92d58b1e8b06cbb57400b5959281a4a1">&#9670;&nbsp;</a></span>split_words()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; split_words </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em> = <code>std::string::npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given string by whitespaces into distinct words. </p>
<p>Multiple consecutive whitespaces are considered as one split point. Whitespaces are space, tab, newline and carriage-return.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to split </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of parts returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing each split substring </dd></dl>

<p class="definition">Definition at line <a class="el" href="split__words_8cpp_source.html#l00015">15</a> of file <a class="el" href="split__words_8cpp_source.html">split_words.cpp</a>.</p>

</div>
</div>
<a id="gaafc9efa79c49c462b0ee723e4f9b384d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafc9efa79c49c462b0ee723e4f9b384d">&#9670;&nbsp;</a></span>ssnprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string std::string ssnprintf </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper for return the result of a snprintf() call inside a std::string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_size</td><td>maximum length of output string, longer ones are truncated. </td></tr>
    <tr><td class="paramname">fmt</td><td>printf format and additional parameters </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ssprintf_8cpp_source.html#l00042">42</a> of file <a class="el" href="ssprintf_8cpp_source.html">ssprintf.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="file__io_8cpp_source.html#l00071">thrill::vfs::FillFilePattern()</a>.</p>

</div>
</div>
<a id="ga1cc4f715331a96631370a8a25d6e9526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cc4f715331a96631370a8a25d6e9526">&#9670;&nbsp;</a></span>ssnprintf_generic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">String tlx::ssnprintf_generic </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper for return the result of a snprintf() call inside a string object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_size</td><td>maximum length of output string, longer ones are truncated. </td></tr>
    <tr><td class="paramname">fmt</td><td>printf format and additional parameters </td></tr>
  </table>
  </dd>
</dl>

<p class="reference">Referenced by <a class="el" href="ssprintf__generic_8hpp_source.html#l00035">tlx::ssprintf_generic()</a>.</p>

</div>
</div>
<a id="gae5a94b0f02730f1df3009eb5ce67eb17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae5a94b0f02730f1df3009eb5ce67eb17">&#9670;&nbsp;</a></span>ssprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string ssprintf </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper for return the result of a sprintf() call inside a std::string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fmt</td><td>printf format and additional parameters </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="ssprintf_8cpp_source.html#l00018">18</a> of file <a class="el" href="ssprintf_8cpp_source.html">ssprintf.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="construct__wt_8hpp_source.html#l00035">examples::suffix_sorting::ConstructWaveletTree()</a>, <a class="el" href="page__rank__run_8cpp_source.html#l00122">RunJoinPageRankEdgePerLine()</a>, <a class="el" href="page__rank__run_8cpp_source.html#l00049">RunPageRankEdgePerLine()</a>, and <a class="el" href="page__rank__run_8cpp_source.html#l00254">RunPageRankJoinGenerated()</a>.</p>

</div>
</div>
<a id="gaa45e4c8639177f5deb682313a572c32b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa45e4c8639177f5deb682313a572c32b">&#9670;&nbsp;</a></span>ssprintf_generic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">String tlx::ssprintf_generic </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>fmt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper for return the result of a sprintf() call inside a string object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fmt</td><td>printf format and additional parameters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga77af8ef839dcd6f90d26bcb68413df1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga77af8ef839dcd6f90d26bcb68413df1b">&#9670;&nbsp;</a></span>starts_with() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool starts_with </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given match string is located at the start of this string. </p>

<p class="definition">Definition at line <a class="el" href="starts__with_8cpp_source.html#l00021">21</a> of file <a class="el" href="starts__with_8cpp_source.html">starts_with.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="file__io_8cpp_source.html#l00128">thrill::vfs::Glob()</a>, <a class="el" href="file__io_8cpp_source.html#l00055">thrill::vfs::IsRemoteUri()</a>, <a class="el" href="file__io_8cpp_source.html#l00180">thrill::vfs::OpenReadStream()</a>, and <a class="el" href="file__io_8cpp_source.html#l00211">thrill::vfs::OpenWriteStream()</a>.</p>

</div>
</div>
<a id="gaabdd7c8689c583acd1e58e5b87b18ae4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaabdd7c8689c583acd1e58e5b87b18ae4">&#9670;&nbsp;</a></span>starts_with() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool starts_with </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given match string is located at the start of this string. </p>

<p class="definition">Definition at line <a class="el" href="starts__with_8cpp_source.html#l00029">29</a> of file <a class="el" href="starts__with_8cpp_source.html">starts_with.cpp</a>.</p>

</div>
</div>
<a id="ga125efbe989d08402389613766af825b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga125efbe989d08402389613766af825b5">&#9670;&nbsp;</a></span>starts_with() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool starts_with </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given match string is located at the start of this string. </p>

<p class="definition">Definition at line <a class="el" href="starts__with_8cpp_source.html#l00038">38</a> of file <a class="el" href="starts__with_8cpp_source.html">starts_with.cpp</a>.</p>

</div>
</div>
<a id="gadc5cce7e8c7fd30078b9129a7ae1d74b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc5cce7e8c7fd30078b9129a7ae1d74b">&#9670;&nbsp;</a></span>starts_with() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool starts_with </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given match string is located at the start of this string. </p>

<p class="definition">Definition at line <a class="el" href="starts__with_8cpp_source.html#l00047">47</a> of file <a class="el" href="starts__with_8cpp_source.html">starts_with.cpp</a>.</p>

</div>
</div>
<a id="ga9ca04814cbc556649adfd9fa2dbb40e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ca04814cbc556649adfd9fa2dbb40e6">&#9670;&nbsp;</a></span>starts_with_icase() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool starts_with_icase </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given match string is located at the start of this string. </p>
<p>Compares the characters case-insensitively. </p>

<p class="definition">Definition at line <a class="el" href="starts__with_8cpp_source.html#l00055">55</a> of file <a class="el" href="starts__with_8cpp_source.html">starts_with.cpp</a>.</p>

<p class="reference">References <a class="el" href="to__lower_8cpp_source.html#l00017">tlx::to_lower()</a>.</p>

</div>
</div>
<a id="ga9f3acf713798426fde1285f5ccab8922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f3acf713798426fde1285f5ccab8922">&#9670;&nbsp;</a></span>starts_with_icase() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool starts_with_icase </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given match string is located at the start of this string. </p>
<p>Compares the characters case-insensitively. </p>

<p class="definition">Definition at line <a class="el" href="starts__with_8cpp_source.html#l00064">64</a> of file <a class="el" href="starts__with_8cpp_source.html">starts_with.cpp</a>.</p>

<p class="reference">References <a class="el" href="to__lower_8cpp_source.html#l00017">tlx::to_lower()</a>.</p>

</div>
</div>
<a id="gab6d169441d65d96bceb7c936e88afc67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6d169441d65d96bceb7c936e88afc67">&#9670;&nbsp;</a></span>starts_with_icase() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool starts_with_icase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given match string is located at the start of this string. </p>
<p>Compares the characters case-insensitively. </p>

<p class="definition">Definition at line <a class="el" href="starts__with_8cpp_source.html#l00073">73</a> of file <a class="el" href="starts__with_8cpp_source.html">starts_with.cpp</a>.</p>

<p class="reference">References <a class="el" href="to__lower_8cpp_source.html#l00017">tlx::to_lower()</a>.</p>

</div>
</div>
<a id="gadbcdc1f2a056e954b197ce9c1d236522"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbcdc1f2a056e954b197ce9c1d236522">&#9670;&nbsp;</a></span>starts_with_icase() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool starts_with_icase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given match string is located at the start of this string. </p>
<p>Compares the characters case-insensitively. </p>

<p class="definition">Definition at line <a class="el" href="starts__with_8cpp_source.html#l00083">83</a> of file <a class="el" href="starts__with_8cpp_source.html">starts_with.cpp</a>.</p>

<p class="reference">References <a class="el" href="to__lower_8cpp_source.html#l00017">tlx::to_lower()</a>.</p>

</div>
</div>
<a id="ga355a332620f8220ecbb0dc5a0aa67350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga355a332620f8220ecbb0dc5a0aa67350">&#9670;&nbsp;</a></span>to_lower() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char to_lower </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform the given character to lower case without any localization. </p>

<p class="definition">Definition at line <a class="el" href="to__lower_8cpp_source.html#l00017">17</a> of file <a class="el" href="to__lower_8cpp_source.html">to_lower.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="levenshtein_8hpp_source.html#l00048">LevenshteinStandardICaseParameters::char_equal()</a>, <a class="el" href="compare__icase_8cpp_source.html#l00018">tlx::compare_icase()</a>, <a class="el" href="ends__with_8cpp_source.html#l00075">tlx::ends_with_icase()</a>, <a class="el" href="equal__icase_8cpp_source.html#l00018">tlx::equal_icase()</a>, <a class="el" href="less__icase_8cpp_source.html#l00018">tlx::less_icase()</a>, <a class="el" href="starts__with_8cpp_source.html#l00055">tlx::starts_with_icase()</a>, and <a class="el" href="to__lower_8cpp_source.html#l00023">tlx::to_lower()</a>.</p>

</div>
</div>
<a id="ga4ec240b74b77e3ce42f8d67079dea430"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4ec240b74b77e3ce42f8d67079dea430">&#9670;&nbsp;</a></span>to_lower() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; to_lower </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms the given string to lowercase and returns a reference to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p class="definition">Definition at line <a class="el" href="to__lower_8cpp_source.html#l00023">23</a> of file <a class="el" href="to__lower_8cpp_source.html">to_lower.cpp</a>.</p>

<p class="reference">References <a class="el" href="to__lower_8cpp_source.html#l00017">tlx::to_lower()</a>.</p>

</div>
</div>
<a id="ga647f5157d00473cf9bf37c92044bd9a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga647f5157d00473cf9bf37c92044bd9a8">&#9670;&nbsp;</a></span>to_lower() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string to_lower </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a copy of the given string converted to lowercase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new string lowercased </dd></dl>

<p class="definition">Definition at line <a class="el" href="to__lower_8cpp_source.html#l00029">29</a> of file <a class="el" href="to__lower_8cpp_source.html">to_lower.cpp</a>.</p>

<p class="reference">References <a class="el" href="to__lower_8cpp_source.html#l00017">tlx::to_lower()</a>.</p>

</div>
</div>
<a id="gaa00b5d705507da8f74f1ba3874174d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa00b5d705507da8f74f1ba3874174d8d">&#9670;&nbsp;</a></span>to_upper() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char to_upper </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform the given character to upper case without any localization. </p>

<p class="definition">Definition at line <a class="el" href="to__upper_8cpp_source.html#l00017">17</a> of file <a class="el" href="to__upper_8cpp_source.html">to_upper.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="to__upper_8cpp_source.html#l00023">tlx::to_upper()</a>.</p>

</div>
</div>
<a id="ga7d9edcc3303203825126d7d422e8ab75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d9edcc3303203825126d7d422e8ab75">&#9670;&nbsp;</a></span>to_upper() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; to_upper </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms the given string to uppercase and returns a reference to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p class="definition">Definition at line <a class="el" href="to__upper_8cpp_source.html#l00023">23</a> of file <a class="el" href="to__upper_8cpp_source.html">to_upper.cpp</a>.</p>

<p class="reference">References <a class="el" href="to__upper_8cpp_source.html#l00017">tlx::to_upper()</a>.</p>

</div>
</div>
<a id="ga2be559f6e498862bec070f122feb6e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2be559f6e498862bec070f122feb6e14">&#9670;&nbsp;</a></span>to_upper() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string to_upper </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a copy of the given string converted to uppercase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new string uppercased </dd></dl>

<p class="definition">Definition at line <a class="el" href="to__upper_8cpp_source.html#l00029">29</a> of file <a class="el" href="to__upper_8cpp_source.html">to_upper.cpp</a>.</p>

<p class="reference">References <a class="el" href="to__upper_8cpp_source.html#l00017">tlx::to_upper()</a>.</p>

</div>
</div>
<a id="gac44946abf6c2e869d57d1ce3d2c9a7e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac44946abf6c2e869d57d1ce3d2c9a7e8">&#9670;&nbsp;</a></span>trim() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; trim </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string in-place on the left and right. </p>
<p>Removes all characters in the given drop array, which defaults to " \r\n\t".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p class="definition">Definition at line <a class="el" href="trim_8cpp_source.html#l00020">20</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="trim_8cpp_source.html#l00050">tlx::trim()</a>.</p>

</div>
</div>
<a id="ga033f3fec1db85f0203f9f33ef0cfe271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga033f3fec1db85f0203f9f33ef0cfe271">&#9670;&nbsp;</a></span>trim() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; trim </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string in-place on the left and right. </p>
<p>Removes all characters in the given drop array, which defaults to " \r\n\t".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p class="definition">Definition at line <a class="el" href="trim_8cpp_source.html#l00024">24</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a id="ga9f5067eb83515704232300be374b2857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f5067eb83515704232300be374b2857">&#9670;&nbsp;</a></span>trim() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; trim </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string in-place on the left and right. </p>
<p>Removes all characters in the given drop array, which defaults to " \r\n\t".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p class="definition">Definition at line <a class="el" href="trim_8cpp_source.html#l00037">37</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a id="ga5a01f705cc7b4a7317a57f6bf41aef25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5a01f705cc7b4a7317a57f6bf41aef25">&#9670;&nbsp;</a></span>trim() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string trim </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string in-place on the left and right. </p>
<p>Removes all characters in the given drop array, which defaults to " \r\n\t".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p class="definition">Definition at line <a class="el" href="trim_8cpp_source.html#l00050">50</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

<p class="reference">References <a class="el" href="trim_8cpp_source.html#l00020">tlx::trim()</a>.</p>

</div>
</div>
<a id="gaadf066d809b088ceda29675da3420c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadf066d809b088ceda29675da3420c3c">&#9670;&nbsp;</a></span>trim() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string trim </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string in-place on the left and right. </p>
<p>Removes all characters in the given drop array, which defaults to " \r\n\t".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p class="definition">Definition at line <a class="el" href="trim_8cpp_source.html#l00054">54</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a id="ga7aacbd967bfb76fcb4b4d977b4f5d838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7aacbd967bfb76fcb4b4d977b4f5d838">&#9670;&nbsp;</a></span>trim() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string trim </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string in-place on the left and right. </p>
<p>Removes all characters in the given drop array, which defaults to " \r\n\t".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p class="definition">Definition at line <a class="el" href="trim_8cpp_source.html#l00070">70</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a id="gacd01f5ea03e1d4a21ee26d2f3e20206f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacd01f5ea03e1d4a21ee26d2f3e20206f">&#9670;&nbsp;</a></span>trim_left() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; trim_left </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string in-place only on the left. </p>
<p>Removes all characters in the given drop array, which defaults to " \r\n\t".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p class="definition">Definition at line <a class="el" href="trim_8cpp_source.html#l00128">128</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="trim_8cpp_source.html#l00142">tlx::trim_left()</a>.</p>

</div>
</div>
<a id="ga059d265ada554d8653d877a28d4d518d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga059d265ada554d8653d877a28d4d518d">&#9670;&nbsp;</a></span>trim_left() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; trim_left </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string in-place only on the left. </p>
<p>Removes all characters in the given drop array, which defaults to " \r\n\t".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p class="definition">Definition at line <a class="el" href="trim_8cpp_source.html#l00132">132</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a id="ga9db0b1db4ab3774221363c2fafa8bbdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9db0b1db4ab3774221363c2fafa8bbdf">&#9670;&nbsp;</a></span>trim_left() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; trim_left </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string in-place only on the left. </p>
<p>Removes all characters in the given drop array, which defaults to " \r\n\t".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p class="definition">Definition at line <a class="el" href="trim_8cpp_source.html#l00137">137</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a id="ga58107ce115061cb45873f46778bfe836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58107ce115061cb45873f46778bfe836">&#9670;&nbsp;</a></span>trim_left() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string trim_left </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string only on the left. </p>
<p>Removes all characters in the given drop array, which defaults to " \r\n\t". Returns a copy of the string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new trimmed string </dd></dl>

<p class="definition">Definition at line <a class="el" href="trim_8cpp_source.html#l00142">142</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

<p class="reference">References <a class="el" href="trim_8cpp_source.html#l00128">tlx::trim_left()</a>.</p>

</div>
</div>
<a id="ga1bc881fad43aa1c573d47d459ed2a721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1bc881fad43aa1c573d47d459ed2a721">&#9670;&nbsp;</a></span>trim_left() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string trim_left </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string only on the left. </p>
<p>Removes all characters in the given drop array, which defaults to " \r\n\t". Returns a copy of the string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new trimmed string </dd></dl>

<p class="definition">Definition at line <a class="el" href="trim_8cpp_source.html#l00146">146</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a id="ga9f870dbf0b1602d063de42caefde8b68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f870dbf0b1602d063de42caefde8b68">&#9670;&nbsp;</a></span>trim_left() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string trim_left </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string only on the left. </p>
<p>Removes all characters in the given drop array, which defaults to " \r\n\t". Returns a copy of the string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new trimmed string </dd></dl>

<p class="definition">Definition at line <a class="el" href="trim_8cpp_source.html#l00153">153</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a id="ga387d6e51cf1f77b7ac7111e8f0ed7d48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga387d6e51cf1f77b7ac7111e8f0ed7d48">&#9670;&nbsp;</a></span>trim_right() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; trim_right </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string in-place only on the right. </p>
<p>Removes all characters in the given drop array, which defaults to " \r\n\t".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p class="definition">Definition at line <a class="el" href="trim_8cpp_source.html#l00094">94</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="trim_8cpp_source.html#l00108">tlx::trim_right()</a>.</p>

</div>
</div>
<a id="ga1480a3758759216e8206fc9bbb58c0da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1480a3758759216e8206fc9bbb58c0da">&#9670;&nbsp;</a></span>trim_right() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; trim_right </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string in-place only on the right. </p>
<p>Removes all characters in the given drop array, which defaults to " \r\n\t".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p class="definition">Definition at line <a class="el" href="trim_8cpp_source.html#l00098">98</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a id="gaff5e9a8a1501b420ae5a5f8eca2a2f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaff5e9a8a1501b420ae5a5f8eca2a2f01">&#9670;&nbsp;</a></span>trim_right() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; trim_right </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string in-place only on the right. </p>
<p>Removes all characters in the given drop array, which defaults to " \r\n\t".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p class="definition">Definition at line <a class="el" href="trim_8cpp_source.html#l00103">103</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a id="ga9fb8db490eae39cfd9819b407e8655ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9fb8db490eae39cfd9819b407e8655ee">&#9670;&nbsp;</a></span>trim_right() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string trim_right </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string only on the right. </p>
<p>Removes all characters in the given drop array, which defaults to " \r\n\t". Returns a copy of the string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new trimmed string </dd></dl>

<p class="definition">Definition at line <a class="el" href="trim_8cpp_source.html#l00108">108</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

<p class="reference">References <a class="el" href="trim_8cpp_source.html#l00094">tlx::trim_right()</a>.</p>

</div>
</div>
<a id="ga232bc2341b09eea7c6229b7b548f4f8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga232bc2341b09eea7c6229b7b548f4f8f">&#9670;&nbsp;</a></span>trim_right() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string trim_right </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string only on the right. </p>
<p>Removes all characters in the given drop array, which defaults to " \r\n\t". Returns a copy of the string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new trimmed string </dd></dl>

<p class="definition">Definition at line <a class="el" href="trim_8cpp_source.html#l00112">112</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a id="ga4b761b3a20c3f400f4f3451511016a07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4b761b3a20c3f400f4f3451511016a07">&#9670;&nbsp;</a></span>trim_right() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string trim_right </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string only on the right. </p>
<p>Removes all characters in the given drop array, which defaults to " \r\n\t". Returns a copy of the string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new trimmed string </dd></dl>

<p class="definition">Definition at line <a class="el" href="trim_8cpp_source.html#l00119">119</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a id="ga39619db78c7e916bff3544fb07cbe462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga39619db78c7e916bff3544fb07cbe462">&#9670;&nbsp;</a></span>union_words()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string union_words </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>wordsA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>wordsB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return union of two keyword sets. </p>

<p class="definition">Definition at line <a class="el" href="union__words_8cpp_source.html#l00016">16</a> of file <a class="el" href="union__words_8cpp_source.html">union_words.cpp</a>.</p>

<p class="reference">References <a class="el" href="contains__word_8cpp_source.html#l00019">tlx::contains_word()</a>.</p>

</div>
</div>
<a id="ga2d0ada76ddce7fc09d770fa512780839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2d0ada76ddce7fc09d770fa512780839">&#9670;&nbsp;</a></span>word_wrap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string word_wrap </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>wrap</em> = <code>80</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to wrap a string to 80 columns without split words. </p>
<p>All newlines are kept, new newline characters are inserted only at spaces, hence, words are never split. If words longer than 80 columns occur they are NOT broken. </p>

<p class="definition">Definition at line <a class="el" href="word__wrap_8cpp_source.html#l00022">22</a> of file <a class="el" href="word__wrap_8cpp_source.html">word_wrap.cpp</a>.</p>

<p class="reference">References <a class="el" href="word__wrap_8cpp_source.html#l00017">tlx::is_space()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Sat Apr 4 2020 07:53:57 for Thrill by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
