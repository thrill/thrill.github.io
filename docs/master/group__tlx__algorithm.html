<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Thrill: Algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Thrill
   &#160;<span id="projectnumber">0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__tlx__algorithm.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">Algorithms<div class="ingroups"><a class="el" href="group__layers.html">Thrill Layers</a> &raquo; <a class="el" href="group__tlx.html">tlx - C++ Extensions and Utilities</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacetlx_1_1multisequence__partition__detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx_1_1multisequence__partition__detail.html">tlx::multisequence_partition_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetlx_1_1multisequence__selection__detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx_1_1multisequence__selection__detail.html">tlx::multisequence_selection_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacetlx_1_1multiway__merge__detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacetlx_1_1multiway__merge__detail.html">tlx::multiway_merge_detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga98e900a348b28aa3709eb5e6d897ffbb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#ga98e900a348b28aa3709eb5e6d897ffbb">MultiwayMergeAlgorithm</a> { <br />
&#160;&#160;<a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbbac1488a90ba6e18d5f936e51cbc5625e1">MWMA_LOSER_TREE</a>, 
<a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbbadd051fbbe4e1346d6357c82d56add811">MWMA_LOSER_TREE_COMBINED</a>, 
<a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbba8f020d718b11548f7d45b3d56fb37981">MWMA_LOSER_TREE_SENTINEL</a>, 
<a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbba097e6877921551867e9681ff56411d10">MWMA_BUBBLE</a>, 
<br />
&#160;&#160;<a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbba9fbb6366507fb2f30a433c51366719b6">MWMA_ALGORITHM_LAST</a>, 
<a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbba332bba921707cc62f6a682b8ac2c9013">MWMA_ALGORITHM_DEFAULT</a> = MWMA_LOSER_TREE_COMBINED
<br />
 }<tr class="memdesc:ga98e900a348b28aa3709eb5e6d897ffbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different merging algorithms: bubblesort-alike, loser-tree variants, enum sentinel.  <a href="group__tlx__algorithm.html#ga98e900a348b28aa3709eb5e6d897ffbb">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga98e900a348b28aa3709eb5e6d897ffbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a7342a22bda2a80ef56d779ceae36c0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#ga8a7342a22bda2a80ef56d779ceae36c0">MultiwayMergeSplittingAlgorithm</a> { <a class="el" href="group__tlx__algorithm.html#gga8a7342a22bda2a80ef56d779ceae36c0abccc0e651299ce4048220b307340aff3">MWMSA_SAMPLING</a>, 
<a class="el" href="group__tlx__algorithm.html#gga8a7342a22bda2a80ef56d779ceae36c0aa7c13c05b4dd92e3fce043e8d4cc5f43">MWMSA_EXACT</a>, 
<a class="el" href="group__tlx__algorithm.html#gga8a7342a22bda2a80ef56d779ceae36c0a93014d67de65dba047c131661369e38c">MWMSA_LAST</a>, 
<a class="el" href="group__tlx__algorithm.html#gga8a7342a22bda2a80ef56d779ceae36c0acfb06584091121c62050c13c54e0e298">MWMSA_DEFAULT</a> = MWMSA_EXACT
 }<tr class="memdesc:ga8a7342a22bda2a80ef56d779ceae36c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different splitting strategies for sorting/merging: by sampling, exact.  <a href="group__tlx__algorithm.html#ga8a7342a22bda2a80ef56d779ceae36c0">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:ga8a7342a22bda2a80ef56d779ceae36c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga0801d65c092619953947c9c5bbeddc7b"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename T , typename BinaryOperation  = std::plus&lt;T&gt;&gt; </td></tr>
<tr class="memitem:ga0801d65c092619953947c9c5bbeddc7b"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#ga0801d65c092619953947c9c5bbeddc7b">exclusive_scan</a> (InputIterator first, InputIterator last, OutputIterator result, <a class="el" href="logistic__regression_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a> init, BinaryOperation binary_op=BinaryOperation())</td></tr>
<tr class="memdesc:ga0801d65c092619953947c9c5bbeddc7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes an exclusive prefix sum operation using binary_op the range [first, last), using init as the initial value, and writes the results to the range beginning at result.  <a href="group__tlx__algorithm.html#ga0801d65c092619953947c9c5bbeddc7b">More...</a><br /></td></tr>
<tr class="separator:ga0801d65c092619953947c9c5bbeddc7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe360874d7ebb9890f27be61d5b8e599"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename Comparator &gt; </td></tr>
<tr class="memitem:gabe360874d7ebb9890f27be61d5b8e599"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#gabe360874d7ebb9890f27be61d5b8e599">is_sorted_cmp</a> (ForwardIterator first, ForwardIterator last, Comparator cmp)</td></tr>
<tr class="memdesc:gabe360874d7ebb9890f27be61d5b8e599"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a range is sorted using a three-way Comparator (with memcmp() semantics).  <a href="group__tlx__algorithm.html#gabe360874d7ebb9890f27be61d5b8e599">More...</a><br /></td></tr>
<tr class="separator:gabe360874d7ebb9890f27be61d5b8e599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0f76b0fd536a8ed9216ff7c3e26d2214"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename Comparator &gt; </td></tr>
<tr class="memitem:ga0f76b0fd536a8ed9216ff7c3e26d2214"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#ga0f76b0fd536a8ed9216ff7c3e26d2214">is_sorted_until_cmp</a> (ForwardIterator first, ForwardIterator last, Comparator cmp)</td></tr>
<tr class="memdesc:ga0f76b0fd536a8ed9216ff7c3e26d2214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a range is sorted using a three-way Comparator (with memcmp() semantics).  <a href="group__tlx__algorithm.html#ga0f76b0fd536a8ed9216ff7c3e26d2214">More...</a><br /></td></tr>
<tr class="separator:ga0f76b0fd536a8ed9216ff7c3e26d2214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaea5cc8f7ba44822560e49eb74ae83794"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator1 , typename RandomAccessIterator2 , typename OutputIterator , typename DiffType , typename Comparator &gt; </td></tr>
<tr class="memitem:gaea5cc8f7ba44822560e49eb74ae83794"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#gaea5cc8f7ba44822560e49eb74ae83794">merge_advance</a> (RandomAccessIterator1 &amp;begin1, RandomAccessIterator1 end1, RandomAccessIterator2 &amp;begin2, RandomAccessIterator2 end2, OutputIterator target, DiffType max_size, Comparator comp)</td></tr>
<tr class="memdesc:gaea5cc8f7ba44822560e49eb74ae83794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge routine being able to merge only the <code>max_size</code> smallest elements.  <a href="group__tlx__algorithm.html#gaea5cc8f7ba44822560e49eb74ae83794">More...</a><br /></td></tr>
<tr class="separator:gaea5cc8f7ba44822560e49eb74ae83794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae146e022866f8e3e983cfc46b2287555"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator1 , typename RandomAccessIterator2 , typename OutputIterator , typename DiffType , typename Comparator &gt; </td></tr>
<tr class="memitem:gae146e022866f8e3e983cfc46b2287555"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#gae146e022866f8e3e983cfc46b2287555">merge_advance_movc</a> (RandomAccessIterator1 &amp;begin1, RandomAccessIterator1 end1, RandomAccessIterator2 &amp;begin2, RandomAccessIterator2 end2, OutputIterator target, DiffType max_size, Comparator comp)</td></tr>
<tr class="memdesc:gae146e022866f8e3e983cfc46b2287555"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge routine being able to merge only the <code>max_size</code> smallest elements.  <a href="group__tlx__algorithm.html#gae146e022866f8e3e983cfc46b2287555">More...</a><br /></td></tr>
<tr class="separator:gae146e022866f8e3e983cfc46b2287555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad57c4ceef5354d1657467303fe06bebf"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator1 , typename RandomAccessIterator2 , typename OutputIterator , typename DiffType , typename Comparator &gt; </td></tr>
<tr class="memitem:gad57c4ceef5354d1657467303fe06bebf"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#gad57c4ceef5354d1657467303fe06bebf">merge_advance_usual</a> (RandomAccessIterator1 &amp;begin1, RandomAccessIterator1 end1, RandomAccessIterator2 &amp;begin2, RandomAccessIterator2 end2, OutputIterator target, DiffType max_size, Comparator comp)</td></tr>
<tr class="memdesc:gad57c4ceef5354d1657467303fe06bebf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge routine being able to merge only the <code>max_size</code> smallest elements.  <a href="group__tlx__algorithm.html#gad57c4ceef5354d1657467303fe06bebf">More...</a><br /></td></tr>
<tr class="separator:gad57c4ceef5354d1657467303fe06bebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac328961b3d340e0963ca02b7703fafcd"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename Comparator , typename Combine  = std::plus&lt;              typename std::iterator_traits&lt;InputIterator1&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:gac328961b3d340e0963ca02b7703fafcd"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#gac328961b3d340e0963ca02b7703fafcd">merge_combine</a> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, OutputIterator result, Comparator cmp=Comparator(), Combine combine=Combine())</td></tr>
<tr class="memdesc:gac328961b3d340e0963ca02b7703fafcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge two sorted ranges and add all items comparing equal.  <a href="group__tlx__algorithm.html#gac328961b3d340e0963ca02b7703fafcd">More...</a><br /></td></tr>
<tr class="separator:gac328961b3d340e0963ca02b7703fafcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54b64d7db3fbcd0e966d8e4105f52626"><td class="memTemplParams" colspan="2">template&lt;typename RanSeqs , typename RankType , typename RankIterator , typename Comparator  = std::less&lt;              typename std::iterator_traits&lt;                  typename std::iterator_traits&lt;RanSeqs&gt;                  ::value_type::first_type&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:ga54b64d7db3fbcd0e966d8e4105f52626"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#ga54b64d7db3fbcd0e966d8e4105f52626">multisequence_partition</a> (const RanSeqs &amp;begin_seqs, const RanSeqs &amp;end_seqs, const RankType &amp;rank, RankIterator begin_offsets, Comparator comp=Comparator())</td></tr>
<tr class="memdesc:ga54b64d7db3fbcd0e966d8e4105f52626"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits several sorted sequences at a certain global rank, resulting in a splitting point for each sequence.  <a href="group__tlx__algorithm.html#ga54b64d7db3fbcd0e966d8e4105f52626">More...</a><br /></td></tr>
<tr class="separator:ga54b64d7db3fbcd0e966d8e4105f52626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73373d32a6a9d4e92c432d38bef8d908"><td class="memTemplParams" colspan="2">template&lt;typename ValueType , typename RanSeqs , typename RankType , typename Comparator  = std::less&lt;ValueType&gt;&gt; </td></tr>
<tr class="memitem:ga73373d32a6a9d4e92c432d38bef8d908"><td class="memTemplItemLeft" align="right" valign="top">ValueType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#ga73373d32a6a9d4e92c432d38bef8d908">multisequence_selection</a> (const RanSeqs &amp;begin_seqs, const RanSeqs &amp;end_seqs, const RankType &amp;rank, RankType &amp;offset, Comparator comp=Comparator())</td></tr>
<tr class="memdesc:ga73373d32a6a9d4e92c432d38bef8d908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Selects the element at a certain global rank from several sorted sequences.  <a href="group__tlx__algorithm.html#ga73373d32a6a9d4e92c432d38bef8d908">More...</a><br /></td></tr>
<tr class="separator:ga73373d32a6a9d4e92c432d38bef8d908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabfbaa27bf2f95ce5806e19e6fc4980e9"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename Comparator  = std::less&lt;        typename std::iterator_traits&lt;            typename std::iterator_traits&lt;RandomAccessIteratorIterator&gt;            ::value_type::first_type&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:gabfbaa27bf2f95ce5806e19e6fc4980e9"><td class="memTemplItemLeft" align="right" valign="top">RandomAccessIterator3&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#gabfbaa27bf2f95ce5806e19e6fc4980e9">multiway_merge</a> (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type size, Comparator comp=Comparator(), <a class="el" href="group__tlx__algorithm.html#ga98e900a348b28aa3709eb5e6d897ffbb">MultiwayMergeAlgorithm</a> mwma=<a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbba332bba921707cc62f6a682b8ac2c9013">MWMA_ALGORITHM_DEFAULT</a>)</td></tr>
<tr class="memdesc:gabfbaa27bf2f95ce5806e19e6fc4980e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequential multi-way merge.  <a href="group__tlx__algorithm.html#gabfbaa27bf2f95ce5806e19e6fc4980e9">More...</a><br /></td></tr>
<tr class="separator:gabfbaa27bf2f95ce5806e19e6fc4980e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d2560e55c9bda04200cc2dfceda4d94"><td class="memTemplParams" colspan="2">template&lt;bool Stable, bool Sentinels, typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename Comparator  = std::less&lt;        typename std::iterator_traits&lt;            typename std::iterator_traits&lt;RandomAccessIteratorIterator&gt;            ::value_type::first_type&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:ga1d2560e55c9bda04200cc2dfceda4d94"><td class="memTemplItemLeft" align="right" valign="top">RandomAccessIterator3&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#ga1d2560e55c9bda04200cc2dfceda4d94">multiway_merge_base</a> (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type size, Comparator comp=Comparator(), <a class="el" href="group__tlx__algorithm.html#ga98e900a348b28aa3709eb5e6d897ffbb">MultiwayMergeAlgorithm</a> mwma=<a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbba332bba921707cc62f6a682b8ac2c9013">MWMA_ALGORITHM_DEFAULT</a>)</td></tr>
<tr class="memdesc:ga1d2560e55c9bda04200cc2dfceda4d94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequential multi-way merging switch.  <a href="group__tlx__algorithm.html#ga1d2560e55c9bda04200cc2dfceda4d94">More...</a><br /></td></tr>
<tr class="separator:ga1d2560e55c9bda04200cc2dfceda4d94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6211397a04bfb4f213fceb2ae79f3ba1"><td class="memTemplParams" colspan="2">template&lt;bool Stable, typename RandomAccessIteratorIterator , typename Comparator &gt; </td></tr>
<tr class="memitem:ga6211397a04bfb4f213fceb2ae79f3ba1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#ga6211397a04bfb4f213fceb2ae79f3ba1">multiway_merge_exact_splitting</a> (const RandomAccessIteratorIterator &amp;seqs_begin, const RandomAccessIteratorIterator &amp;seqs_end, typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type size, typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type total_size, Comparator comp, std::vector&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type &gt; *chunks, const size_t num_threads)</td></tr>
<tr class="memdesc:ga6211397a04bfb4f213fceb2ae79f3ba1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splitting method for parallel multi-way merge routine: use multisequence selection for exact splitting.  <a href="group__tlx__algorithm.html#ga6211397a04bfb4f213fceb2ae79f3ba1">More...</a><br /></td></tr>
<tr class="separator:ga6211397a04bfb4f213fceb2ae79f3ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc54aa6bde4767b7ccf503674494494b"><td class="memTemplParams" colspan="2">template&lt;bool Stable, typename RandomAccessIteratorIterator , typename Comparator &gt; </td></tr>
<tr class="memitem:gacc54aa6bde4767b7ccf503674494494b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#gacc54aa6bde4767b7ccf503674494494b">multiway_merge_sampling_splitting</a> (const RandomAccessIteratorIterator &amp;seqs_begin, const RandomAccessIteratorIterator &amp;seqs_end, typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type size, typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type total_size, Comparator comp, std::vector&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type &gt; *chunks, const size_t num_threads, const size_t merge_oversampling)</td></tr>
<tr class="memdesc:gacc54aa6bde4767b7ccf503674494494b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splitting method for parallel multi-way merge routine: use sampling and binary search for in-exact splitting.  <a href="group__tlx__algorithm.html#gacc54aa6bde4767b7ccf503674494494b">More...</a><br /></td></tr>
<tr class="separator:gacc54aa6bde4767b7ccf503674494494b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36d2d7a6f5b247579d7e863c82323ed6"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename Comparator  = std::less&lt;        typename std::iterator_traits&lt;            typename std::iterator_traits&lt;RandomAccessIteratorIterator&gt;            ::value_type::first_type&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:ga36d2d7a6f5b247579d7e863c82323ed6"><td class="memTemplItemLeft" align="right" valign="top">RandomAccessIterator3&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#ga36d2d7a6f5b247579d7e863c82323ed6">multiway_merge_sentinels</a> (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type size, Comparator comp=Comparator(), <a class="el" href="group__tlx__algorithm.html#ga98e900a348b28aa3709eb5e6d897ffbb">MultiwayMergeAlgorithm</a> mwma=<a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbba332bba921707cc62f6a682b8ac2c9013">MWMA_ALGORITHM_DEFAULT</a>)</td></tr>
<tr class="memdesc:ga36d2d7a6f5b247579d7e863c82323ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sequential multi-way merge with sentinels in sequences.  <a href="group__tlx__algorithm.html#ga36d2d7a6f5b247579d7e863c82323ed6">More...</a><br /></td></tr>
<tr class="separator:ga36d2d7a6f5b247579d7e863c82323ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac3580dd876ff80d088499292a12d2fbe"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename Comparator  = std::less&lt;        typename std::iterator_traits&lt;            typename std::iterator_traits&lt;RandomAccessIteratorIterator&gt;            ::value_type::first_type&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:gac3580dd876ff80d088499292a12d2fbe"><td class="memTemplItemLeft" align="right" valign="top">RandomAccessIterator3&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#gac3580dd876ff80d088499292a12d2fbe">parallel_multiway_merge</a> (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, const typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type size, Comparator comp=Comparator(), <a class="el" href="group__tlx__algorithm.html#ga98e900a348b28aa3709eb5e6d897ffbb">MultiwayMergeAlgorithm</a> mwma=<a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbba332bba921707cc62f6a682b8ac2c9013">MWMA_ALGORITHM_DEFAULT</a>, <a class="el" href="group__tlx__algorithm.html#ga8a7342a22bda2a80ef56d779ceae36c0">MultiwayMergeSplittingAlgorithm</a> mwmsa=<a class="el" href="group__tlx__algorithm.html#gga8a7342a22bda2a80ef56d779ceae36c0acfb06584091121c62050c13c54e0e298">MWMSA_DEFAULT</a>, size_t num_threads=std::thread::hardware_concurrency())</td></tr>
<tr class="memdesc:gac3580dd876ff80d088499292a12d2fbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel multi-way merge routine.  <a href="group__tlx__algorithm.html#gac3580dd876ff80d088499292a12d2fbe">More...</a><br /></td></tr>
<tr class="separator:gac3580dd876ff80d088499292a12d2fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga267435a66c9b4a25471ea4233318e3cb"><td class="memTemplParams" colspan="2">template&lt;bool Stable, typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename Comparator  = std::less&lt;        typename std::iterator_traits&lt;            typename std::iterator_traits&lt;RandomAccessIteratorIterator&gt;            ::value_type::first_type&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:ga267435a66c9b4a25471ea4233318e3cb"><td class="memTemplItemLeft" align="right" valign="top">RandomAccessIterator3&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#ga267435a66c9b4a25471ea4233318e3cb">parallel_multiway_merge_base</a> (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, const typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type size, Comparator comp=Comparator(), <a class="el" href="group__tlx__algorithm.html#ga98e900a348b28aa3709eb5e6d897ffbb">MultiwayMergeAlgorithm</a> mwma=<a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbba332bba921707cc62f6a682b8ac2c9013">MWMA_ALGORITHM_DEFAULT</a>, <a class="el" href="group__tlx__algorithm.html#ga8a7342a22bda2a80ef56d779ceae36c0">MultiwayMergeSplittingAlgorithm</a> mwmsa=<a class="el" href="group__tlx__algorithm.html#gga8a7342a22bda2a80ef56d779ceae36c0acfb06584091121c62050c13c54e0e298">MWMSA_DEFAULT</a>, size_t num_threads=std::thread::hardware_concurrency())</td></tr>
<tr class="memdesc:ga267435a66c9b4a25471ea4233318e3cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel multi-way merge routine.  <a href="group__tlx__algorithm.html#ga267435a66c9b4a25471ea4233318e3cb">More...</a><br /></td></tr>
<tr class="separator:ga267435a66c9b4a25471ea4233318e3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf080f97856fc44ecf724cb8693a0e62e"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename Comparator  = std::less&lt;        typename std::iterator_traits&lt;            typename std::iterator_traits&lt;RandomAccessIteratorIterator&gt;            ::value_type::first_type&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:gaf080f97856fc44ecf724cb8693a0e62e"><td class="memTemplItemLeft" align="right" valign="top">RandomAccessIterator3&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#gaf080f97856fc44ecf724cb8693a0e62e">parallel_multiway_merge_sentinels</a> (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, const typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type size, Comparator comp=Comparator(), <a class="el" href="group__tlx__algorithm.html#ga98e900a348b28aa3709eb5e6d897ffbb">MultiwayMergeAlgorithm</a> mwma=<a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbba332bba921707cc62f6a682b8ac2c9013">MWMA_ALGORITHM_DEFAULT</a>, <a class="el" href="group__tlx__algorithm.html#ga8a7342a22bda2a80ef56d779ceae36c0">MultiwayMergeSplittingAlgorithm</a> mwmsa=<a class="el" href="group__tlx__algorithm.html#gga8a7342a22bda2a80ef56d779ceae36c0acfb06584091121c62050c13c54e0e298">MWMSA_DEFAULT</a>, size_t num_threads=std::thread::hardware_concurrency())</td></tr>
<tr class="memdesc:gaf080f97856fc44ecf724cb8693a0e62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parallel multi-way merge routine with sentinels.  <a href="group__tlx__algorithm.html#gaf080f97856fc44ecf724cb8693a0e62e">More...</a><br /></td></tr>
<tr class="separator:gaf080f97856fc44ecf724cb8693a0e62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga635866c58aa0826d8c8ea7097f913935"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIt , typename RandomBits &gt; </td></tr>
<tr class="memitem:ga635866c58aa0826d8c8ea7097f913935"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#ga635866c58aa0826d8c8ea7097f913935">random_bipartition_shuffle</a> (RandomAccessIt begin, RandomAccessIt end, size_t size_left_partition, RandomBits &amp;urng)</td></tr>
<tr class="memdesc:ga635866c58aa0826d8c8ea7097f913935"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to std::shuffle, but only generates a random bi-partition.  <a href="group__tlx__algorithm.html#ga635866c58aa0826d8c8ea7097f913935">More...</a><br /></td></tr>
<tr class="separator:ga635866c58aa0826d8c8ea7097f913935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab5a6467af7f10ab6f206eb3f9b3e0e4e"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename Comparator  = std::less&lt;        typename std::iterator_traits&lt;            typename std::iterator_traits&lt;RandomAccessIteratorIterator&gt;            ::value_type::first_type&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:gab5a6467af7f10ab6f206eb3f9b3e0e4e"><td class="memTemplItemLeft" align="right" valign="top">RandomAccessIterator3&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#gab5a6467af7f10ab6f206eb3f9b3e0e4e">stable_multiway_merge</a> (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type size, Comparator comp=Comparator(), <a class="el" href="group__tlx__algorithm.html#ga98e900a348b28aa3709eb5e6d897ffbb">MultiwayMergeAlgorithm</a> mwma=<a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbba332bba921707cc62f6a682b8ac2c9013">MWMA_ALGORITHM_DEFAULT</a>)</td></tr>
<tr class="memdesc:gab5a6467af7f10ab6f206eb3f9b3e0e4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stable sequential multi-way merge.  <a href="group__tlx__algorithm.html#gab5a6467af7f10ab6f206eb3f9b3e0e4e">More...</a><br /></td></tr>
<tr class="separator:gab5a6467af7f10ab6f206eb3f9b3e0e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2db163874c1c8e389c2736a72decb5f"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename Comparator  = std::less&lt;        typename std::iterator_traits&lt;            typename std::iterator_traits&lt;RandomAccessIteratorIterator&gt;            ::value_type::first_type&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:gac2db163874c1c8e389c2736a72decb5f"><td class="memTemplItemLeft" align="right" valign="top">RandomAccessIterator3&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#gac2db163874c1c8e389c2736a72decb5f">stable_multiway_merge_sentinels</a> (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type size, Comparator comp=Comparator(), <a class="el" href="group__tlx__algorithm.html#ga98e900a348b28aa3709eb5e6d897ffbb">MultiwayMergeAlgorithm</a> mwma=<a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbba332bba921707cc62f6a682b8ac2c9013">MWMA_ALGORITHM_DEFAULT</a>)</td></tr>
<tr class="memdesc:gac2db163874c1c8e389c2736a72decb5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stable sequential multi-way merge with sentinels in sequences.  <a href="group__tlx__algorithm.html#gac2db163874c1c8e389c2736a72decb5f">More...</a><br /></td></tr>
<tr class="separator:gac2db163874c1c8e389c2736a72decb5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae6f27252c44641af08a7297588ab1e6b"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename Comparator  = std::less&lt;        typename std::iterator_traits&lt;            typename std::iterator_traits&lt;RandomAccessIteratorIterator&gt;            ::value_type::first_type&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:gae6f27252c44641af08a7297588ab1e6b"><td class="memTemplItemLeft" align="right" valign="top">RandomAccessIterator3&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#gae6f27252c44641af08a7297588ab1e6b">stable_parallel_multiway_merge</a> (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, const typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type size, Comparator comp=Comparator(), <a class="el" href="group__tlx__algorithm.html#ga98e900a348b28aa3709eb5e6d897ffbb">MultiwayMergeAlgorithm</a> mwma=<a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbba332bba921707cc62f6a682b8ac2c9013">MWMA_ALGORITHM_DEFAULT</a>, <a class="el" href="group__tlx__algorithm.html#ga8a7342a22bda2a80ef56d779ceae36c0">MultiwayMergeSplittingAlgorithm</a> mwmsa=<a class="el" href="group__tlx__algorithm.html#gga8a7342a22bda2a80ef56d779ceae36c0acfb06584091121c62050c13c54e0e298">MWMSA_DEFAULT</a>, size_t num_threads=std::thread::hardware_concurrency())</td></tr>
<tr class="memdesc:gae6f27252c44641af08a7297588ab1e6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stable parallel multi-way merge routine.  <a href="group__tlx__algorithm.html#gae6f27252c44641af08a7297588ab1e6b">More...</a><br /></td></tr>
<tr class="separator:gae6f27252c44641af08a7297588ab1e6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1bcd8deadd96750e476982b2d572fcf"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIteratorIterator , typename RandomAccessIterator3 , typename Comparator  = std::less&lt;        typename std::iterator_traits&lt;            typename std::iterator_traits&lt;RandomAccessIteratorIterator&gt;            ::value_type::first_type&gt;::value_type&gt;&gt; </td></tr>
<tr class="memitem:gae1bcd8deadd96750e476982b2d572fcf"><td class="memTemplItemLeft" align="right" valign="top">RandomAccessIterator3&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#gae1bcd8deadd96750e476982b2d572fcf">stable_parallel_multiway_merge_sentinels</a> (RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, const typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type size, Comparator comp=Comparator(), <a class="el" href="group__tlx__algorithm.html#ga98e900a348b28aa3709eb5e6d897ffbb">MultiwayMergeAlgorithm</a> mwma=<a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbba332bba921707cc62f6a682b8ac2c9013">MWMA_ALGORITHM_DEFAULT</a>, <a class="el" href="group__tlx__algorithm.html#ga8a7342a22bda2a80ef56d779ceae36c0">MultiwayMergeSplittingAlgorithm</a> mwmsa=<a class="el" href="group__tlx__algorithm.html#gga8a7342a22bda2a80ef56d779ceae36c0acfb06584091121c62050c13c54e0e298">MWMSA_DEFAULT</a>, size_t num_threads=std::thread::hardware_concurrency())</td></tr>
<tr class="memdesc:gae1bcd8deadd96750e476982b2d572fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stable parallel multi-way merge routine with sentinels.  <a href="group__tlx__algorithm.html#gae1bcd8deadd96750e476982b2d572fcf">More...</a><br /></td></tr>
<tr class="separator:gae1bcd8deadd96750e476982b2d572fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ga8345e9f64e776708ff06090e0480f9ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#ga8345e9f64e776708ff06090e0480f9ae">parallel_multiway_merge_force_parallel</a> = false</td></tr>
<tr class="memdesc:ga8345e9f64e776708ff06090e0480f9ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">setting to force <a class="el" href="group__tlx__algorithm.html#gac3580dd876ff80d088499292a12d2fbe" title="Parallel multi-way merge routine. ">parallel_multiway_merge()</a> calls to run with parallel code  <a href="group__tlx__algorithm.html#ga8345e9f64e776708ff06090e0480f9ae">More...</a><br /></td></tr>
<tr class="separator:ga8345e9f64e776708ff06090e0480f9ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee58bcd5ecf83c8fde2fdfcb4645a91c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#gaee58bcd5ecf83c8fde2fdfcb4645a91c">parallel_multiway_merge_force_sequential</a> = false</td></tr>
<tr class="memdesc:gaee58bcd5ecf83c8fde2fdfcb4645a91c"><td class="mdescLeft">&#160;</td><td class="mdescRight">setting to force all <a class="el" href="group__tlx__algorithm.html#gac3580dd876ff80d088499292a12d2fbe" title="Parallel multi-way merge routine. ">parallel_multiway_merge()</a> calls to run sequentially  <a href="group__tlx__algorithm.html#gaee58bcd5ecf83c8fde2fdfcb4645a91c">More...</a><br /></td></tr>
<tr class="separator:gaee58bcd5ecf83c8fde2fdfcb4645a91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3fec55f066eef8bab8e18da604f978f0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#ga3fec55f066eef8bab8e18da604f978f0">parallel_multiway_merge_minimal_k</a> = 2</td></tr>
<tr class="memdesc:ga3fec55f066eef8bab8e18da604f978f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">minimal number of sequences for switching to parallel merging  <a href="group__tlx__algorithm.html#ga3fec55f066eef8bab8e18da604f978f0">More...</a><br /></td></tr>
<tr class="separator:ga3fec55f066eef8bab8e18da604f978f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga13c75c629afda60aa74bfc46239c977c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#ga13c75c629afda60aa74bfc46239c977c">parallel_multiway_merge_minimal_n</a> = 1000</td></tr>
<tr class="memdesc:ga13c75c629afda60aa74bfc46239c977c"><td class="mdescLeft">&#160;</td><td class="mdescRight">minimal number of items for switching to parallel merging  <a href="group__tlx__algorithm.html#ga13c75c629afda60aa74bfc46239c977c">More...</a><br /></td></tr>
<tr class="separator:ga13c75c629afda60aa74bfc46239c977c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a0a9b421b4afc71557597aa03874b4d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__tlx__algorithm.html#ga0a0a9b421b4afc71557597aa03874b4d">parallel_multiway_merge_oversampling</a> = 10</td></tr>
<tr class="memdesc:ga0a0a9b421b4afc71557597aa03874b4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">default oversampling factor for parallel_multiway_merge  <a href="group__tlx__algorithm.html#ga0a0a9b421b4afc71557597aa03874b4d">More...</a><br /></td></tr>
<tr class="separator:ga0a0a9b421b4afc71557597aa03874b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Algorithms for iterators and ranges </p>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ga98e900a348b28aa3709eb5e6d897ffbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98e900a348b28aa3709eb5e6d897ffbb">&#9670;&nbsp;</a></span>MultiwayMergeAlgorithm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__tlx__algorithm.html#ga98e900a348b28aa3709eb5e6d897ffbb">MultiwayMergeAlgorithm</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different merging algorithms: bubblesort-alike, loser-tree variants, enum sentinel. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga98e900a348b28aa3709eb5e6d897ffbbac1488a90ba6e18d5f936e51cbc5625e1"></a>MWMA_LOSER_TREE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga98e900a348b28aa3709eb5e6d897ffbbadd051fbbe4e1346d6357c82d56add811"></a>MWMA_LOSER_TREE_COMBINED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga98e900a348b28aa3709eb5e6d897ffbba8f020d718b11548f7d45b3d56fb37981"></a>MWMA_LOSER_TREE_SENTINEL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga98e900a348b28aa3709eb5e6d897ffbba097e6877921551867e9681ff56411d10"></a>MWMA_BUBBLE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga98e900a348b28aa3709eb5e6d897ffbba9fbb6366507fb2f30a433c51366719b6"></a>MWMA_ALGORITHM_LAST&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga98e900a348b28aa3709eb5e6d897ffbba332bba921707cc62f6a682b8ac2c9013"></a>MWMA_ALGORITHM_DEFAULT&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="extlib_2tlx_2tlx_2algorithm_2multiway__merge_8hpp_source.html#l01165">1165</a> of file <a class="el" href="extlib_2tlx_2tlx_2algorithm_2multiway__merge_8hpp_source.html">multiway_merge.hpp</a>.</p>

</div>
</div>
<a id="ga8a7342a22bda2a80ef56d779ceae36c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a7342a22bda2a80ef56d779ceae36c0">&#9670;&nbsp;</a></span>MultiwayMergeSplittingAlgorithm</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__tlx__algorithm.html#ga8a7342a22bda2a80ef56d779ceae36c0">MultiwayMergeSplittingAlgorithm</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different splitting strategies for sorting/merging: by sampling, exact. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="gga8a7342a22bda2a80ef56d779ceae36c0abccc0e651299ce4048220b307340aff3"></a>MWMSA_SAMPLING&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga8a7342a22bda2a80ef56d779ceae36c0aa7c13c05b4dd92e3fce043e8d4cc5f43"></a>MWMSA_EXACT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga8a7342a22bda2a80ef56d779ceae36c0a93014d67de65dba047c131661369e38c"></a>MWMSA_LAST&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="gga8a7342a22bda2a80ef56d779ceae36c0acfb06584091121c62050c13c54e0e298"></a>MWMSA_DEFAULT&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="multiway__merge__splitting_8hpp_source.html#l00035">35</a> of file <a class="el" href="multiway__merge__splitting_8hpp_source.html">multiway_merge_splitting.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga0801d65c092619953947c9c5bbeddc7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0801d65c092619953947c9c5bbeddc7b">&#9670;&nbsp;</a></span>exclusive_scan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator tlx::exclusive_scan </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="logistic__regression_8cpp.html#a6b2d038ea9c8d2651eecffe0e28b7ebb">T</a>&#160;</td>
          <td class="paramname"><em>init</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BinaryOperation&#160;</td>
          <td class="paramname"><em>binary_op</em> = <code>BinaryOperation()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes an exclusive prefix sum operation using binary_op the range [first, last), using init as the initial value, and writes the results to the range beginning at result. </p>
<p>The term "exclusive" means that the i-th input element is not included in the i-th sum. </p>

<p class="definition">Definition at line <a class="el" href="exclusive__scan_8hpp_source.html#l00030">30</a> of file <a class="el" href="exclusive__scan_8hpp_source.html">exclusive_scan.hpp</a>.</p>

<p class="reference">References <a class="el" href="gen__data_8py_source.html#l00041">gen_data::value</a>.</p>

</div>
</div>
<a id="gabe360874d7ebb9890f27be61d5b8e599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe360874d7ebb9890f27be61d5b8e599">&#9670;&nbsp;</a></span>is_sorted_cmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tlx::is_sorted_cmp </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a range is sorted using a three-way Comparator (with memcmp() semantics). </p>

<p class="definition">Definition at line <a class="el" href="is__sorted__cmp_8hpp_source.html#l00044">44</a> of file <a class="el" href="is__sorted__cmp_8hpp_source.html">is_sorted_cmp.hpp</a>.</p>

<p class="reference">References <a class="el" href="is__sorted__cmp_8hpp_source.html#l00026">tlx::is_sorted_until_cmp()</a>.</p>

</div>
</div>
<a id="ga0f76b0fd536a8ed9216ff7c3e26d2214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0f76b0fd536a8ed9216ff7c3e26d2214">&#9670;&nbsp;</a></span>is_sorted_until_cmp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ForwardIterator tlx::is_sorted_until_cmp </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a range is sorted using a three-way Comparator (with memcmp() semantics). </p>
<p>Returns an iterator to the first items not in order. </p>

<p class="definition">Definition at line <a class="el" href="is__sorted__cmp_8hpp_source.html#l00026">26</a> of file <a class="el" href="is__sorted__cmp_8hpp_source.html">is_sorted_cmp.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="is__sorted__cmp_8hpp_source.html#l00044">tlx::is_sorted_cmp()</a>.</p>

</div>
</div>
<a id="gaea5cc8f7ba44822560e49eb74ae83794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaea5cc8f7ba44822560e49eb74ae83794">&#9670;&nbsp;</a></span>merge_advance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator tlx::merge_advance </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator1 &amp;&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator2 &amp;&#160;</td>
          <td class="paramname"><em>begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator2&#160;</td>
          <td class="paramname"><em>end2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiffType&#160;</td>
          <td class="paramname"><em>max_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge routine being able to merge only the <code>max_size</code> smallest elements. </p>
<p>The <code>begin</code> iterators are advanced accordingly, they might not reach <code>end</code>, in contrast to the usual variant. Static switch on whether to use the conditional-move variant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin1</td><td>Begin iterator of first sequence. </td></tr>
    <tr><td class="paramname">end1</td><td>End iterator of first sequence. </td></tr>
    <tr><td class="paramname">begin2</td><td>Begin iterator of second sequence. </td></tr>
    <tr><td class="paramname">end2</td><td>End iterator of second sequence. </td></tr>
    <tr><td class="paramname">target</td><td>Target begin iterator. </td></tr>
    <tr><td class="paramname">max_size</td><td>Maximum number of elements to merge. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output end iterator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="merge__advance_8hpp_source.html#l00158">158</a> of file <a class="el" href="merge__advance_8hpp_source.html">merge_advance.hpp</a>.</p>

<p class="reference">References <a class="el" href="merge__advance_8hpp_source.html#l00094">tlx::merge_advance_movc()</a>.</p>

<p class="reference">Referenced by <a class="el" href="extlib_2tlx_2tlx_2algorithm_2multiway__merge_8hpp_source.html#l00453">tlx::multiway_merge_detail::multiway_merge_3_combined()</a>, and <a class="el" href="extlib_2tlx_2tlx_2algorithm_2multiway__merge_8hpp_source.html#l01198">tlx::multiway_merge_base()</a>.</p>

</div>
</div>
<a id="gae146e022866f8e3e983cfc46b2287555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae146e022866f8e3e983cfc46b2287555">&#9670;&nbsp;</a></span>merge_advance_movc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator tlx::merge_advance_movc </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator1 &amp;&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator2 &amp;&#160;</td>
          <td class="paramname"><em>begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator2&#160;</td>
          <td class="paramname"><em>end2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiffType&#160;</td>
          <td class="paramname"><em>max_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge routine being able to merge only the <code>max_size</code> smallest elements. </p>
<p>The <code>begin</code> iterators are advanced accordingly, they might not reach <code>end</code>, in contrast to the usual variant. Specially designed code should allow the compiler to generate conditional moves instead of branches.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin1</td><td>Begin iterator of first sequence. </td></tr>
    <tr><td class="paramname">end1</td><td>End iterator of first sequence. </td></tr>
    <tr><td class="paramname">begin2</td><td>Begin iterator of second sequence. </td></tr>
    <tr><td class="paramname">end2</td><td>End iterator of second sequence. </td></tr>
    <tr><td class="paramname">target</td><td>Target begin iterator. </td></tr>
    <tr><td class="paramname">max_size</td><td>Maximum number of elements to merge. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output end iterator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="merge__advance_8hpp_source.html#l00094">94</a> of file <a class="el" href="merge__advance_8hpp_source.html">merge_advance.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="merge__advance_8hpp_source.html#l00158">tlx::merge_advance()</a>.</p>

</div>
</div>
<a id="gad57c4ceef5354d1657467303fe06bebf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad57c4ceef5354d1657467303fe06bebf">&#9670;&nbsp;</a></span>merge_advance_usual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator tlx::merge_advance_usual </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator1 &amp;&#160;</td>
          <td class="paramname"><em>begin1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator1&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator2 &amp;&#160;</td>
          <td class="paramname"><em>begin2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator2&#160;</td>
          <td class="paramname"><em>end2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DiffType&#160;</td>
          <td class="paramname"><em>max_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge routine being able to merge only the <code>max_size</code> smallest elements. </p>
<p>The <code>begin</code> iterators are advanced accordingly, they might not reach <code>end</code>, in contrast to the usual variant.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin1</td><td>Begin iterator of first sequence. </td></tr>
    <tr><td class="paramname">end1</td><td>End iterator of first sequence. </td></tr>
    <tr><td class="paramname">begin2</td><td>Begin iterator of second sequence. </td></tr>
    <tr><td class="paramname">end2</td><td>End iterator of second sequence. </td></tr>
    <tr><td class="paramname">target</td><td>Target begin iterator. </td></tr>
    <tr><td class="paramname">max_size</td><td>Maximum number of elements to merge. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparator. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Output end iterator. </dd></dl>

<p class="definition">Definition at line <a class="el" href="merge__advance_8hpp_source.html#l00047">47</a> of file <a class="el" href="merge__advance_8hpp_source.html">merge_advance.hpp</a>.</p>

</div>
</div>
<a id="gac328961b3d340e0963ca02b7703fafcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac328961b3d340e0963ca02b7703fafcd">&#9670;&nbsp;</a></span>merge_combine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OutputIterator tlx::merge_combine </td>
          <td>(</td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>first1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator1&#160;</td>
          <td class="paramname"><em>last1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>first2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>last2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>cmp</em> = <code>Comparator()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Combine&#160;</td>
          <td class="paramname"><em>combine</em> = <code>Combine()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge two sorted ranges and add all items comparing equal. </p>
<p>Both ranges must be sorted using the three-way Comparator (with memcmp() semantics). Item pairs comparing equal (cmp returns 0) are combined together using a combine operator.</p>
<dl class="section warning"><dt>Warning</dt><dd>This method does not check if the ranges are sorted. Also make sure that the comparator does not work with unsigned types. </dd></dl>

<p class="definition">Definition at line <a class="el" href="merge__combine_8hpp_source.html#l00037">37</a> of file <a class="el" href="merge__combine_8hpp_source.html">merge_combine.hpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="iostats_8cpp_source.html#l00444">stats_data::operator+()</a>, and <a class="el" href="iostats_8cpp_source.html#l00468">stats_data::operator-()</a>.</p>

</div>
</div>
<a id="ga54b64d7db3fbcd0e966d8e4105f52626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga54b64d7db3fbcd0e966d8e4105f52626">&#9670;&nbsp;</a></span>multisequence_partition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tlx::multisequence_partition </td>
          <td>(</td>
          <td class="paramtype">const RanSeqs &amp;&#160;</td>
          <td class="paramname"><em>begin_seqs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RanSeqs &amp;&#160;</td>
          <td class="paramname"><em>end_seqs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RankType &amp;&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RankIterator&#160;</td>
          <td class="paramname"><em>begin_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em> = <code>Comparator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splits several sorted sequences at a certain global rank, resulting in a splitting point for each sequence. </p>
<p>The sequences are passed via a sequence of random-access iterator pairs, none of the sequences may be empty. If there are several equal elements across the split, the ones on the left side will be chosen from sequences with smaller number.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin_seqs</td><td>Begin of the sequence of iterator pairs. </td></tr>
    <tr><td class="paramname">end_seqs</td><td>End of the sequence of iterator pairs. </td></tr>
    <tr><td class="paramname">rank</td><td>The global rank to partition at. </td></tr>
    <tr><td class="paramname">begin_offsets</td><td>A random-access sequence begin where the result will be stored in. Each element of the sequence is an iterator that points to the first element on the greater part of the respective sequence. </td></tr>
    <tr><td class="paramname">comp</td><td>The ordering functor, defaults to std::less&lt;T&gt;. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="multisequence__partition_8hpp_source.html#l00106">106</a> of file <a class="el" href="multisequence__partition_8hpp_source.html">multisequence_partition.hpp</a>.</p>

<p class="reference">References <a class="el" href="extlib_2foxxll_2foxxll_2common_2uint__types_8hpp_source.html#l00226">max()</a>, <a class="el" href="extlib_2foxxll_2foxxll_2common_2uint__types_8hpp_source.html#l00217">min()</a>, <a class="el" href="gen__data_8py_source.html#l00015">gen_data::N</a>, and <a class="el" href="round__to__power__of__two_8hpp_source.html#l00038">tlx::round_up_to_power_of_two()</a>.</p>

<p class="reference">Referenced by <a class="el" href="multiway__merge__splitting_8hpp_source.html#l00190">tlx::multiway_merge_exact_splitting()</a>, and <a class="el" href="parallel__mergesort_8hpp_source.html#l00120">tlx::parallel_mergesort_detail::parallel_sort_mwms_pu()</a>.</p>

</div>
</div>
<a id="ga73373d32a6a9d4e92c432d38bef8d908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga73373d32a6a9d4e92c432d38bef8d908">&#9670;&nbsp;</a></span>multisequence_selection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ValueType tlx::multisequence_selection </td>
          <td>(</td>
          <td class="paramtype">const RanSeqs &amp;&#160;</td>
          <td class="paramname"><em>begin_seqs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RanSeqs &amp;&#160;</td>
          <td class="paramname"><em>end_seqs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RankType &amp;&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RankType &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em> = <code>Comparator()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Selects the element at a certain global rank from several sorted sequences. </p>
<p>The sequences are passed via a sequence of random-access iterator pairs, none of the sequences may be empty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin_seqs</td><td>Begin of the sequence of iterator pairs. </td></tr>
    <tr><td class="paramname">end_seqs</td><td>End of the sequence of iterator pairs. </td></tr>
    <tr><td class="paramname">rank</td><td>The global rank to partition at. </td></tr>
    <tr><td class="paramname">offset</td><td>The rank of the selected element in the global subsequence of elements equal to the selected element. If the selected element is unique, this number is 0. </td></tr>
    <tr><td class="paramname">comp</td><td>The ordering functor, defaults to std::less. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="multisequence__selection_8hpp_source.html#l00100">100</a> of file <a class="el" href="multisequence__selection_8hpp_source.html">multisequence_selection.hpp</a>.</p>

<p class="reference">References <a class="el" href="extlib_2foxxll_2foxxll_2common_2uint__types_8hpp_source.html#l00226">max()</a>, <a class="el" href="extlib_2foxxll_2foxxll_2common_2uint__types_8hpp_source.html#l00217">min()</a>, <a class="el" href="gen__data_8py_source.html#l00015">gen_data::N</a>, and <a class="el" href="round__to__power__of__two_8hpp_source.html#l00038">tlx::round_up_to_power_of_two()</a>.</p>

</div>
</div>
<a id="gabfbaa27bf2f95ce5806e19e6fc4980e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabfbaa27bf2f95ce5806e19e6fc4980e9">&#9670;&nbsp;</a></span>multiway_merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RandomAccessIterator3 tlx::multiway_merge </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator3&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em> = <code>Comparator()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__tlx__algorithm.html#ga98e900a348b28aa3709eb5e6d897ffbb">MultiwayMergeAlgorithm</a>&#160;</td>
          <td class="paramname"><em>mwma</em> = <code><a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbba332bba921707cc62f6a682b8ac2c9013">MWMA_ALGORITHM_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sequential multi-way merge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seqs_begin</td><td>Begin iterator of iterator pair input sequence. </td></tr>
    <tr><td class="paramname">seqs_end</td><td>End iterator of iterator pair input sequence. </td></tr>
    <tr><td class="paramname">target</td><td>Begin iterator out output sequence. </td></tr>
    <tr><td class="paramname">size</td><td>Maximum size to merge. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparator. </td></tr>
    <tr><td class="paramname">mwma</td><td>MultiwayMergeAlgorithm set to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End iterator of output sequence. </dd></dl>

<p class="definition">Definition at line <a class="el" href="extlib_2tlx_2tlx_2algorithm_2multiway__merge_8hpp_source.html#l01324">1324</a> of file <a class="el" href="extlib_2tlx_2tlx_2algorithm_2multiway__merge_8hpp_source.html">multiway_merge.hpp</a>.</p>

<p class="reference">References <a class="el" href="extlib_2tlx_2tlx_2algorithm_2multiway__merge_8hpp_source.html#l01198">tlx::multiway_merge_base()</a>.</p>

</div>
</div>
<a id="ga1d2560e55c9bda04200cc2dfceda4d94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d2560e55c9bda04200cc2dfceda4d94">&#9670;&nbsp;</a></span>multiway_merge_base()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RandomAccessIterator3 tlx::multiway_merge_base </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator3&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em> = <code>Comparator()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__tlx__algorithm.html#ga98e900a348b28aa3709eb5e6d897ffbb">MultiwayMergeAlgorithm</a>&#160;</td>
          <td class="paramname"><em>mwma</em> = <code><a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbba332bba921707cc62f6a682b8ac2c9013">MWMA_ALGORITHM_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sequential multi-way merging switch. </p>
<p>The decision if based on the branching factor and runtime settings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seqs_begin</td><td>Begin iterator of iterator pair input sequence. </td></tr>
    <tr><td class="paramname">seqs_end</td><td>End iterator of iterator pair input sequence. </td></tr>
    <tr><td class="paramname">target</td><td>Begin iterator out output sequence. </td></tr>
    <tr><td class="paramname">size</td><td>Maximum size to merge. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparator. </td></tr>
    <tr><td class="paramname">mwma</td><td>MultiwayMergeAlgorithm set to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stable</td><td>Stable merging incurs a performance penalty. </td></tr>
    <tr><td class="paramname">Sentinels</td><td>The sequences have a sentinel element. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End iterator of output sequence. </dd></dl>

<p class="definition">Definition at line <a class="el" href="extlib_2tlx_2tlx_2algorithm_2multiway__merge_8hpp_source.html#l01198">1198</a> of file <a class="el" href="extlib_2tlx_2tlx_2algorithm_2multiway__merge_8hpp_source.html">multiway_merge.hpp</a>.</p>

<p class="reference">References <a class="el" href="merge__advance_8hpp_source.html#l00158">tlx::merge_advance()</a>, <a class="el" href="extlib_2tlx_2tlx_2algorithm_2multiway__merge_8hpp_source.html#l00453">tlx::multiway_merge_detail::multiway_merge_3_combined()</a>, <a class="el" href="extlib_2tlx_2tlx_2algorithm_2multiway__merge_8hpp_source.html#l00655">tlx::multiway_merge_detail::multiway_merge_4_combined()</a>, <a class="el" href="extlib_2tlx_2tlx_2algorithm_2multiway__merge_8hpp_source.html#l00915">tlx::multiway_merge_detail::multiway_merge_loser_tree()</a>, <a class="el" href="extlib_2tlx_2tlx_2algorithm_2multiway__merge_8hpp_source.html#l01169">tlx::MWMA_BUBBLE</a>, <a class="el" href="extlib_2tlx_2tlx_2algorithm_2multiway__merge_8hpp_source.html#l01166">tlx::MWMA_LOSER_TREE</a>, <a class="el" href="extlib_2tlx_2tlx_2algorithm_2multiway__merge_8hpp_source.html#l01167">tlx::MWMA_LOSER_TREE_COMBINED</a>, and <a class="el" href="extlib_2tlx_2tlx_2algorithm_2multiway__merge_8hpp_source.html#l01168">tlx::MWMA_LOSER_TREE_SENTINEL</a>.</p>

<p class="reference">Referenced by <a class="el" href="extlib_2tlx_2tlx_2algorithm_2multiway__merge_8hpp_source.html#l01324">tlx::multiway_merge()</a>, <a class="el" href="extlib_2tlx_2tlx_2algorithm_2multiway__merge_8hpp_source.html#l01390">tlx::multiway_merge_sentinels()</a>, <a class="el" href="parallel__multiway__merge_8hpp_source.html#l00229">tlx::parallel_multiway_merge()</a>, <a class="el" href="parallel__multiway__merge_8hpp_source.html#l00343">tlx::parallel_multiway_merge_sentinels()</a>, <a class="el" href="parallel__mergesort_8hpp_source.html#l00120">tlx::parallel_mergesort_detail::parallel_sort_mwms_pu()</a>, <a class="el" href="extlib_2tlx_2tlx_2algorithm_2multiway__merge_8hpp_source.html#l01357">tlx::stable_multiway_merge()</a>, <a class="el" href="extlib_2tlx_2tlx_2algorithm_2multiway__merge_8hpp_source.html#l01423">tlx::stable_multiway_merge_sentinels()</a>, <a class="el" href="parallel__multiway__merge_8hpp_source.html#l00286">tlx::stable_parallel_multiway_merge()</a>, and <a class="el" href="parallel__multiway__merge_8hpp_source.html#l00400">tlx::stable_parallel_multiway_merge_sentinels()</a>.</p>

</div>
</div>
<a id="ga6211397a04bfb4f213fceb2ae79f3ba1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6211397a04bfb4f213fceb2ae79f3ba1">&#9670;&nbsp;</a></span>multiway_merge_exact_splitting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tlx::multiway_merge_exact_splitting </td>
          <td>(</td>
          <td class="paramtype">const RandomAccessIteratorIterator &amp;&#160;</td>
          <td class="paramname"><em>seqs_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RandomAccessIteratorIterator &amp;&#160;</td>
          <td class="paramname"><em>seqs_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type&#160;</td>
          <td class="paramname"><em>total_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type &gt; *&#160;</td>
          <td class="paramname"><em>chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>num_threads</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splitting method for parallel multi-way merge routine: use multisequence selection for exact splitting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seqs_begin</td><td>Begin iterator of iterator pair input sequence. </td></tr>
    <tr><td class="paramname">seqs_end</td><td>End iterator of iterator pair input sequence. </td></tr>
    <tr><td class="paramname">size</td><td>Maximum size to merge. </td></tr>
    <tr><td class="paramname">total_size</td><td>Total size of all sequences combined. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparator. </td></tr>
    <tr><td class="paramname">chunks</td><td>Output subsequences for num_threads. </td></tr>
    <tr><td class="paramname">num_threads</td><td>Split the sequences into for num_threads. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stable</td><td>Stable merging incurs a performance penalty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End iterator of output sequence. </dd></dl>

<p class="definition">Definition at line <a class="el" href="multiway__merge__splitting_8hpp_source.html#l00190">190</a> of file <a class="el" href="multiway__merge__splitting_8hpp_source.html">multiway_merge_splitting.hpp</a>.</p>

<p class="reference">References <a class="el" href="multiway__merge__splitting_8hpp_source.html#l00057">tlx::multiway_merge_detail::equally_split()</a>, <a class="el" href="multisequence__partition_8hpp_source.html#l00106">tlx::multisequence_partition()</a>, and <a class="el" href="container_2simple__vector_8hpp_source.html#l00163">SimpleVector&lt; ValueType, Mode &gt;::resize()</a>.</p>

</div>
</div>
<a id="gacc54aa6bde4767b7ccf503674494494b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacc54aa6bde4767b7ccf503674494494b">&#9670;&nbsp;</a></span>multiway_merge_sampling_splitting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tlx::multiway_merge_sampling_splitting </td>
          <td>(</td>
          <td class="paramtype">const RandomAccessIteratorIterator &amp;&#160;</td>
          <td class="paramname"><em>seqs_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RandomAccessIteratorIterator &amp;&#160;</td>
          <td class="paramname"><em>seqs_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type&#160;</td>
          <td class="paramname"><em>total_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type &gt; *&#160;</td>
          <td class="paramname"><em>chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>num_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>merge_oversampling</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Splitting method for parallel multi-way merge routine: use sampling and binary search for in-exact splitting. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seqs_begin</td><td>Begin iterator of iterator pair input sequence. </td></tr>
    <tr><td class="paramname">seqs_end</td><td>End iterator of iterator pair input sequence. </td></tr>
    <tr><td class="paramname">size</td><td>Maximum size to merge. </td></tr>
    <tr><td class="paramname">total_size</td><td>Total size of all sequences combined. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparator. </td></tr>
    <tr><td class="paramname">chunks</td><td>Output subsequences for num_threads. </td></tr>
    <tr><td class="paramname">num_threads</td><td>Split the sequences into for num_threads. </td></tr>
    <tr><td class="paramname">merge_oversampling</td><td>oversampling factor </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stable</td><td>Stable merging incurs a performance penalty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End iterator of output sequence. </dd></dl>

<p class="definition">Definition at line <a class="el" href="multiway__merge__splitting_8hpp_source.html#l00094">94</a> of file <a class="el" href="multiway__merge__splitting_8hpp_source.html">multiway_merge_splitting.hpp</a>.</p>

</div>
</div>
<a id="ga36d2d7a6f5b247579d7e863c82323ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36d2d7a6f5b247579d7e863c82323ed6">&#9670;&nbsp;</a></span>multiway_merge_sentinels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RandomAccessIterator3 tlx::multiway_merge_sentinels </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator3&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em> = <code>Comparator()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__tlx__algorithm.html#ga98e900a348b28aa3709eb5e6d897ffbb">MultiwayMergeAlgorithm</a>&#160;</td>
          <td class="paramname"><em>mwma</em> = <code><a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbba332bba921707cc62f6a682b8ac2c9013">MWMA_ALGORITHM_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sequential multi-way merge with sentinels in sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seqs_begin</td><td>Begin iterator of iterator pair input sequence. </td></tr>
    <tr><td class="paramname">seqs_end</td><td>End iterator of iterator pair input sequence. </td></tr>
    <tr><td class="paramname">target</td><td>Begin iterator out output sequence. </td></tr>
    <tr><td class="paramname">size</td><td>Maximum size to merge. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparator. </td></tr>
    <tr><td class="paramname">mwma</td><td>MultiwayMergeAlgorithm set to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End iterator of output sequence. </dd></dl>

<p class="definition">Definition at line <a class="el" href="extlib_2tlx_2tlx_2algorithm_2multiway__merge_8hpp_source.html#l01390">1390</a> of file <a class="el" href="extlib_2tlx_2tlx_2algorithm_2multiway__merge_8hpp_source.html">multiway_merge.hpp</a>.</p>

<p class="reference">References <a class="el" href="extlib_2tlx_2tlx_2algorithm_2multiway__merge_8hpp_source.html#l01198">tlx::multiway_merge_base()</a>.</p>

</div>
</div>
<a id="gac3580dd876ff80d088499292a12d2fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac3580dd876ff80d088499292a12d2fbe">&#9670;&nbsp;</a></span>parallel_multiway_merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RandomAccessIterator3 tlx::parallel_multiway_merge </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator3&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em> = <code>Comparator()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__tlx__algorithm.html#ga98e900a348b28aa3709eb5e6d897ffbb">MultiwayMergeAlgorithm</a>&#160;</td>
          <td class="paramname"><em>mwma</em> = <code><a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbba332bba921707cc62f6a682b8ac2c9013">MWMA_ALGORITHM_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__tlx__algorithm.html#ga8a7342a22bda2a80ef56d779ceae36c0">MultiwayMergeSplittingAlgorithm</a>&#160;</td>
          <td class="paramname"><em>mwmsa</em> = <code><a class="el" href="group__tlx__algorithm.html#gga8a7342a22bda2a80ef56d779ceae36c0acfb06584091121c62050c13c54e0e298">MWMSA_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_threads</em> = <code>std::thread::hardware_concurrency()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parallel multi-way merge routine. </p>
<p>Implemented either using OpenMP or with std::threads, depending on if compiled with -fopenmp or not. The OpenMP version uses the implicit thread pool, which is faster when using this method often.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seqs_begin</td><td>Begin iterator of iterator pair input sequence. </td></tr>
    <tr><td class="paramname">seqs_end</td><td>End iterator of iterator pair input sequence. </td></tr>
    <tr><td class="paramname">target</td><td>Begin iterator out output sequence. </td></tr>
    <tr><td class="paramname">size</td><td>Maximum size to merge. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparator. </td></tr>
    <tr><td class="paramname">mwma</td><td>MultiwayMergeAlgorithm set to use. </td></tr>
    <tr><td class="paramname">mwmsa</td><td>MultiwayMergeSplittingAlgorithm to use. </td></tr>
    <tr><td class="paramname">num_threads</td><td>Number of threads to use (defaults to all cores) </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stable</td><td>Stable merging incurs a performance penalty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End iterator of output sequence. </dd></dl>

<p class="definition">Definition at line <a class="el" href="parallel__multiway__merge_8hpp_source.html#l00229">229</a> of file <a class="el" href="parallel__multiway__merge_8hpp_source.html">parallel_multiway_merge.hpp</a>.</p>

<p class="reference">References <a class="el" href="extlib_2tlx_2tlx_2algorithm_2multiway__merge_8hpp_source.html#l01198">tlx::multiway_merge_base()</a>, and <a class="el" href="parallel__multiway__merge_8hpp_source.html#l00068">tlx::parallel_multiway_merge_base()</a>.</p>

</div>
</div>
<a id="ga267435a66c9b4a25471ea4233318e3cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga267435a66c9b4a25471ea4233318e3cb">&#9670;&nbsp;</a></span>parallel_multiway_merge_base()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RandomAccessIterator3 tlx::parallel_multiway_merge_base </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator3&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em> = <code>Comparator()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__tlx__algorithm.html#ga98e900a348b28aa3709eb5e6d897ffbb">MultiwayMergeAlgorithm</a>&#160;</td>
          <td class="paramname"><em>mwma</em> = <code><a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbba332bba921707cc62f6a682b8ac2c9013">MWMA_ALGORITHM_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__tlx__algorithm.html#ga8a7342a22bda2a80ef56d779ceae36c0">MultiwayMergeSplittingAlgorithm</a>&#160;</td>
          <td class="paramname"><em>mwmsa</em> = <code><a class="el" href="group__tlx__algorithm.html#gga8a7342a22bda2a80ef56d779ceae36c0acfb06584091121c62050c13c54e0e298">MWMSA_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_threads</em> = <code>std::thread::hardware_concurrency()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parallel multi-way merge routine. </p>
<p>Implemented either using OpenMP or with std::threads, depending on if compiled with -fopenmp or not. The OpenMP version uses the implicit thread pool, which is faster when using this method often.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seqs_begin</td><td>Begin iterator of iterator pair input sequence. </td></tr>
    <tr><td class="paramname">seqs_end</td><td>End iterator of iterator pair input sequence. </td></tr>
    <tr><td class="paramname">target</td><td>Begin iterator out output sequence. </td></tr>
    <tr><td class="paramname">size</td><td>Maximum size to merge. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparator. </td></tr>
    <tr><td class="paramname">mwma</td><td>MultiwayMergeAlgorithm set to use. </td></tr>
    <tr><td class="paramname">mwmsa</td><td>MultiwayMergeSplittingAlgorithm to use. </td></tr>
    <tr><td class="paramname">num_threads</td><td>Number of threads to use (defaults to all cores) </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stable</td><td>Stable merging incurs a performance penalty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End iterator of output sequence. </dd></dl>

<p class="definition">Definition at line <a class="el" href="parallel__multiway__merge_8hpp_source.html#l00068">68</a> of file <a class="el" href="parallel__multiway__merge_8hpp_source.html">parallel_multiway_merge.hpp</a>.</p>

<p class="reference">References <a class="el" href="container_2simple__vector_8hpp_source.html#l00128">SimpleVector&lt; ValueType, Mode &gt;::begin()</a>, <a class="el" href="container_2simple__vector_8hpp_source.html#l00115">SimpleVector&lt; ValueType, Mode &gt;::data()</a>, <a class="el" href="container_2simple__vector_8hpp_source.html#l00141">SimpleVector&lt; ValueType, Mode &gt;::end()</a>, <a class="el" href="join_8cpp_source.html#l00016">tlx::join()</a>, <a class="el" href="extlib_2foxxll_2foxxll_2common_2uint__types_8hpp_source.html#l00217">min()</a>, <a class="el" href="multiway__merge__splitting_8hpp_source.html#l00036">tlx::MWMSA_SAMPLING</a>, <a class="el" href="parallel__multiway__merge_8cpp_source.html#l00029">tlx::parallel_multiway_merge_force_parallel</a>, <a class="el" href="parallel__multiway__merge_8cpp_source.html#l00027">tlx::parallel_multiway_merge_force_sequential</a>, <a class="el" href="parallel__multiway__merge_8cpp_source.html#l00031">tlx::parallel_multiway_merge_minimal_k</a>, <a class="el" href="parallel__multiway__merge_8cpp_source.html#l00033">tlx::parallel_multiway_merge_minimal_n</a>, and <a class="el" href="parallel__multiway__merge_8cpp_source.html#l00035">tlx::parallel_multiway_merge_oversampling</a>.</p>

<p class="reference">Referenced by <a class="el" href="parallel__multiway__merge_8hpp_source.html#l00229">tlx::parallel_multiway_merge()</a>, <a class="el" href="parallel__multiway__merge_8hpp_source.html#l00343">tlx::parallel_multiway_merge_sentinels()</a>, <a class="el" href="parallel__multiway__merge_8hpp_source.html#l00286">tlx::stable_parallel_multiway_merge()</a>, and <a class="el" href="parallel__multiway__merge_8hpp_source.html#l00400">tlx::stable_parallel_multiway_merge_sentinels()</a>.</p>

</div>
</div>
<a id="gaf080f97856fc44ecf724cb8693a0e62e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf080f97856fc44ecf724cb8693a0e62e">&#9670;&nbsp;</a></span>parallel_multiway_merge_sentinels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RandomAccessIterator3 tlx::parallel_multiway_merge_sentinels </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator3&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em> = <code>Comparator()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__tlx__algorithm.html#ga98e900a348b28aa3709eb5e6d897ffbb">MultiwayMergeAlgorithm</a>&#160;</td>
          <td class="paramname"><em>mwma</em> = <code><a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbba332bba921707cc62f6a682b8ac2c9013">MWMA_ALGORITHM_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__tlx__algorithm.html#ga8a7342a22bda2a80ef56d779ceae36c0">MultiwayMergeSplittingAlgorithm</a>&#160;</td>
          <td class="paramname"><em>mwmsa</em> = <code><a class="el" href="group__tlx__algorithm.html#gga8a7342a22bda2a80ef56d779ceae36c0acfb06584091121c62050c13c54e0e298">MWMSA_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_threads</em> = <code>std::thread::hardware_concurrency()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parallel multi-way merge routine with sentinels. </p>
<p>Implemented either using OpenMP or with std::threads, depending on if compiled with -fopenmp or not. The OpenMP version uses the implicit thread pool, which is faster when using this method often.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seqs_begin</td><td>Begin iterator of iterator pair input sequence. </td></tr>
    <tr><td class="paramname">seqs_end</td><td>End iterator of iterator pair input sequence. </td></tr>
    <tr><td class="paramname">target</td><td>Begin iterator out output sequence. </td></tr>
    <tr><td class="paramname">size</td><td>Maximum size to merge. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparator. </td></tr>
    <tr><td class="paramname">mwma</td><td>MultiwayMergeAlgorithm set to use. </td></tr>
    <tr><td class="paramname">mwmsa</td><td>MultiwayMergeSplittingAlgorithm to use. </td></tr>
    <tr><td class="paramname">num_threads</td><td>Number of threads to use (defaults to all cores) </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stable</td><td>Stable merging incurs a performance penalty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End iterator of output sequence. </dd></dl>

<p class="definition">Definition at line <a class="el" href="parallel__multiway__merge_8hpp_source.html#l00343">343</a> of file <a class="el" href="parallel__multiway__merge_8hpp_source.html">parallel_multiway_merge.hpp</a>.</p>

<p class="reference">References <a class="el" href="extlib_2tlx_2tlx_2algorithm_2multiway__merge_8hpp_source.html#l01198">tlx::multiway_merge_base()</a>, and <a class="el" href="parallel__multiway__merge_8hpp_source.html#l00068">tlx::parallel_multiway_merge_base()</a>.</p>

</div>
</div>
<a id="ga635866c58aa0826d8c8ea7097f913935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga635866c58aa0826d8c8ea7097f913935">&#9670;&nbsp;</a></span>random_bipartition_shuffle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tlx::random_bipartition_shuffle </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIt&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIt&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size_left_partition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomBits &amp;&#160;</td>
          <td class="paramname"><em>urng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to std::shuffle, but only generates a random bi-partition. </p>
<p>In the result, the the left partition class is stored at positions 0 to size_left_partition-1 the right partition class is stored at positions size_left_partition to n where n = std::distance(begin, end).</p>
<p>Each element is moved to the left partition with probability (size_left_partition / n). There are no guarantees on the order WITHIN a partition (which makes this function considerable faster than std::shuffle especially if partition sizes are unbalanced). The runtime complexity is linear in the size of the smaller partition class.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>Iterator to the begin of the data frame </td></tr>
    <tr><td class="paramname">end</td><td>Iterator to the end of the data frame </td></tr>
    <tr><td class="paramname">size_left_partition</td><td>Number of elements to be put into the left partition: 0 &lt;= size_left_partition &lt;= n </td></tr>
    <tr><td class="paramname">urng</td><td>Random number generator compatible with STL interface, e.g. std::mt19937 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="random__bipartition__shuffle_8hpp_source.html#l00044">44</a> of file <a class="el" href="random__bipartition__shuffle_8hpp_source.html">random_bipartition_shuffle.hpp</a>.</p>

<p class="reference">References <a class="el" href="counting__ptr_8hpp_source.html#l00320">tlx::swap()</a>, and <a class="el" href="gen__data_8py_source.html#l00039">gen_data::x</a>.</p>

</div>
</div>
<a id="gab5a6467af7f10ab6f206eb3f9b3e0e4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab5a6467af7f10ab6f206eb3f9b3e0e4e">&#9670;&nbsp;</a></span>stable_multiway_merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RandomAccessIterator3 tlx::stable_multiway_merge </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator3&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em> = <code>Comparator()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__tlx__algorithm.html#ga98e900a348b28aa3709eb5e6d897ffbb">MultiwayMergeAlgorithm</a>&#160;</td>
          <td class="paramname"><em>mwma</em> = <code><a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbba332bba921707cc62f6a682b8ac2c9013">MWMA_ALGORITHM_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stable sequential multi-way merge. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seqs_begin</td><td>Begin iterator of iterator pair input sequence. </td></tr>
    <tr><td class="paramname">seqs_end</td><td>End iterator of iterator pair input sequence. </td></tr>
    <tr><td class="paramname">target</td><td>Begin iterator out output sequence. </td></tr>
    <tr><td class="paramname">size</td><td>Maximum size to merge. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparator. </td></tr>
    <tr><td class="paramname">mwma</td><td>MultiwayMergeAlgorithm set to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End iterator of output sequence. </dd></dl>

<p class="definition">Definition at line <a class="el" href="extlib_2tlx_2tlx_2algorithm_2multiway__merge_8hpp_source.html#l01357">1357</a> of file <a class="el" href="extlib_2tlx_2tlx_2algorithm_2multiway__merge_8hpp_source.html">multiway_merge.hpp</a>.</p>

<p class="reference">References <a class="el" href="extlib_2tlx_2tlx_2algorithm_2multiway__merge_8hpp_source.html#l01198">tlx::multiway_merge_base()</a>.</p>

</div>
</div>
<a id="gac2db163874c1c8e389c2736a72decb5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac2db163874c1c8e389c2736a72decb5f">&#9670;&nbsp;</a></span>stable_multiway_merge_sentinels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RandomAccessIterator3 tlx::stable_multiway_merge_sentinels </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator3&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em> = <code>Comparator()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__tlx__algorithm.html#ga98e900a348b28aa3709eb5e6d897ffbb">MultiwayMergeAlgorithm</a>&#160;</td>
          <td class="paramname"><em>mwma</em> = <code><a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbba332bba921707cc62f6a682b8ac2c9013">MWMA_ALGORITHM_DEFAULT</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stable sequential multi-way merge with sentinels in sequences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seqs_begin</td><td>Begin iterator of iterator pair input sequence. </td></tr>
    <tr><td class="paramname">seqs_end</td><td>End iterator of iterator pair input sequence. </td></tr>
    <tr><td class="paramname">target</td><td>Begin iterator out output sequence. </td></tr>
    <tr><td class="paramname">size</td><td>Maximum size to merge. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparator. </td></tr>
    <tr><td class="paramname">mwma</td><td>MultiwayMergeAlgorithm set to use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End iterator of output sequence. </dd></dl>

<p class="definition">Definition at line <a class="el" href="extlib_2tlx_2tlx_2algorithm_2multiway__merge_8hpp_source.html#l01423">1423</a> of file <a class="el" href="extlib_2tlx_2tlx_2algorithm_2multiway__merge_8hpp_source.html">multiway_merge.hpp</a>.</p>

<p class="reference">References <a class="el" href="extlib_2tlx_2tlx_2algorithm_2multiway__merge_8hpp_source.html#l01198">tlx::multiway_merge_base()</a>.</p>

</div>
</div>
<a id="gae6f27252c44641af08a7297588ab1e6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae6f27252c44641af08a7297588ab1e6b">&#9670;&nbsp;</a></span>stable_parallel_multiway_merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RandomAccessIterator3 tlx::stable_parallel_multiway_merge </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator3&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em> = <code>Comparator()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__tlx__algorithm.html#ga98e900a348b28aa3709eb5e6d897ffbb">MultiwayMergeAlgorithm</a>&#160;</td>
          <td class="paramname"><em>mwma</em> = <code><a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbba332bba921707cc62f6a682b8ac2c9013">MWMA_ALGORITHM_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__tlx__algorithm.html#ga8a7342a22bda2a80ef56d779ceae36c0">MultiwayMergeSplittingAlgorithm</a>&#160;</td>
          <td class="paramname"><em>mwmsa</em> = <code><a class="el" href="group__tlx__algorithm.html#gga8a7342a22bda2a80ef56d779ceae36c0acfb06584091121c62050c13c54e0e298">MWMSA_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_threads</em> = <code>std::thread::hardware_concurrency()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stable parallel multi-way merge routine. </p>
<p>Implemented either using OpenMP or with std::threads, depending on if compiled with -fopenmp or not. The OpenMP version uses the implicit thread pool, which is faster when using this method often.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seqs_begin</td><td>Begin iterator of iterator pair input sequence. </td></tr>
    <tr><td class="paramname">seqs_end</td><td>End iterator of iterator pair input sequence. </td></tr>
    <tr><td class="paramname">target</td><td>Begin iterator out output sequence. </td></tr>
    <tr><td class="paramname">size</td><td>Maximum size to merge. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparator. </td></tr>
    <tr><td class="paramname">mwma</td><td>MultiwayMergeAlgorithm set to use. </td></tr>
    <tr><td class="paramname">mwmsa</td><td>MultiwayMergeSplittingAlgorithm to use. </td></tr>
    <tr><td class="paramname">num_threads</td><td>Number of threads to use (defaults to all cores) </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stable</td><td>Stable merging incurs a performance penalty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End iterator of output sequence. </dd></dl>

<p class="definition">Definition at line <a class="el" href="parallel__multiway__merge_8hpp_source.html#l00286">286</a> of file <a class="el" href="parallel__multiway__merge_8hpp_source.html">parallel_multiway_merge.hpp</a>.</p>

<p class="reference">References <a class="el" href="extlib_2tlx_2tlx_2algorithm_2multiway__merge_8hpp_source.html#l01198">tlx::multiway_merge_base()</a>, and <a class="el" href="parallel__multiway__merge_8hpp_source.html#l00068">tlx::parallel_multiway_merge_base()</a>.</p>

</div>
</div>
<a id="gae1bcd8deadd96750e476982b2d572fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1bcd8deadd96750e476982b2d572fcf">&#9670;&nbsp;</a></span>stable_parallel_multiway_merge_sentinels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RandomAccessIterator3 tlx::stable_parallel_multiway_merge_sentinels </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIteratorIterator&#160;</td>
          <td class="paramname"><em>seqs_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator3&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename std::iterator_traits&lt; typename std::iterator_traits&lt; RandomAccessIteratorIterator &gt;::value_type::first_type &gt;::difference_type&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Comparator&#160;</td>
          <td class="paramname"><em>comp</em> = <code>Comparator()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__tlx__algorithm.html#ga98e900a348b28aa3709eb5e6d897ffbb">MultiwayMergeAlgorithm</a>&#160;</td>
          <td class="paramname"><em>mwma</em> = <code><a class="el" href="group__tlx__algorithm.html#gga98e900a348b28aa3709eb5e6d897ffbba332bba921707cc62f6a682b8ac2c9013">MWMA_ALGORITHM_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__tlx__algorithm.html#ga8a7342a22bda2a80ef56d779ceae36c0">MultiwayMergeSplittingAlgorithm</a>&#160;</td>
          <td class="paramname"><em>mwmsa</em> = <code><a class="el" href="group__tlx__algorithm.html#gga8a7342a22bda2a80ef56d779ceae36c0acfb06584091121c62050c13c54e0e298">MWMSA_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_threads</em> = <code>std::thread::hardware_concurrency()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stable parallel multi-way merge routine with sentinels. </p>
<p>Implemented either using OpenMP or with std::threads, depending on if compiled with -fopenmp or not. The OpenMP version uses the implicit thread pool, which is faster when using this method often.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">seqs_begin</td><td>Begin iterator of iterator pair input sequence. </td></tr>
    <tr><td class="paramname">seqs_end</td><td>End iterator of iterator pair input sequence. </td></tr>
    <tr><td class="paramname">target</td><td>Begin iterator out output sequence. </td></tr>
    <tr><td class="paramname">size</td><td>Maximum size to merge. </td></tr>
    <tr><td class="paramname">comp</td><td>Comparator. </td></tr>
    <tr><td class="paramname">mwma</td><td>MultiwayMergeAlgorithm set to use. </td></tr>
    <tr><td class="paramname">mwmsa</td><td>MultiwayMergeSplittingAlgorithm to use. </td></tr>
    <tr><td class="paramname">num_threads</td><td>Number of threads to use (defaults to all cores) </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Stable</td><td>Stable merging incurs a performance penalty. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>End iterator of output sequence. </dd></dl>

<p class="definition">Definition at line <a class="el" href="parallel__multiway__merge_8hpp_source.html#l00400">400</a> of file <a class="el" href="parallel__multiway__merge_8hpp_source.html">parallel_multiway_merge.hpp</a>.</p>

<p class="reference">References <a class="el" href="extlib_2tlx_2tlx_2algorithm_2multiway__merge_8hpp_source.html#l01198">tlx::multiway_merge_base()</a>, and <a class="el" href="parallel__multiway__merge_8hpp_source.html#l00068">tlx::parallel_multiway_merge_base()</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ga8345e9f64e776708ff06090e0480f9ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8345e9f64e776708ff06090e0480f9ae">&#9670;&nbsp;</a></span>parallel_multiway_merge_force_parallel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parallel_multiway_merge_force_parallel = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>setting to force <a class="el" href="group__tlx__algorithm.html#gac3580dd876ff80d088499292a12d2fbe" title="Parallel multi-way merge routine. ">parallel_multiway_merge()</a> calls to run with parallel code </p>

<p class="definition">Definition at line <a class="el" href="parallel__multiway__merge_8cpp_source.html#l00029">29</a> of file <a class="el" href="parallel__multiway__merge_8cpp_source.html">parallel_multiway_merge.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="parallel__multiway__merge_8hpp_source.html#l00068">tlx::parallel_multiway_merge_base()</a>.</p>

</div>
</div>
<a id="gaee58bcd5ecf83c8fde2fdfcb4645a91c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee58bcd5ecf83c8fde2fdfcb4645a91c">&#9670;&nbsp;</a></span>parallel_multiway_merge_force_sequential</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parallel_multiway_merge_force_sequential = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>setting to force all <a class="el" href="group__tlx__algorithm.html#gac3580dd876ff80d088499292a12d2fbe" title="Parallel multi-way merge routine. ">parallel_multiway_merge()</a> calls to run sequentially </p>

<p class="definition">Definition at line <a class="el" href="parallel__multiway__merge_8cpp_source.html#l00027">27</a> of file <a class="el" href="parallel__multiway__merge_8cpp_source.html">parallel_multiway_merge.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="parallel__multiway__merge_8hpp_source.html#l00068">tlx::parallel_multiway_merge_base()</a>.</p>

</div>
</div>
<a id="ga3fec55f066eef8bab8e18da604f978f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3fec55f066eef8bab8e18da604f978f0">&#9670;&nbsp;</a></span>parallel_multiway_merge_minimal_k</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t parallel_multiway_merge_minimal_k = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>minimal number of sequences for switching to parallel merging </p>

<p class="definition">Definition at line <a class="el" href="parallel__multiway__merge_8cpp_source.html#l00031">31</a> of file <a class="el" href="parallel__multiway__merge_8cpp_source.html">parallel_multiway_merge.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="parallel__multiway__merge_8hpp_source.html#l00068">tlx::parallel_multiway_merge_base()</a>.</p>

</div>
</div>
<a id="ga13c75c629afda60aa74bfc46239c977c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga13c75c629afda60aa74bfc46239c977c">&#9670;&nbsp;</a></span>parallel_multiway_merge_minimal_n</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t parallel_multiway_merge_minimal_n = 1000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>minimal number of items for switching to parallel merging </p>

<p class="definition">Definition at line <a class="el" href="parallel__multiway__merge_8cpp_source.html#l00033">33</a> of file <a class="el" href="parallel__multiway__merge_8cpp_source.html">parallel_multiway_merge.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="parallel__multiway__merge_8hpp_source.html#l00068">tlx::parallel_multiway_merge_base()</a>.</p>

</div>
</div>
<a id="ga0a0a9b421b4afc71557597aa03874b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a0a9b421b4afc71557597aa03874b4d">&#9670;&nbsp;</a></span>parallel_multiway_merge_oversampling</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t parallel_multiway_merge_oversampling = 10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>default oversampling factor for parallel_multiway_merge </p>

<p class="definition">Definition at line <a class="el" href="parallel__multiway__merge_8cpp_source.html#l00035">35</a> of file <a class="el" href="parallel__multiway__merge_8cpp_source.html">parallel_multiway_merge.cpp</a>.</p>

<p class="reference">Referenced by <a class="el" href="parallel__mergesort_8hpp_source.html#l00093">tlx::parallel_mergesort_detail::determine_samples()</a>, <a class="el" href="parallel__mergesort_8hpp_source.html#l00280">tlx::parallel_mergesort_base()</a>, and <a class="el" href="parallel__multiway__merge_8hpp_source.html#l00068">tlx::parallel_multiway_merge_base()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Mon Apr 6 2020 06:53:59 for Thrill by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
