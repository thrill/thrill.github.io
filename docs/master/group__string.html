<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Thrill: String Algorithms</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Thrill
   &#160;<span id="projectnumber">0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__string.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(11)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(12)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">String Algorithms</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga7a87b7f6120ebcde0c01ad293465f9d7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga7a87b7f6120ebcde0c01ad293465f9d7">compare_icase</a> (const char *a, const char *b)</td></tr>
<tr class="memdesc:ga7a87b7f6120ebcde0c01ad293465f9d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns +1/0/-1 like strcmp(a, b) but without regard for letter case  <a href="#ga7a87b7f6120ebcde0c01ad293465f9d7">More...</a><br/></td></tr>
<tr class="separator:ga7a87b7f6120ebcde0c01ad293465f9d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga061e7b66eb332d7621ef99d11b724c16"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga061e7b66eb332d7621ef99d11b724c16">compare_icase</a> (const char *a, const std::string &amp;b)</td></tr>
<tr class="memdesc:ga061e7b66eb332d7621ef99d11b724c16"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns +1/0/-1 like strcmp(a, b) but without regard for letter case  <a href="#ga061e7b66eb332d7621ef99d11b724c16">More...</a><br/></td></tr>
<tr class="separator:ga061e7b66eb332d7621ef99d11b724c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6b99f43a01b6d2ff8ca49f4518297b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#gad6b99f43a01b6d2ff8ca49f4518297b9">compare_icase</a> (const std::string &amp;a, const char *b)</td></tr>
<tr class="memdesc:gad6b99f43a01b6d2ff8ca49f4518297b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns +1/0/-1 like strcmp(a, b) but without regard for letter case  <a href="#gad6b99f43a01b6d2ff8ca49f4518297b9">More...</a><br/></td></tr>
<tr class="separator:gad6b99f43a01b6d2ff8ca49f4518297b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga988bb20efc727413da0a9d9d11f488b0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga988bb20efc727413da0a9d9d11f488b0">compare_icase</a> (const std::string &amp;a, const std::string &amp;b)</td></tr>
<tr class="memdesc:ga988bb20efc727413da0a9d9d11f488b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns +1/0/-1 like strcmp(a, b) but without regard for letter case  <a href="#ga988bb20efc727413da0a9d9d11f488b0">More...</a><br/></td></tr>
<tr class="separator:ga988bb20efc727413da0a9d9d11f488b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ff92619b9a2ae3dbbdd6ef511c1779e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga7ff92619b9a2ae3dbbdd6ef511c1779e">contains</a> (const std::string &amp;str, const std::string &amp;pattern)</td></tr>
<tr class="memdesc:ga7ff92619b9a2ae3dbbdd6ef511c1779e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests of string contains pattern.  <a href="#ga7ff92619b9a2ae3dbbdd6ef511c1779e">More...</a><br/></td></tr>
<tr class="separator:ga7ff92619b9a2ae3dbbdd6ef511c1779e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga399719274798a8a808e8e309ab490f03"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga399719274798a8a808e8e309ab490f03">contains</a> (const std::string &amp;str, const char *pattern)</td></tr>
<tr class="memdesc:ga399719274798a8a808e8e309ab490f03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests of string contains pattern.  <a href="#ga399719274798a8a808e8e309ab490f03">More...</a><br/></td></tr>
<tr class="separator:ga399719274798a8a808e8e309ab490f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d6aca56ee9463cd116fc8e065c4c3a0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga8d6aca56ee9463cd116fc8e065c4c3a0">contains</a> (const std::string &amp;str, const char ch)</td></tr>
<tr class="memdesc:ga8d6aca56ee9463cd116fc8e065c4c3a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests of string contains character.  <a href="#ga8d6aca56ee9463cd116fc8e065c4c3a0">More...</a><br/></td></tr>
<tr class="separator:ga8d6aca56ee9463cd116fc8e065c4c3a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2fd07edea7502e13dbc9d2991be95f02"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga2fd07edea7502e13dbc9d2991be95f02">contains_word</a> (const std::string &amp;str, const char *word)</td></tr>
<tr class="memdesc:ga2fd07edea7502e13dbc9d2991be95f02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the given string for a whitespace-delimited word.  <a href="#ga2fd07edea7502e13dbc9d2991be95f02">More...</a><br/></td></tr>
<tr class="separator:ga2fd07edea7502e13dbc9d2991be95f02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f7b2444597941650e05c1bb96b04f45"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga7f7b2444597941650e05c1bb96b04f45">contains_word</a> (const std::string &amp;str, const std::string &amp;word)</td></tr>
<tr class="memdesc:ga7f7b2444597941650e05c1bb96b04f45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the given string for a whitespace-delimited word.  <a href="#ga7f7b2444597941650e05c1bb96b04f45">More...</a><br/></td></tr>
<tr class="separator:ga7f7b2444597941650e05c1bb96b04f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6eadd6e031f051ff44c5ab2935cdddfd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga6eadd6e031f051ff44c5ab2935cdddfd">ends_with</a> (const std::string &amp;str, const std::string &amp;match)</td></tr>
<tr class="memdesc:ga6eadd6e031f051ff44c5ab2935cdddfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the end of this string.  <a href="#ga6eadd6e031f051ff44c5ab2935cdddfd">More...</a><br/></td></tr>
<tr class="separator:ga6eadd6e031f051ff44c5ab2935cdddfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacea7b710bca17bae104e7e5eb6137fcf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#gacea7b710bca17bae104e7e5eb6137fcf">ends_with</a> (const std::string &amp;str, const char *match)</td></tr>
<tr class="memdesc:gacea7b710bca17bae104e7e5eb6137fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the end of this string.  <a href="#gacea7b710bca17bae104e7e5eb6137fcf">More...</a><br/></td></tr>
<tr class="separator:gacea7b710bca17bae104e7e5eb6137fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga849ffa2f657372a30b5cfc53fe1267a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga849ffa2f657372a30b5cfc53fe1267a1">ends_with_icase</a> (const std::string &amp;str, const std::string &amp;match)</td></tr>
<tr class="memdesc:ga849ffa2f657372a30b5cfc53fe1267a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the end of this string.  <a href="#ga849ffa2f657372a30b5cfc53fe1267a1">More...</a><br/></td></tr>
<tr class="separator:ga849ffa2f657372a30b5cfc53fe1267a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac7e29572ead3f33c45cd95c8d4b720d0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#gac7e29572ead3f33c45cd95c8d4b720d0">ends_with_icase</a> (const std::string &amp;str, const char *match)</td></tr>
<tr class="memdesc:gac7e29572ead3f33c45cd95c8d4b720d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the end of this string.  <a href="#gac7e29572ead3f33c45cd95c8d4b720d0">More...</a><br/></td></tr>
<tr class="separator:gac7e29572ead3f33c45cd95c8d4b720d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42a4d6e9f12943be811bcb6666d53493"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga42a4d6e9f12943be811bcb6666d53493">equal_icase</a> (const char *a, const char *b)</td></tr>
<tr class="memdesc:ga42a4d6e9f12943be811bcb6666d53493"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a == b without regard for letter case  <a href="#ga42a4d6e9f12943be811bcb6666d53493">More...</a><br/></td></tr>
<tr class="separator:ga42a4d6e9f12943be811bcb6666d53493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad15c6b082515414b93a34b7ac0327df9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#gad15c6b082515414b93a34b7ac0327df9">equal_icase</a> (const char *a, const std::string &amp;b)</td></tr>
<tr class="memdesc:gad15c6b082515414b93a34b7ac0327df9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a == b without regard for letter case  <a href="#gad15c6b082515414b93a34b7ac0327df9">More...</a><br/></td></tr>
<tr class="separator:gad15c6b082515414b93a34b7ac0327df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga118abe0d4d0cd1d90426121b626aeea9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga118abe0d4d0cd1d90426121b626aeea9">equal_icase</a> (const std::string &amp;a, const char *b)</td></tr>
<tr class="memdesc:ga118abe0d4d0cd1d90426121b626aeea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a == b without regard for letter case  <a href="#ga118abe0d4d0cd1d90426121b626aeea9">More...</a><br/></td></tr>
<tr class="separator:ga118abe0d4d0cd1d90426121b626aeea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c9c153df7b49712108276c9a48fe88e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga2c9c153df7b49712108276c9a48fe88e">equal_icase</a> (const std::string &amp;a, const std::string &amp;b)</td></tr>
<tr class="memdesc:ga2c9c153df7b49712108276c9a48fe88e"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a == b without regard for letter case  <a href="#ga2c9c153df7b49712108276c9a48fe88e">More...</a><br/></td></tr>
<tr class="separator:ga2c9c153df7b49712108276c9a48fe88e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga593df4d923a5f07d65ff39950e31e367"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga593df4d923a5f07d65ff39950e31e367">erase_all</a> (std::string *str, char drop= ' ')</td></tr>
<tr class="memdesc:ga593df4d923a5f07d65ff39950e31e367"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurrences of the given character in-place.  <a href="#ga593df4d923a5f07d65ff39950e31e367">More...</a><br/></td></tr>
<tr class="separator:ga593df4d923a5f07d65ff39950e31e367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga290c6e7261f453c4774a0cf82586bf47"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga290c6e7261f453c4774a0cf82586bf47">erase_all</a> (std::string *str, const char *drop)</td></tr>
<tr class="memdesc:ga290c6e7261f453c4774a0cf82586bf47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurrences of the given characters in-place.  <a href="#ga290c6e7261f453c4774a0cf82586bf47">More...</a><br/></td></tr>
<tr class="separator:ga290c6e7261f453c4774a0cf82586bf47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacefd443f50a3e6123651a031eb1701c4"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#gacefd443f50a3e6123651a031eb1701c4">erase_all</a> (std::string *str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:gacefd443f50a3e6123651a031eb1701c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurrences of the given characters in-place.  <a href="#gacefd443f50a3e6123651a031eb1701c4">More...</a><br/></td></tr>
<tr class="separator:gacefd443f50a3e6123651a031eb1701c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86282247928444ece567ced18f0012b1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga86282247928444ece567ced18f0012b1">erase_all</a> (const std::string &amp;str, char drop= ' ')</td></tr>
<tr class="memdesc:ga86282247928444ece567ced18f0012b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurrences of the given character, return copy of string.  <a href="#ga86282247928444ece567ced18f0012b1">More...</a><br/></td></tr>
<tr class="separator:ga86282247928444ece567ced18f0012b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c0aa5a14584e80887d4afc8c34337f8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga7c0aa5a14584e80887d4afc8c34337f8">erase_all</a> (const std::string &amp;str, const char *drop)</td></tr>
<tr class="memdesc:ga7c0aa5a14584e80887d4afc8c34337f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurrences of the given characters, return copy of string.  <a href="#ga7c0aa5a14584e80887d4afc8c34337f8">More...</a><br/></td></tr>
<tr class="separator:ga7c0aa5a14584e80887d4afc8c34337f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09e7dd3f20d8e54c8502c81d540f9916"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga09e7dd3f20d8e54c8502c81d540f9916">erase_all</a> (const std::string &amp;str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:ga09e7dd3f20d8e54c8502c81d540f9916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all occurrences of the given characters, return copy of string.  <a href="#ga09e7dd3f20d8e54c8502c81d540f9916">More...</a><br/></td></tr>
<tr class="separator:ga09e7dd3f20d8e54c8502c81d540f9916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa3ec7c7d258293a6891f016878d22f09"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#gaa3ec7c7d258293a6891f016878d22f09">escape_html</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:gaa3ec7c7d258293a6891f016878d22f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escape characters for inclusion in HTML documents: replaces the characters &lt;, &gt;, &amp; and " with HTML entities.  <a href="#gaa3ec7c7d258293a6891f016878d22f09">More...</a><br/></td></tr>
<tr class="separator:gaa3ec7c7d258293a6891f016878d22f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c9dca404398316e3ffb6266d592b38d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga6c9dca404398316e3ffb6266d592b38d">escape_uri</a> (const std::string &amp;src)</td></tr>
<tr class="memdesc:ga6c9dca404398316e3ffb6266d592b38d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escape a string into a URI-encoding.  <a href="#ga6c9dca404398316e3ffb6266d592b38d">More...</a><br/></td></tr>
<tr class="separator:ga6c9dca404398316e3ffb6266d592b38d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga713c5cd2e2209e379c8b79ba2cd3e398"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga713c5cd2e2209e379c8b79ba2cd3e398">extract_between</a> (const std::string &amp;str, const char *sep1, const char *sep2)</td></tr>
<tr class="memdesc:ga713c5cd2e2209e379c8b79ba2cd3e398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the string for given start and end separators and extract all characters between the both, if they are found.  <a href="#ga713c5cd2e2209e379c8b79ba2cd3e398">More...</a><br/></td></tr>
<tr class="separator:ga713c5cd2e2209e379c8b79ba2cd3e398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1ac1e43a5ae269bdbe594c4f4f4a325"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#gae1ac1e43a5ae269bdbe594c4f4f4a325">extract_between</a> (const std::string &amp;str, const char *sep1, const std::string &amp;sep2)</td></tr>
<tr class="memdesc:gae1ac1e43a5ae269bdbe594c4f4f4a325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the string for given start and end separators and extract all characters between the both, if they are found.  <a href="#gae1ac1e43a5ae269bdbe594c4f4f4a325">More...</a><br/></td></tr>
<tr class="separator:gae1ac1e43a5ae269bdbe594c4f4f4a325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0c6e73d346e3deda660b2eb24b06c67"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#gaf0c6e73d346e3deda660b2eb24b06c67">extract_between</a> (const std::string &amp;str, const std::string &amp;sep1, const char *sep2)</td></tr>
<tr class="memdesc:gaf0c6e73d346e3deda660b2eb24b06c67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the string for given start and end separators and extract all characters between the both, if they are found.  <a href="#gaf0c6e73d346e3deda660b2eb24b06c67">More...</a><br/></td></tr>
<tr class="separator:gaf0c6e73d346e3deda660b2eb24b06c67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3a44aaf97230d79b6aac046331240d3"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#gab3a44aaf97230d79b6aac046331240d3">extract_between</a> (const std::string &amp;str, const std::string &amp;sep1, const std::string &amp;sep2)</td></tr>
<tr class="memdesc:gab3a44aaf97230d79b6aac046331240d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Search the string for given start and end separators and extract all characters between the both, if they are found.  <a href="#gab3a44aaf97230d79b6aac046331240d3">More...</a><br/></td></tr>
<tr class="separator:gab3a44aaf97230d79b6aac046331240d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga937bd46650d317c28df7c7723ae84119"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga937bd46650d317c28df7c7723ae84119">format_iec_units</a> (uint64_t number, int precision)</td></tr>
<tr class="memdesc:ga937bd46650d317c28df7c7723ae84119"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format number as something like 1 TiB.  <a href="#ga937bd46650d317c28df7c7723ae84119">More...</a><br/></td></tr>
<tr class="separator:ga937bd46650d317c28df7c7723ae84119"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga084c15f3eff7d1eb6018d00779486013"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga084c15f3eff7d1eb6018d00779486013">format_si_units</a> (uint64_t number, int precision)</td></tr>
<tr class="memdesc:ga084c15f3eff7d1eb6018d00779486013"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format number as something like 1 TB.  <a href="#ga084c15f3eff7d1eb6018d00779486013">More...</a><br/></td></tr>
<tr class="separator:ga084c15f3eff7d1eb6018d00779486013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15b290439811d07e8fc0a6134c4faa0b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga15b290439811d07e8fc0a6134c4faa0b">index_of</a> (const std::vector&lt; std::string &gt; &amp;list, const char *str)</td></tr>
<tr class="memdesc:ga15b290439811d07e8fc0a6134c4faa0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to find str in the list and return the index.  <a href="#ga15b290439811d07e8fc0a6134c4faa0b">More...</a><br/></td></tr>
<tr class="separator:ga15b290439811d07e8fc0a6134c4faa0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5156b8029cca4a21cb3e1b14ea6526d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#gac5156b8029cca4a21cb3e1b14ea6526d">index_of</a> (const std::vector&lt; std::string &gt; &amp;list, const std::string &amp;str)</td></tr>
<tr class="memdesc:gac5156b8029cca4a21cb3e1b14ea6526d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to find str in the list and return the index.  <a href="#gac5156b8029cca4a21cb3e1b14ea6526d">More...</a><br/></td></tr>
<tr class="separator:gac5156b8029cca4a21cb3e1b14ea6526d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00bece0086ba6a8598e97e93694b713f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga00bece0086ba6a8598e97e93694b713f">index_of_icase</a> (const std::vector&lt; std::string &gt; &amp;list, const char *str)</td></tr>
<tr class="memdesc:ga00bece0086ba6a8598e97e93694b713f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to find str in the list and return the index using case-insensitive comparisons.  <a href="#ga00bece0086ba6a8598e97e93694b713f">More...</a><br/></td></tr>
<tr class="separator:ga00bece0086ba6a8598e97e93694b713f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d3b5b0636e261f97ab3292d78f2201b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga2d3b5b0636e261f97ab3292d78f2201b">index_of_icase</a> (const std::vector&lt; std::string &gt; &amp;list, const std::string &amp;str)</td></tr>
<tr class="memdesc:ga2d3b5b0636e261f97ab3292d78f2201b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Attempts to find str in the list and return the index using case-insensitive comparisons.  <a href="#ga2d3b5b0636e261f97ab3292d78f2201b">More...</a><br/></td></tr>
<tr class="separator:ga2d3b5b0636e261f97ab3292d78f2201b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad383d32ace209b51abe936d256d0bb1e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#gad383d32ace209b51abe936d256d0bb1e">join</a> (char glue, const std::vector&lt; std::string &gt; &amp;parts)</td></tr>
<tr class="memdesc:gad383d32ace209b51abe936d256d0bb1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a vector of strings by some glue character between each pair from the sequence.  <a href="#gad383d32ace209b51abe936d256d0bb1e">More...</a><br/></td></tr>
<tr class="separator:gad383d32ace209b51abe936d256d0bb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0cb20ee53f25c37880faf1b5e5ac3619"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga0cb20ee53f25c37880faf1b5e5ac3619">join</a> (const char *glue, const std::vector&lt; std::string &gt; &amp;parts)</td></tr>
<tr class="memdesc:ga0cb20ee53f25c37880faf1b5e5ac3619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a vector of strings by some glue string between each pair from the sequence.  <a href="#ga0cb20ee53f25c37880faf1b5e5ac3619">More...</a><br/></td></tr>
<tr class="separator:ga0cb20ee53f25c37880faf1b5e5ac3619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga206c170915b483387448714300d311c1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga206c170915b483387448714300d311c1">join</a> (const std::string &amp;glue, const std::vector&lt; std::string &gt; &amp;parts)</td></tr>
<tr class="memdesc:ga206c170915b483387448714300d311c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a vector of strings by some glue string between each pair from the sequence.  <a href="#ga206c170915b483387448714300d311c1">More...</a><br/></td></tr>
<tr class="separator:ga206c170915b483387448714300d311c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1af0448079469f224ea8905c34dc1868"><td class="memTemplParams" colspan="2">template&lt;typename Glue , typename Iterator &gt; </td></tr>
<tr class="memitem:ga1af0448079469f224ea8905c34dc1868"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__string.html#ga1af0448079469f224ea8905c34dc1868">join</a> (Glue glue, Iterator first, Iterator last)</td></tr>
<tr class="memdesc:ga1af0448079469f224ea8905c34dc1868"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a sequence of strings by some glue string between each pair from the sequence.  <a href="#ga1af0448079469f224ea8905c34dc1868">More...</a><br/></td></tr>
<tr class="separator:ga1af0448079469f224ea8905c34dc1868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a96227b0edd6c65800124ba1dac82cf"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:ga4a96227b0edd6c65800124ba1dac82cf"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__string.html#ga4a96227b0edd6c65800124ba1dac82cf">join</a> (char glue, const Container &amp;parts)</td></tr>
<tr class="memdesc:ga4a96227b0edd6c65800124ba1dac82cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a Container of strings by some glue character between each pair from the sequence.  <a href="#ga4a96227b0edd6c65800124ba1dac82cf">More...</a><br/></td></tr>
<tr class="separator:ga4a96227b0edd6c65800124ba1dac82cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffea57c0c1e61aa8c9bc50e1ec2f9fe2"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:gaffea57c0c1e61aa8c9bc50e1ec2f9fe2"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__string.html#gaffea57c0c1e61aa8c9bc50e1ec2f9fe2">join</a> (const char *glue, const Container &amp;parts)</td></tr>
<tr class="memdesc:gaffea57c0c1e61aa8c9bc50e1ec2f9fe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a Container of strings by some glue string between each pair from the sequence.  <a href="#gaffea57c0c1e61aa8c9bc50e1ec2f9fe2">More...</a><br/></td></tr>
<tr class="separator:gaffea57c0c1e61aa8c9bc50e1ec2f9fe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e35ca12bd4564ba470e3bf4f6a91798"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:ga2e35ca12bd4564ba470e3bf4f6a91798"><td class="memTemplItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__string.html#ga2e35ca12bd4564ba470e3bf4f6a91798">join</a> (const std::string &amp;glue, const Container &amp;parts)</td></tr>
<tr class="memdesc:ga2e35ca12bd4564ba470e3bf4f6a91798"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join a Container of strings by some glue string between each pair from the sequence.  <a href="#ga2e35ca12bd4564ba470e3bf4f6a91798">More...</a><br/></td></tr>
<tr class="separator:ga2e35ca12bd4564ba470e3bf4f6a91798"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a73759be8d7ec5778cb6192bc32c4c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga3a73759be8d7ec5778cb6192bc32c4c2">less_icase</a> (const char *a, const char *b)</td></tr>
<tr class="memdesc:ga3a73759be8d7ec5778cb6192bc32c4c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a &lt; b without regard for letter case  <a href="#ga3a73759be8d7ec5778cb6192bc32c4c2">More...</a><br/></td></tr>
<tr class="separator:ga3a73759be8d7ec5778cb6192bc32c4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e53bb43043cc4fdf6fef5a9f017957c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga0e53bb43043cc4fdf6fef5a9f017957c">less_icase</a> (const char *a, const std::string &amp;b)</td></tr>
<tr class="memdesc:ga0e53bb43043cc4fdf6fef5a9f017957c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a &lt; b without regard for letter case  <a href="#ga0e53bb43043cc4fdf6fef5a9f017957c">More...</a><br/></td></tr>
<tr class="separator:ga0e53bb43043cc4fdf6fef5a9f017957c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25e2629353a36fb47c587b4eef89c0d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga25e2629353a36fb47c587b4eef89c0d2">less_icase</a> (const std::string &amp;a, const char *b)</td></tr>
<tr class="memdesc:ga25e2629353a36fb47c587b4eef89c0d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a &lt; b without regard for letter case  <a href="#ga25e2629353a36fb47c587b4eef89c0d2">More...</a><br/></td></tr>
<tr class="separator:ga25e2629353a36fb47c587b4eef89c0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9fb49f152c6bf0d96ec46bfb90a38bfc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga9fb49f152c6bf0d96ec46bfb90a38bfc">less_icase</a> (const std::string &amp;a, const std::string &amp;b)</td></tr>
<tr class="memdesc:ga9fb49f152c6bf0d96ec46bfb90a38bfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if a &lt; b without regard for letter case  <a href="#ga9fb49f152c6bf0d96ec46bfb90a38bfc">More...</a><br/></td></tr>
<tr class="separator:ga9fb49f152c6bf0d96ec46bfb90a38bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03240bad0b02669f254c21c28009c21a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga03240bad0b02669f254c21c28009c21a">pad</a> (const std::string &amp;s, size_t len, char pad_char= ' ')</td></tr>
<tr class="memdesc:ga03240bad0b02669f254c21c28009c21a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate or pad string to exactly len characters.  <a href="#ga03240bad0b02669f254c21c28009c21a">More...</a><br/></td></tr>
<tr class="separator:ga03240bad0b02669f254c21c28009c21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58be0557b1b38913b28d947c935aed42"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga58be0557b1b38913b28d947c935aed42">parse_si_iec_units</a> (const char *str, uint64_t *out_size, char default_unit=0)</td></tr>
<tr class="memdesc:ga58be0557b1b38913b28d947c935aed42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a string like "343KB" or "44 GiB" into the corresponding size in bytes.  <a href="#ga58be0557b1b38913b28d947c935aed42">More...</a><br/></td></tr>
<tr class="separator:ga58be0557b1b38913b28d947c935aed42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42a656ed3586b515140cb71b312f0f9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga42a656ed3586b515140cb71b312f0f9b">parse_si_iec_units</a> (const std::string &amp;str, uint64_t *out_size, char default_unit=0)</td></tr>
<tr class="memdesc:ga42a656ed3586b515140cb71b312f0f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a string like "343KB" or "44 GiB" into the corresponding size in bytes.  <a href="#ga42a656ed3586b515140cb71b312f0f9b">More...</a><br/></td></tr>
<tr class="separator:ga42a656ed3586b515140cb71b312f0f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7021d36930f4bd434b2082dce8bd43cf"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga7021d36930f4bd434b2082dce8bd43cf">replace_all</a> (std::string *str, const std::string &amp;needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:ga7021d36930f4bd434b2082dce8bd43cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="#ga7021d36930f4bd434b2082dce8bd43cf">More...</a><br/></td></tr>
<tr class="separator:ga7021d36930f4bd434b2082dce8bd43cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd5bd9f9a887fa20b4a8ebaf987fd5de"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#gadd5bd9f9a887fa20b4a8ebaf987fd5de">replace_all</a> (std::string *str, const std::string &amp;needle, const char *instead)</td></tr>
<tr class="memdesc:gadd5bd9f9a887fa20b4a8ebaf987fd5de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="#gadd5bd9f9a887fa20b4a8ebaf987fd5de">More...</a><br/></td></tr>
<tr class="separator:gadd5bd9f9a887fa20b4a8ebaf987fd5de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b4b8117690af529b7051a3c10c382ff"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga6b4b8117690af529b7051a3c10c382ff">replace_all</a> (std::string *str, const char *needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:ga6b4b8117690af529b7051a3c10c382ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="#ga6b4b8117690af529b7051a3c10c382ff">More...</a><br/></td></tr>
<tr class="separator:ga6b4b8117690af529b7051a3c10c382ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d7d14badd05473e5a5c847b3f91b9e9"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga0d7d14badd05473e5a5c847b3f91b9e9">replace_all</a> (std::string *str, const char *needle, const char *instead)</td></tr>
<tr class="memdesc:ga0d7d14badd05473e5a5c847b3f91b9e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="#ga0d7d14badd05473e5a5c847b3f91b9e9">More...</a><br/></td></tr>
<tr class="separator:ga0d7d14badd05473e5a5c847b3f91b9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga768d59e5cc6d2c91f25a441ab4d265a6"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga768d59e5cc6d2c91f25a441ab4d265a6">replace_all</a> (std::string *str, char needle, char instead)</td></tr>
<tr class="memdesc:ga768d59e5cc6d2c91f25a441ab4d265a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="#ga768d59e5cc6d2c91f25a441ab4d265a6">More...</a><br/></td></tr>
<tr class="separator:ga768d59e5cc6d2c91f25a441ab4d265a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac001aff0fa6c3bee2e9755e3ddd516f9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#gac001aff0fa6c3bee2e9755e3ddd516f9">replace_all</a> (const std::string &amp;str, const std::string &amp;needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:gac001aff0fa6c3bee2e9755e3ddd516f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="#gac001aff0fa6c3bee2e9755e3ddd516f9">More...</a><br/></td></tr>
<tr class="separator:gac001aff0fa6c3bee2e9755e3ddd516f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadfe9c066393585d1a769cbd55e9f9960"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#gadfe9c066393585d1a769cbd55e9f9960">replace_all</a> (const std::string &amp;str, const std::string &amp;needle, const char *instead)</td></tr>
<tr class="memdesc:gadfe9c066393585d1a769cbd55e9f9960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="#gadfe9c066393585d1a769cbd55e9f9960">More...</a><br/></td></tr>
<tr class="separator:gadfe9c066393585d1a769cbd55e9f9960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4e3b406ea495a236fff401c3585d8814"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga4e3b406ea495a236fff401c3585d8814">replace_all</a> (const std::string &amp;str, const char *needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:ga4e3b406ea495a236fff401c3585d8814"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="#ga4e3b406ea495a236fff401c3585d8814">More...</a><br/></td></tr>
<tr class="separator:ga4e3b406ea495a236fff401c3585d8814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14cfa75fa579e1d4943855455d9e605d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga14cfa75fa579e1d4943855455d9e605d">replace_all</a> (const std::string &amp;str, const char *needle, const char *instead)</td></tr>
<tr class="memdesc:ga14cfa75fa579e1d4943855455d9e605d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="#ga14cfa75fa579e1d4943855455d9e605d">More...</a><br/></td></tr>
<tr class="separator:ga14cfa75fa579e1d4943855455d9e605d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae87b40ae8e461c110fffcb7a12b066d5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#gae87b40ae8e461c110fffcb7a12b066d5">replace_all</a> (const std::string &amp;str, char needle, char instead)</td></tr>
<tr class="memdesc:gae87b40ae8e461c110fffcb7a12b066d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace all occurrences of needle in str.  <a href="#gae87b40ae8e461c110fffcb7a12b066d5">More...</a><br/></td></tr>
<tr class="separator:gae87b40ae8e461c110fffcb7a12b066d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca0aeb9a74105ec849e939229d47970b"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#gaca0aeb9a74105ec849e939229d47970b">replace_first</a> (std::string *str, const std::string &amp;needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:gaca0aeb9a74105ec849e939229d47970b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="#gaca0aeb9a74105ec849e939229d47970b">More...</a><br/></td></tr>
<tr class="separator:gaca0aeb9a74105ec849e939229d47970b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32d2a706e20d6e5b07cbb677c340deba"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga32d2a706e20d6e5b07cbb677c340deba">replace_first</a> (std::string *str, const std::string &amp;needle, const char *instead)</td></tr>
<tr class="memdesc:ga32d2a706e20d6e5b07cbb677c340deba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="#ga32d2a706e20d6e5b07cbb677c340deba">More...</a><br/></td></tr>
<tr class="separator:ga32d2a706e20d6e5b07cbb677c340deba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2b83d93d49145437aec2964f30e4cd1"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#gab2b83d93d49145437aec2964f30e4cd1">replace_first</a> (std::string *str, const char *needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:gab2b83d93d49145437aec2964f30e4cd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="#gab2b83d93d49145437aec2964f30e4cd1">More...</a><br/></td></tr>
<tr class="separator:gab2b83d93d49145437aec2964f30e4cd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ed49bc3eebffeefeff05f84ffbcc086"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga6ed49bc3eebffeefeff05f84ffbcc086">replace_first</a> (std::string *str, const char *needle, const char *instead)</td></tr>
<tr class="memdesc:ga6ed49bc3eebffeefeff05f84ffbcc086"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="#ga6ed49bc3eebffeefeff05f84ffbcc086">More...</a><br/></td></tr>
<tr class="separator:ga6ed49bc3eebffeefeff05f84ffbcc086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4865798a465a43845804dda0fe21f888"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga4865798a465a43845804dda0fe21f888">replace_first</a> (std::string *str, char needle, char instead)</td></tr>
<tr class="memdesc:ga4865798a465a43845804dda0fe21f888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="#ga4865798a465a43845804dda0fe21f888">More...</a><br/></td></tr>
<tr class="separator:ga4865798a465a43845804dda0fe21f888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b0092a333e84d0c4eaae50955bc5a71"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga8b0092a333e84d0c4eaae50955bc5a71">replace_first</a> (const std::string &amp;str, const std::string &amp;needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:ga8b0092a333e84d0c4eaae50955bc5a71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="#ga8b0092a333e84d0c4eaae50955bc5a71">More...</a><br/></td></tr>
<tr class="separator:ga8b0092a333e84d0c4eaae50955bc5a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6b1e9aa3d513c96cd5973e50551d6b5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#gab6b1e9aa3d513c96cd5973e50551d6b5">replace_first</a> (const std::string &amp;str, const std::string &amp;needle, const char *instead)</td></tr>
<tr class="memdesc:gab6b1e9aa3d513c96cd5973e50551d6b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="#gab6b1e9aa3d513c96cd5973e50551d6b5">More...</a><br/></td></tr>
<tr class="separator:gab6b1e9aa3d513c96cd5973e50551d6b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7e6db7b1dfe54efc4b195f27df5ed71"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#gae7e6db7b1dfe54efc4b195f27df5ed71">replace_first</a> (const std::string &amp;str, const char *needle, const std::string &amp;instead)</td></tr>
<tr class="memdesc:gae7e6db7b1dfe54efc4b195f27df5ed71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="#gae7e6db7b1dfe54efc4b195f27df5ed71">More...</a><br/></td></tr>
<tr class="separator:gae7e6db7b1dfe54efc4b195f27df5ed71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga711f2f36ac6d9cb35a6a63672e47a47c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga711f2f36ac6d9cb35a6a63672e47a47c">replace_first</a> (const std::string &amp;str, const char *needle, const char *instead)</td></tr>
<tr class="memdesc:ga711f2f36ac6d9cb35a6a63672e47a47c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="#ga711f2f36ac6d9cb35a6a63672e47a47c">More...</a><br/></td></tr>
<tr class="separator:ga711f2f36ac6d9cb35a6a63672e47a47c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga276e1110c0ea48a01ef5a84f8ff40f37"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga276e1110c0ea48a01ef5a84f8ff40f37">replace_first</a> (const std::string &amp;str, char needle, char instead)</td></tr>
<tr class="memdesc:ga276e1110c0ea48a01ef5a84f8ff40f37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace only the first occurrence of needle in str.  <a href="#ga276e1110c0ea48a01ef5a84f8ff40f37">More...</a><br/></td></tr>
<tr class="separator:ga276e1110c0ea48a01ef5a84f8ff40f37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4fb56b145f00428be03f74257c61f1cc"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga4fb56b145f00428be03f74257c61f1cc">split</a> (char sep, const std::string &amp;str, std::string::size_type limit=std::string::npos)</td></tr>
<tr class="memdesc:ga4fb56b145f00428be03f74257c61f1cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator character into distinct substrings.  <a href="#ga4fb56b145f00428be03f74257c61f1cc">More...</a><br/></td></tr>
<tr class="separator:ga4fb56b145f00428be03f74257c61f1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad838882b8fc992742b09450925758b32"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#gad838882b8fc992742b09450925758b32">split</a> (const char *sep, const std::string &amp;str, std::string::size_type limit=std::string::npos)</td></tr>
<tr class="memdesc:gad838882b8fc992742b09450925758b32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator string into distinct substrings.  <a href="#gad838882b8fc992742b09450925758b32">More...</a><br/></td></tr>
<tr class="separator:gad838882b8fc992742b09450925758b32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d57e8e6ac19e94787bf3cd44a79c1fe"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga0d57e8e6ac19e94787bf3cd44a79c1fe">split</a> (const std::string &amp;sep, const std::string &amp;str, std::string::size_type limit=std::string::npos)</td></tr>
<tr class="memdesc:ga0d57e8e6ac19e94787bf3cd44a79c1fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator string into distinct substrings.  <a href="#ga0d57e8e6ac19e94787bf3cd44a79c1fe">More...</a><br/></td></tr>
<tr class="separator:ga0d57e8e6ac19e94787bf3cd44a79c1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00c921a6a793d9c4e59e380b2bb32fca"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga00c921a6a793d9c4e59e380b2bb32fca">split</a> (char sep, const std::string &amp;str, std::string::size_type min_fields, std::string::size_type limit)</td></tr>
<tr class="memdesc:ga00c921a6a793d9c4e59e380b2bb32fca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator character into distinct substrings.  <a href="#ga00c921a6a793d9c4e59e380b2bb32fca">More...</a><br/></td></tr>
<tr class="separator:ga00c921a6a793d9c4e59e380b2bb32fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5fb737c26e5fa4d63467b0ded2a1b90"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#gac5fb737c26e5fa4d63467b0ded2a1b90">split</a> (const char *sep, const std::string &amp;str, std::string::size_type min_fields, std::string::size_type limit)</td></tr>
<tr class="memdesc:gac5fb737c26e5fa4d63467b0ded2a1b90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator string into distinct substrings.  <a href="#gac5fb737c26e5fa4d63467b0ded2a1b90">More...</a><br/></td></tr>
<tr class="separator:gac5fb737c26e5fa4d63467b0ded2a1b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a0a5d581ecd362eaae43bdee50b3896"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga7a0a5d581ecd362eaae43bdee50b3896">split</a> (const std::string &amp;sep, const std::string &amp;str, std::string::size_type min_fields, std::string::size_type limit)</td></tr>
<tr class="memdesc:ga7a0a5d581ecd362eaae43bdee50b3896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator string into distinct substrings.  <a href="#ga7a0a5d581ecd362eaae43bdee50b3896">More...</a><br/></td></tr>
<tr class="separator:ga7a0a5d581ecd362eaae43bdee50b3896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17fd4a3698ca54702b30dddc232bf903"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga17fd4a3698ca54702b30dddc232bf903">split</a> (std::vector&lt; std::string &gt; *into, char sep, const std::string &amp;str, std::string::size_type limit=std::string::npos)</td></tr>
<tr class="memdesc:ga17fd4a3698ca54702b30dddc232bf903"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator character into distinct substrings.  <a href="#ga17fd4a3698ca54702b30dddc232bf903">More...</a><br/></td></tr>
<tr class="separator:ga17fd4a3698ca54702b30dddc232bf903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga177a8fd78d5cc4e0fd8dc50810967d89"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga177a8fd78d5cc4e0fd8dc50810967d89">split</a> (std::vector&lt; std::string &gt; *into, const char *sep, const std::string &amp;str, std::string::size_type limit=std::string::npos)</td></tr>
<tr class="memdesc:ga177a8fd78d5cc4e0fd8dc50810967d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator string into distinct substrings.  <a href="#ga177a8fd78d5cc4e0fd8dc50810967d89">More...</a><br/></td></tr>
<tr class="separator:ga177a8fd78d5cc4e0fd8dc50810967d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga431c048d40a30f531e2e419e26582e4c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga431c048d40a30f531e2e419e26582e4c">split</a> (std::vector&lt; std::string &gt; *into, const std::string &amp;sep, const std::string &amp;str, std::string::size_type limit=std::string::npos)</td></tr>
<tr class="memdesc:ga431c048d40a30f531e2e419e26582e4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator string into distinct substrings.  <a href="#ga431c048d40a30f531e2e419e26582e4c">More...</a><br/></td></tr>
<tr class="separator:ga431c048d40a30f531e2e419e26582e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4997fcbeb1c6a97d23bce8ea590b3ce3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga4997fcbeb1c6a97d23bce8ea590b3ce3">split</a> (std::vector&lt; std::string &gt; *into, char sep, const std::string &amp;str, std::string::size_type min_fields, std::string::size_type limit)</td></tr>
<tr class="memdesc:ga4997fcbeb1c6a97d23bce8ea590b3ce3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator character into distinct substrings.  <a href="#ga4997fcbeb1c6a97d23bce8ea590b3ce3">More...</a><br/></td></tr>
<tr class="separator:ga4997fcbeb1c6a97d23bce8ea590b3ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga40222e4ae7f552a3d6f8d485ced3d91d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga40222e4ae7f552a3d6f8d485ced3d91d">split</a> (std::vector&lt; std::string &gt; *into, const char *sep, const std::string &amp;str, std::string::size_type min_fields, std::string::size_type limit)</td></tr>
<tr class="memdesc:ga40222e4ae7f552a3d6f8d485ced3d91d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator string into distinct substrings.  <a href="#ga40222e4ae7f552a3d6f8d485ced3d91d">More...</a><br/></td></tr>
<tr class="separator:ga40222e4ae7f552a3d6f8d485ced3d91d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4aa7e0fb9bd81e31214087d3d85367a3"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga4aa7e0fb9bd81e31214087d3d85367a3">split</a> (std::vector&lt; std::string &gt; *into, const std::string &amp;sep, const std::string &amp;str, std::string::size_type min_fields, std::string::size_type limit)</td></tr>
<tr class="memdesc:ga4aa7e0fb9bd81e31214087d3d85367a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string at each separator string into distinct substrings.  <a href="#ga4aa7e0fb9bd81e31214087d3d85367a3">More...</a><br/></td></tr>
<tr class="separator:ga4aa7e0fb9bd81e31214087d3d85367a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92d58b1e8b06cbb57400b5959281a4a1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga92d58b1e8b06cbb57400b5959281a4a1">split_words</a> (const std::string &amp;str, std::string::size_type limit=std::string::npos)</td></tr>
<tr class="memdesc:ga92d58b1e8b06cbb57400b5959281a4a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split the given string by whitespaces into distinct words.  <a href="#ga92d58b1e8b06cbb57400b5959281a4a1">More...</a><br/></td></tr>
<tr class="separator:ga92d58b1e8b06cbb57400b5959281a4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc5cce7e8c7fd30078b9129a7ae1d74b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#gadc5cce7e8c7fd30078b9129a7ae1d74b">starts_with</a> (const std::string &amp;str, const std::string &amp;match)</td></tr>
<tr class="memdesc:gadc5cce7e8c7fd30078b9129a7ae1d74b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the start of this string.  <a href="#gadc5cce7e8c7fd30078b9129a7ae1d74b">More...</a><br/></td></tr>
<tr class="separator:gadc5cce7e8c7fd30078b9129a7ae1d74b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga125efbe989d08402389613766af825b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga125efbe989d08402389613766af825b5">starts_with</a> (const std::string &amp;str, const char *match)</td></tr>
<tr class="memdesc:ga125efbe989d08402389613766af825b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the start of this string.  <a href="#ga125efbe989d08402389613766af825b5">More...</a><br/></td></tr>
<tr class="separator:ga125efbe989d08402389613766af825b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbcdc1f2a056e954b197ce9c1d236522"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#gadbcdc1f2a056e954b197ce9c1d236522">starts_with_icase</a> (const std::string &amp;str, const std::string &amp;match)</td></tr>
<tr class="memdesc:gadbcdc1f2a056e954b197ce9c1d236522"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the start of this string.  <a href="#gadbcdc1f2a056e954b197ce9c1d236522">More...</a><br/></td></tr>
<tr class="separator:gadbcdc1f2a056e954b197ce9c1d236522"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6d169441d65d96bceb7c936e88afc67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#gab6d169441d65d96bceb7c936e88afc67">starts_with_icase</a> (const std::string &amp;str, const char *match)</td></tr>
<tr class="memdesc:gab6d169441d65d96bceb7c936e88afc67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the given match string is located at the start of this string.  <a href="#gab6d169441d65d96bceb7c936e88afc67">More...</a><br/></td></tr>
<tr class="separator:gab6d169441d65d96bceb7c936e88afc67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga355a332620f8220ecbb0dc5a0aa67350"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga355a332620f8220ecbb0dc5a0aa67350">to_lower</a> (char ch)</td></tr>
<tr class="memdesc:ga355a332620f8220ecbb0dc5a0aa67350"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform the given character to lower case without any localization.  <a href="#ga355a332620f8220ecbb0dc5a0aa67350">More...</a><br/></td></tr>
<tr class="separator:ga355a332620f8220ecbb0dc5a0aa67350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4ec240b74b77e3ce42f8d67079dea430"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga4ec240b74b77e3ce42f8d67079dea430">to_lower</a> (std::string *str)</td></tr>
<tr class="memdesc:ga4ec240b74b77e3ce42f8d67079dea430"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the given string to lowercase and returns a reference to it.  <a href="#ga4ec240b74b77e3ce42f8d67079dea430">More...</a><br/></td></tr>
<tr class="separator:ga4ec240b74b77e3ce42f8d67079dea430"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga647f5157d00473cf9bf37c92044bd9a8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga647f5157d00473cf9bf37c92044bd9a8">to_lower</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga647f5157d00473cf9bf37c92044bd9a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the given string converted to lowercase.  <a href="#ga647f5157d00473cf9bf37c92044bd9a8">More...</a><br/></td></tr>
<tr class="separator:ga647f5157d00473cf9bf37c92044bd9a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa00b5d705507da8f74f1ba3874174d8d"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#gaa00b5d705507da8f74f1ba3874174d8d">to_upper</a> (char ch)</td></tr>
<tr class="memdesc:gaa00b5d705507da8f74f1ba3874174d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform the given character to upper case without any localization.  <a href="#gaa00b5d705507da8f74f1ba3874174d8d">More...</a><br/></td></tr>
<tr class="separator:gaa00b5d705507da8f74f1ba3874174d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d9edcc3303203825126d7d422e8ab75"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga7d9edcc3303203825126d7d422e8ab75">to_upper</a> (std::string *str)</td></tr>
<tr class="memdesc:ga7d9edcc3303203825126d7d422e8ab75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the given string to uppercase and returns a reference to it.  <a href="#ga7d9edcc3303203825126d7d422e8ab75">More...</a><br/></td></tr>
<tr class="separator:ga7d9edcc3303203825126d7d422e8ab75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2be559f6e498862bec070f122feb6e14"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga2be559f6e498862bec070f122feb6e14">to_upper</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga2be559f6e498862bec070f122feb6e14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of the given string converted to uppercase.  <a href="#ga2be559f6e498862bec070f122feb6e14">More...</a><br/></td></tr>
<tr class="separator:ga2be559f6e498862bec070f122feb6e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef21c8a44ad85b60cee80e66ae877b9a"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#gaef21c8a44ad85b60cee80e66ae877b9a">trim</a> (std::string *str, const char *drop=&quot; \r\n\t&quot;)</td></tr>
<tr class="memdesc:gaef21c8a44ad85b60cee80e66ae877b9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place on the left and right.  <a href="#gaef21c8a44ad85b60cee80e66ae877b9a">More...</a><br/></td></tr>
<tr class="separator:gaef21c8a44ad85b60cee80e66ae877b9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f5067eb83515704232300be374b2857"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga9f5067eb83515704232300be374b2857">trim</a> (std::string *str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:ga9f5067eb83515704232300be374b2857"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place on the left and right.  <a href="#ga9f5067eb83515704232300be374b2857">More...</a><br/></td></tr>
<tr class="separator:ga9f5067eb83515704232300be374b2857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6b44c87fe78e1d7479b7a4fff91cc2e"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#gac6b44c87fe78e1d7479b7a4fff91cc2e">trim</a> (const std::string &amp;str, const char *drop=&quot; \r\n\t&quot;)</td></tr>
<tr class="memdesc:gac6b44c87fe78e1d7479b7a4fff91cc2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place on the left and right.  <a href="#gac6b44c87fe78e1d7479b7a4fff91cc2e">More...</a><br/></td></tr>
<tr class="separator:gac6b44c87fe78e1d7479b7a4fff91cc2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7aacbd967bfb76fcb4b4d977b4f5d838"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga7aacbd967bfb76fcb4b4d977b4f5d838">trim</a> (const std::string &amp;str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:ga7aacbd967bfb76fcb4b4d977b4f5d838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place on the left and right.  <a href="#ga7aacbd967bfb76fcb4b4d977b4f5d838">More...</a><br/></td></tr>
<tr class="separator:ga7aacbd967bfb76fcb4b4d977b4f5d838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9990f13215dc89af47b26ed8f2d26c9e"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga9990f13215dc89af47b26ed8f2d26c9e">trim_left</a> (std::string *str, const char *drop=&quot; \r\n\t&quot;)</td></tr>
<tr class="memdesc:ga9990f13215dc89af47b26ed8f2d26c9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place only on the left.  <a href="#ga9990f13215dc89af47b26ed8f2d26c9e">More...</a><br/></td></tr>
<tr class="separator:ga9990f13215dc89af47b26ed8f2d26c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9db0b1db4ab3774221363c2fafa8bbdf"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga9db0b1db4ab3774221363c2fafa8bbdf">trim_left</a> (std::string *str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:ga9db0b1db4ab3774221363c2fafa8bbdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place only on the left.  <a href="#ga9db0b1db4ab3774221363c2fafa8bbdf">More...</a><br/></td></tr>
<tr class="separator:ga9db0b1db4ab3774221363c2fafa8bbdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafaed624d011733264819eb39daae7d64"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#gafaed624d011733264819eb39daae7d64">trim_left</a> (const std::string &amp;str, const char *drop=&quot; \r\n\t&quot;)</td></tr>
<tr class="memdesc:gafaed624d011733264819eb39daae7d64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string only on the left.  <a href="#gafaed624d011733264819eb39daae7d64">More...</a><br/></td></tr>
<tr class="separator:gafaed624d011733264819eb39daae7d64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f870dbf0b1602d063de42caefde8b68"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga9f870dbf0b1602d063de42caefde8b68">trim_left</a> (const std::string &amp;str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:ga9f870dbf0b1602d063de42caefde8b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string only on the left.  <a href="#ga9f870dbf0b1602d063de42caefde8b68">More...</a><br/></td></tr>
<tr class="separator:ga9f870dbf0b1602d063de42caefde8b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae59121dc9b7582edd903016d412bdb4b"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#gae59121dc9b7582edd903016d412bdb4b">trim_right</a> (std::string *str, const char *drop=&quot; \r\n\t&quot;)</td></tr>
<tr class="memdesc:gae59121dc9b7582edd903016d412bdb4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place only on the right.  <a href="#gae59121dc9b7582edd903016d412bdb4b">More...</a><br/></td></tr>
<tr class="separator:gae59121dc9b7582edd903016d412bdb4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff5e9a8a1501b420ae5a5f8eca2a2f01"><td class="memItemLeft" align="right" valign="top">std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#gaff5e9a8a1501b420ae5a5f8eca2a2f01">trim_right</a> (std::string *str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:gaff5e9a8a1501b420ae5a5f8eca2a2f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string in-place only on the right.  <a href="#gaff5e9a8a1501b420ae5a5f8eca2a2f01">More...</a><br/></td></tr>
<tr class="separator:gaff5e9a8a1501b420ae5a5f8eca2a2f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75e734df783f6b4f70f75a8031d930aa"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga75e734df783f6b4f70f75a8031d930aa">trim_right</a> (const std::string &amp;str, const char *drop=&quot; \r\n\t&quot;)</td></tr>
<tr class="memdesc:ga75e734df783f6b4f70f75a8031d930aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string only on the right.  <a href="#ga75e734df783f6b4f70f75a8031d930aa">More...</a><br/></td></tr>
<tr class="separator:ga75e734df783f6b4f70f75a8031d930aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b761b3a20c3f400f4f3451511016a07"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga4b761b3a20c3f400f4f3451511016a07">trim_right</a> (const std::string &amp;str, const std::string &amp;drop)</td></tr>
<tr class="memdesc:ga4b761b3a20c3f400f4f3451511016a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Trims the given string only on the right.  <a href="#ga4b761b3a20c3f400f4f3451511016a07">More...</a><br/></td></tr>
<tr class="separator:ga4b761b3a20c3f400f4f3451511016a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga39619db78c7e916bff3544fb07cbe462"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga39619db78c7e916bff3544fb07cbe462">union_words</a> (const std::string &amp;wordsA, const std::string &amp;wordsB)</td></tr>
<tr class="memdesc:ga39619db78c7e916bff3544fb07cbe462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return union of two keyword sets.  <a href="#ga39619db78c7e916bff3544fb07cbe462">More...</a><br/></td></tr>
<tr class="separator:ga39619db78c7e916bff3544fb07cbe462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2d0ada76ddce7fc09d770fa512780839"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga2d0ada76ddce7fc09d770fa512780839">word_wrap</a> (const std::string &amp;str, unsigned int wrap=80)</td></tr>
<tr class="memdesc:ga2d0ada76ddce7fc09d770fa512780839"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to wrap a string to 80 columns without split words.  <a href="#ga2d0ada76ddce7fc09d770fa512780839">More...</a><br/></td></tr>
<tr class="separator:ga2d0ada76ddce7fc09d770fa512780839"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Base64 Encoding and Decoding</h2></td></tr>
<tr class="memitem:ga691477f59c8496eec65e994ce3f6e6e5"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga691477f59c8496eec65e994ce3f6e6e5">base64_encode</a> (const void *data, size_t size, size_t line_break=0)</td></tr>
<tr class="memdesc:ga691477f59c8496eec65e994ce3f6e6e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode the given binary data into base64 representation as described in RFC 2045 or RFC 3548.  <a href="#ga691477f59c8496eec65e994ce3f6e6e5">More...</a><br/></td></tr>
<tr class="separator:ga691477f59c8496eec65e994ce3f6e6e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga16a12f591febaeddffd2ffca031c8bf4"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga16a12f591febaeddffd2ffca031c8bf4">base64_encode</a> (const std::string &amp;str, size_t line_break=0)</td></tr>
<tr class="memdesc:ga16a12f591febaeddffd2ffca031c8bf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode the given binary string into base64 representation as described in RFC 2045 or RFC 3548.  <a href="#ga16a12f591febaeddffd2ffca031c8bf4">More...</a><br/></td></tr>
<tr class="separator:ga16a12f591febaeddffd2ffca031c8bf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2775fbea220f27325aba0f8af1cc9a8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#gac2775fbea220f27325aba0f8af1cc9a8">base64_decode</a> (const void *data, size_t size, bool strict=true)</td></tr>
<tr class="memdesc:gac2775fbea220f27325aba0f8af1cc9a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a string in base64 representation as described in RFC 2045 or RFC 3548 and return the original data.  <a href="#gac2775fbea220f27325aba0f8af1cc9a8">More...</a><br/></td></tr>
<tr class="separator:gac2775fbea220f27325aba0f8af1cc9a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe1e973cd3a2d5b7e55544d4c616da49"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#gabe1e973cd3a2d5b7e55544d4c616da49">base64_decode</a> (const std::string &amp;str, bool strict=true)</td></tr>
<tr class="memdesc:gabe1e973cd3a2d5b7e55544d4c616da49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decode a string in base64 representation as described in RFC 2045 or RFC 3548 and return the original data.  <a href="#gabe1e973cd3a2d5b7e55544d4c616da49">More...</a><br/></td></tr>
<tr class="separator:gabe1e973cd3a2d5b7e55544d4c616da49"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Hexdump Methods</h2></td></tr>
<tr class="memitem:gab4c0ada9ff7b0d905361e60050316899"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#gab4c0ada9ff7b0d905361e60050316899">hexdump</a> (const void *const data, size_t size)</td></tr>
<tr class="memdesc:gab4c0ada9ff7b0d905361e60050316899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) string as a sequence of uppercase hexadecimal pairs.  <a href="#gab4c0ada9ff7b0d905361e60050316899">More...</a><br/></td></tr>
<tr class="separator:gab4c0ada9ff7b0d905361e60050316899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0757bf9871dc4e2526ab48e4cde28e1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#gaa0757bf9871dc4e2526ab48e4cde28e1">hexdump</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:gaa0757bf9871dc4e2526ab48e4cde28e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) string as a sequence of uppercase hexadecimal pairs.  <a href="#gaa0757bf9871dc4e2526ab48e4cde28e1">More...</a><br/></td></tr>
<tr class="separator:gaa0757bf9871dc4e2526ab48e4cde28e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2a485134f5e618b846abb630d44ec6f"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:gae2a485134f5e618b846abb630d44ec6f"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__string.html#gae2a485134f5e618b846abb630d44ec6f">hexdump_type</a> (const Type &amp;t)</td></tr>
<tr class="memdesc:gae2a485134f5e618b846abb630d44ec6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) item as a sequence of uppercase hexadecimal pairs.  <a href="#gae2a485134f5e618b846abb630d44ec6f">More...</a><br/></td></tr>
<tr class="separator:gae2a485134f5e618b846abb630d44ec6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15c83e3e2055412b0440758c98b3f148"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga15c83e3e2055412b0440758c98b3f148">hexdump</a> (const std::vector&lt; char &gt; &amp;data)</td></tr>
<tr class="memdesc:ga15c83e3e2055412b0440758c98b3f148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a char vector as a sequence of uppercase hexadecimal pairs.  <a href="#ga15c83e3e2055412b0440758c98b3f148">More...</a><br/></td></tr>
<tr class="separator:ga15c83e3e2055412b0440758c98b3f148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c6446ce9a61a434b3a10345cbf3ebed"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga6c6446ce9a61a434b3a10345cbf3ebed">hexdump</a> (const std::vector&lt; uint8_t &gt; &amp;data)</td></tr>
<tr class="memdesc:ga6c6446ce9a61a434b3a10345cbf3ebed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a uint8_t vector as a sequence of uppercase hexadecimal pairs.  <a href="#ga6c6446ce9a61a434b3a10345cbf3ebed">More...</a><br/></td></tr>
<tr class="separator:ga6c6446ce9a61a434b3a10345cbf3ebed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab10f91fa3b24c787e4e0d88c009ac298"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#gab10f91fa3b24c787e4e0d88c009ac298">hexdump_sourcecode</a> (const std::string &amp;str, const std::string &amp;var_name=&quot;name&quot;)</td></tr>
<tr class="memdesc:gab10f91fa3b24c787e4e0d88c009ac298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) string into a C source code snippet.  <a href="#gab10f91fa3b24c787e4e0d88c009ac298">More...</a><br/></td></tr>
<tr class="separator:gab10f91fa3b24c787e4e0d88c009ac298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0c47a216e0abcdf9a88fc50bb79c98ba"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga0c47a216e0abcdf9a88fc50bb79c98ba">hexdump_lc</a> (const void *const data, size_t size)</td></tr>
<tr class="memdesc:ga0c47a216e0abcdf9a88fc50bb79c98ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) string as a sequence of lowercase hexadecimal pairs.  <a href="#ga0c47a216e0abcdf9a88fc50bb79c98ba">More...</a><br/></td></tr>
<tr class="separator:ga0c47a216e0abcdf9a88fc50bb79c98ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga60e8912db4511738cfdbf3e97ff6dbbf"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga60e8912db4511738cfdbf3e97ff6dbbf">hexdump_lc</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga60e8912db4511738cfdbf3e97ff6dbbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) string as a sequence of lowercase hexadecimal pairs.  <a href="#ga60e8912db4511738cfdbf3e97ff6dbbf">More...</a><br/></td></tr>
<tr class="separator:ga60e8912db4511738cfdbf3e97ff6dbbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b2f444830d8f7b1b0eaf93b5f514bf7"><td class="memTemplParams" colspan="2">template&lt;typename Type &gt; </td></tr>
<tr class="memitem:ga0b2f444830d8f7b1b0eaf93b5f514bf7"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__string.html#ga0b2f444830d8f7b1b0eaf93b5f514bf7">hexdump_lc_type</a> (const Type &amp;t)</td></tr>
<tr class="memdesc:ga0b2f444830d8f7b1b0eaf93b5f514bf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a (binary) item as a sequence of lowercase hexadecimal pairs.  <a href="#ga0b2f444830d8f7b1b0eaf93b5f514bf7">More...</a><br/></td></tr>
<tr class="separator:ga0b2f444830d8f7b1b0eaf93b5f514bf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae749cedcfc25af4f829d70e8febba7a1"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#gae749cedcfc25af4f829d70e8febba7a1">hexdump_lc</a> (const std::vector&lt; char &gt; &amp;data)</td></tr>
<tr class="memdesc:gae749cedcfc25af4f829d70e8febba7a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a char vector as a sequence of lowercase hexadecimal pairs.  <a href="#gae749cedcfc25af4f829d70e8febba7a1">More...</a><br/></td></tr>
<tr class="separator:gae749cedcfc25af4f829d70e8febba7a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b35bd68e5974e78327fce13e0e2eaf6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga0b35bd68e5974e78327fce13e0e2eaf6">hexdump_lc</a> (const std::vector&lt; uint8_t &gt; &amp;data)</td></tr>
<tr class="memdesc:ga0b35bd68e5974e78327fce13e0e2eaf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump a uint8_t vector as a sequence of lowercase hexadecimal pairs.  <a href="#ga0b35bd68e5974e78327fce13e0e2eaf6">More...</a><br/></td></tr>
<tr class="separator:ga0b35bd68e5974e78327fce13e0e2eaf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81809bc5e0b69034f39659303baa4bf9"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__string.html#ga81809bc5e0b69034f39659303baa4bf9">parse_hexdump</a> (const std::string &amp;str)</td></tr>
<tr class="memdesc:ga81809bc5e0b69034f39659303baa4bf9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a string as a sequence of hexadecimal pairs.  <a href="#ga81809bc5e0b69034f39659303baa4bf9">More...</a><br/></td></tr>
<tr class="separator:ga81809bc5e0b69034f39659303baa4bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>simple string manipulations </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="gac2775fbea220f27325aba0f8af1cc9a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string base64_decode </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a string in base64 representation as described in RFC 2045 or RFC 3548 and return the original data. </p>
<p>If a non-whitespace invalid base64 character is encountered <em>and</em> the parameter "strict" is true, then this function will throw a std::runtime_error. If "strict" is false, the character is silently ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>input data to decode </td></tr>
    <tr><td class="paramname">size</td><td>size of input data to decode </td></tr>
    <tr><td class="paramname">strict</td><td>throw exception on invalid character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>decoded binary data </dd></dl>

<p>Definition at line <a class="el" href="base64_8cpp_source.html#l00108">108</a> of file <a class="el" href="base64_8cpp_source.html">base64.cpp</a>.</p>

<p>Referenced by <a class="el" href="base64_8cpp_source.html#l00203">tlx::base64_decode()</a>.</p>

</div>
</div>
<a class="anchor" id="gabe1e973cd3a2d5b7e55544d4c616da49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string base64_decode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decode a string in base64 representation as described in RFC 2045 or RFC 3548 and return the original data. </p>
<p>If a non-whitespace invalid base64 character is encountered <em>and</em> the parameter "strict" is true, then this function will throw a std::runtime_error. If "strict" is false, the character is silently ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>input string to encode </td></tr>
    <tr><td class="paramname">strict</td><td>throw exception on invalid character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>decoded binary data </dd></dl>

<p>Definition at line <a class="el" href="base64_8cpp_source.html#l00203">203</a> of file <a class="el" href="base64_8cpp_source.html">base64.cpp</a>.</p>

<p>References <a class="el" href="base64_8cpp_source.html#l00108">tlx::base64_decode()</a>.</p>

</div>
</div>
<a class="anchor" id="ga691477f59c8496eec65e994ce3f6e6e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string base64_encode </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>line_break</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode the given binary data into base64 representation as described in RFC 2045 or RFC 3548. </p>
<p>The output string contains only characters [A-Za-z0-9+/] and is roughly 33% longer than the input. The output string can be broken into lines after n characters, where n must be a multiple of 4.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>input data to encode </td></tr>
    <tr><td class="paramname">size</td><td>size of input data to encode </td></tr>
    <tr><td class="paramname">line_break</td><td>break the output string every n characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>base64 encoded string </dd></dl>

<p>Definition at line <a class="el" href="base64_8cpp_source.html#l00025">25</a> of file <a class="el" href="base64_8cpp_source.html">base64.cpp</a>.</p>

<p>Referenced by <a class="el" href="base64_8cpp_source.html#l00102">tlx::base64_encode()</a>.</p>

</div>
</div>
<a class="anchor" id="ga16a12f591febaeddffd2ffca031c8bf4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string base64_encode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>line_break</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode the given binary string into base64 representation as described in RFC 2045 or RFC 3548. </p>
<p>The output string contains only characters [A-Za-z0-9+/] and is roughly 33% longer than the input. The output string can be broken into lines after n characters, where n must be a multiple of 4.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>input string to encode </td></tr>
    <tr><td class="paramname">line_break</td><td>break the output string every n characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>base64 encoded string </dd></dl>

<p>Definition at line <a class="el" href="base64_8cpp_source.html#l00102">102</a> of file <a class="el" href="base64_8cpp_source.html">base64.cpp</a>.</p>

<p>References <a class="el" href="base64_8cpp_source.html#l00025">tlx::base64_encode()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7a87b7f6120ebcde0c01ad293465f9d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int compare_icase </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns +1/0/-1 like strcmp(a, b) but without regard for letter case </p>

<p>Definition at line <a class="el" href="compare__icase_8cpp_source.html#l00018">18</a> of file <a class="el" href="compare__icase_8cpp_source.html">compare_icase.cpp</a>.</p>

<p>References <a class="el" href="to__lower_8cpp_source.html#l00017">tlx::to_lower()</a>.</p>

</div>
</div>
<a class="anchor" id="ga061e7b66eb332d7621ef99d11b724c16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int compare_icase </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns +1/0/-1 like strcmp(a, b) but without regard for letter case </p>

<p>Definition at line <a class="el" href="compare__icase_8cpp_source.html#l00035">35</a> of file <a class="el" href="compare__icase_8cpp_source.html">compare_icase.cpp</a>.</p>

<p>References <a class="el" href="to__lower_8cpp_source.html#l00017">tlx::to_lower()</a>.</p>

</div>
</div>
<a class="anchor" id="gad6b99f43a01b6d2ff8ca49f4518297b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int compare_icase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns +1/0/-1 like strcmp(a, b) but without regard for letter case </p>

<p>Definition at line <a class="el" href="compare__icase_8cpp_source.html#l00054">54</a> of file <a class="el" href="compare__icase_8cpp_source.html">compare_icase.cpp</a>.</p>

<p>References <a class="el" href="to__lower_8cpp_source.html#l00017">tlx::to_lower()</a>.</p>

</div>
</div>
<a class="anchor" id="ga988bb20efc727413da0a9d9d11f488b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int compare_icase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns +1/0/-1 like strcmp(a, b) but without regard for letter case </p>

<p>Definition at line <a class="el" href="compare__icase_8cpp_source.html#l00072">72</a> of file <a class="el" href="compare__icase_8cpp_source.html">compare_icase.cpp</a>.</p>

<p>References <a class="el" href="to__lower_8cpp_source.html#l00017">tlx::to_lower()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7ff92619b9a2ae3dbbdd6ef511c1779e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool contains </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests of string contains pattern. </p>

<p>Definition at line <a class="el" href="contains_8cpp_source.html#l00015">15</a> of file <a class="el" href="contains_8cpp_source.html">contains.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga399719274798a8a808e8e309ab490f03"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool contains </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests of string contains pattern. </p>

<p>Definition at line <a class="el" href="contains_8cpp_source.html#l00019">19</a> of file <a class="el" href="contains_8cpp_source.html">contains.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga8d6aca56ee9463cd116fc8e065c4c3a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool contains </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>ch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests of string contains character. </p>

<p>Definition at line <a class="el" href="contains_8cpp_source.html#l00023">23</a> of file <a class="el" href="contains_8cpp_source.html">contains.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga2fd07edea7502e13dbc9d2991be95f02"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool contains_word </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>word</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search the given string for a whitespace-delimited word. </p>
<p>It works as if the str was <a class="el" href="group__string.html#ga92d58b1e8b06cbb57400b5959281a4a1" title="Split the given string by whitespaces into distinct words. ">split_words()</a> and the resulting vector checked for a given word. However this function does not create a vector, it scans the string directly. Whitespace is space, tab, newline or carriage-return.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>whitespace-delimited string to check </td></tr>
    <tr><td class="paramname">word</td><td>word to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the word was found </dd></dl>

<p>Definition at line <a class="el" href="contains__word_8cpp_source.html#l00019">19</a> of file <a class="el" href="contains__word_8cpp_source.html">contains_word.cpp</a>.</p>

<p>References <a class="el" href="contains__word_8cpp_source.html#l00015">tlx::is_white()</a>.</p>

<p>Referenced by <a class="el" href="union__words_8cpp_source.html#l00016">tlx::union_words()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7f7b2444597941650e05c1bb96b04f45"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool contains_word </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>word</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search the given string for a whitespace-delimited word. </p>
<p>It works as if the str was <a class="el" href="group__string.html#ga92d58b1e8b06cbb57400b5959281a4a1" title="Split the given string by whitespaces into distinct words. ">split_words()</a> and the resulting vector checked for a given word. However this function does not create a vector, it scans the string directly. Whitespace is space, tab, newline or carriage-return.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>whitespace-delimited string to check </td></tr>
    <tr><td class="paramname">word</td><td>word to find </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the word was found </dd></dl>

<p>Definition at line <a class="el" href="contains__word_8cpp_source.html#l00055">55</a> of file <a class="el" href="contains__word_8cpp_source.html">contains_word.cpp</a>.</p>

<p>References <a class="el" href="contains__word_8cpp_source.html#l00015">tlx::is_white()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6eadd6e031f051ff44c5ab2935cdddfd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ends_with </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given match string is located at the end of this string. </p>

<p>Definition at line <a class="el" href="ends__with_8cpp_source.html#l00020">20</a> of file <a class="el" href="ends__with_8cpp_source.html">ends_with.cpp</a>.</p>

<p>Referenced by <a class="el" href="file__io_8cpp_source.html#l00046">thrill::vfs::IsCompressed()</a>, <a class="el" href="file__io_8cpp_source.html#l00179">thrill::vfs::OpenReadStream()</a>, <a class="el" href="file__io_8cpp_source.html#l00210">thrill::vfs::OpenWriteStream()</a>, <a class="el" href="sys__file_8cpp_source.html#l00230">thrill::vfs::SysOpenReadStream()</a>, and <a class="el" href="sys__file_8cpp_source.html#l00321">thrill::vfs::SysOpenWriteStream()</a>.</p>

</div>
</div>
<a class="anchor" id="gacea7b710bca17bae104e7e5eb6137fcf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ends_with </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given match string is located at the end of this string. </p>

<p>Definition at line <a class="el" href="ends__with_8cpp_source.html#l00027">27</a> of file <a class="el" href="ends__with_8cpp_source.html">ends_with.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga849ffa2f657372a30b5cfc53fe1267a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ends_with_icase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given match string is located at the end of this string. </p>
<p>Compares the characters case-insensitively. </p>

<p>Definition at line <a class="el" href="ends__with_8cpp_source.html#l00044">44</a> of file <a class="el" href="ends__with_8cpp_source.html">ends_with.cpp</a>.</p>

<p>References <a class="el" href="to__lower_8cpp_source.html#l00017">tlx::to_lower()</a>.</p>

</div>
</div>
<a class="anchor" id="gac7e29572ead3f33c45cd95c8d4b720d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ends_with_icase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given match string is located at the end of this string. </p>
<p>Compares the characters case-insensitively. </p>

<p>Definition at line <a class="el" href="ends__with_8cpp_source.html#l00054">54</a> of file <a class="el" href="ends__with_8cpp_source.html">ends_with.cpp</a>.</p>

<p>References <a class="el" href="to__lower_8cpp_source.html#l00017">tlx::to_lower()</a>.</p>

</div>
</div>
<a class="anchor" id="ga42a4d6e9f12943be811bcb6666d53493"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool equal_icase </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if a == b without regard for letter case </p>

<p>Definition at line <a class="el" href="equal__icase_8cpp_source.html#l00018">18</a> of file <a class="el" href="equal__icase_8cpp_source.html">equal_icase.cpp</a>.</p>

<p>References <a class="el" href="to__lower_8cpp_source.html#l00017">tlx::to_lower()</a>.</p>

<p>Referenced by <a class="el" href="index__of_8cpp_source.html#l00039">tlx::index_of_icase()</a>.</p>

</div>
</div>
<a class="anchor" id="gad15c6b082515414b93a34b7ac0327df9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool equal_icase </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if a == b without regard for letter case </p>

<p>Definition at line <a class="el" href="equal__icase_8cpp_source.html#l00026">26</a> of file <a class="el" href="equal__icase_8cpp_source.html">equal_icase.cpp</a>.</p>

<p>References <a class="el" href="to__lower_8cpp_source.html#l00017">tlx::to_lower()</a>.</p>

</div>
</div>
<a class="anchor" id="ga118abe0d4d0cd1d90426121b626aeea9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool equal_icase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if a == b without regard for letter case </p>

<p>Definition at line <a class="el" href="equal__icase_8cpp_source.html#l00035">35</a> of file <a class="el" href="equal__icase_8cpp_source.html">equal_icase.cpp</a>.</p>

<p>References <a class="el" href="to__lower_8cpp_source.html#l00017">tlx::to_lower()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2c9c153df7b49712108276c9a48fe88e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool equal_icase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if a == b without regard for letter case </p>

<p>Definition at line <a class="el" href="equal__icase_8cpp_source.html#l00044">44</a> of file <a class="el" href="equal__icase_8cpp_source.html">equal_icase.cpp</a>.</p>

<p>References <a class="el" href="to__lower_8cpp_source.html#l00017">tlx::to_lower()</a>.</p>

</div>
</div>
<a class="anchor" id="ga593df4d923a5f07d65ff39950e31e367"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; erase_all </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>drop</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all occurrences of the given character in-place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove this character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p>Definition at line <a class="el" href="erase__all_8cpp_source.html#l00018">18</a> of file <a class="el" href="erase__all_8cpp_source.html">erase_all.cpp</a>.</p>

<p>Referenced by <a class="el" href="erase__all_8cpp_source.html#l00050">tlx::erase_all()</a>.</p>

</div>
</div>
<a class="anchor" id="ga290c6e7261f453c4774a0cf82586bf47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; erase_all </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all occurrences of the given characters in-place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p>Definition at line <a class="el" href="erase__all_8cpp_source.html#l00034">34</a> of file <a class="el" href="erase__all_8cpp_source.html">erase_all.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="gacefd443f50a3e6123651a031eb1701c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; erase_all </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all occurrences of the given characters in-place. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p>Definition at line <a class="el" href="erase__all_8cpp_source.html#l00050">50</a> of file <a class="el" href="erase__all_8cpp_source.html">erase_all.cpp</a>.</p>

<p>References <a class="el" href="erase__all_8cpp_source.html#l00018">tlx::erase_all()</a>.</p>

</div>
</div>
<a class="anchor" id="ga86282247928444ece567ced18f0012b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string erase_all </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>drop</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all occurrences of the given character, return copy of string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove this character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with less characters </dd></dl>

<p>Definition at line <a class="el" href="erase__all_8cpp_source.html#l00057">57</a> of file <a class="el" href="erase__all_8cpp_source.html">erase_all.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga7c0aa5a14584e80887d4afc8c34337f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string erase_all </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all occurrences of the given characters, return copy of string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with less characters </dd></dl>

<p>Definition at line <a class="el" href="erase__all_8cpp_source.html#l00071">71</a> of file <a class="el" href="erase__all_8cpp_source.html">erase_all.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga09e7dd3f20d8e54c8502c81d540f9916"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string erase_all </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all occurrences of the given characters, return copy of string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with less characters </dd></dl>

<p>Definition at line <a class="el" href="erase__all_8cpp_source.html#l00092">92</a> of file <a class="el" href="erase__all_8cpp_source.html">erase_all.cpp</a>.</p>

<p>References <a class="el" href="erase__all_8cpp_source.html#l00018">tlx::erase_all()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa3ec7c7d258293a6891f016878d22f09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string escape_html </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Escape characters for inclusion in HTML documents: replaces the characters &lt;, &gt;, &amp; and " with HTML entities. </p>

<p>Definition at line <a class="el" href="escape__html_8cpp_source.html#l00015">15</a> of file <a class="el" href="escape__html_8cpp_source.html">escape_html.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga6c9dca404398316e3ffb6266d592b38d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string escape_uri </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Escape a string into a URI-encoding. </p>
<p>This maps all non A-Z0-9 characters to HH hex representation. </p>

<p>Definition at line <a class="el" href="escape__uri_8cpp_source.html#l00015">15</a> of file <a class="el" href="escape__uri_8cpp_source.html">escape_uri.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga713c5cd2e2209e379c8b79ba2cd3e398"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string extract_between </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sep1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sep2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search the string for given start and end separators and extract all characters between the both, if they are found. </p>
<p>Otherwise return an empty string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to search in </td></tr>
    <tr><td class="paramname">sep1</td><td>start boundary </td></tr>
    <tr><td class="paramname">sep2</td><td>end boundary </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="extract__between_8cpp_source.html#l00037">37</a> of file <a class="el" href="extract__between_8cpp_source.html">extract_between.cpp</a>.</p>

<p>References <a class="el" href="extract__between_8cpp_source.html#l00019">tlx::extract_between_template()</a>.</p>

</div>
</div>
<a class="anchor" id="gae1ac1e43a5ae269bdbe594c4f4f4a325"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string extract_between </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sep1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sep2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search the string for given start and end separators and extract all characters between the both, if they are found. </p>
<p>Otherwise return an empty string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to search in </td></tr>
    <tr><td class="paramname">sep1</td><td>start boundary </td></tr>
    <tr><td class="paramname">sep2</td><td>end boundary </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="extract__between_8cpp_source.html#l00042">42</a> of file <a class="el" href="extract__between_8cpp_source.html">extract_between.cpp</a>.</p>

<p>References <a class="el" href="extract__between_8cpp_source.html#l00019">tlx::extract_between_template()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf0c6e73d346e3deda660b2eb24b06c67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string extract_between </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sep1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sep2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search the string for given start and end separators and extract all characters between the both, if they are found. </p>
<p>Otherwise return an empty string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to search in </td></tr>
    <tr><td class="paramname">sep1</td><td>start boundary </td></tr>
    <tr><td class="paramname">sep2</td><td>end boundary </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="extract__between_8cpp_source.html#l00047">47</a> of file <a class="el" href="extract__between_8cpp_source.html">extract_between.cpp</a>.</p>

<p>References <a class="el" href="extract__between_8cpp_source.html#l00019">tlx::extract_between_template()</a>.</p>

</div>
</div>
<a class="anchor" id="gab3a44aaf97230d79b6aac046331240d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string extract_between </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sep1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sep2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Search the string for given start and end separators and extract all characters between the both, if they are found. </p>
<p>Otherwise return an empty string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to search in </td></tr>
    <tr><td class="paramname">sep1</td><td>start boundary </td></tr>
    <tr><td class="paramname">sep2</td><td>end boundary </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="extract__between_8cpp_source.html#l00052">52</a> of file <a class="el" href="extract__between_8cpp_source.html">extract_between.cpp</a>.</p>

<p>References <a class="el" href="extract__between_8cpp_source.html#l00019">tlx::extract_between_template()</a>.</p>

</div>
</div>
<a class="anchor" id="ga937bd46650d317c28df7c7723ae84119"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string format_iec_units </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>precision</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format number as something like 1 TiB. </p>
<p>Format a byte size using IEC (Ki, Mi, Gi, Ti) suffixes (powers of two). Returns "123 Ki" or similar. </p>

<p>Definition at line <a class="el" href="format__si__iec__units_8cpp_source.html#l00038">38</a> of file <a class="el" href="format__si__iec__units_8cpp_source.html">format_si_iec_units.cpp</a>.</p>

<p>Referenced by <a class="el" href="context_8cpp_source.html#l01104">Context::Launch()</a>, <a class="el" href="just__sort_8cpp_source.html#l00076">main()</a>, and <a class="el" href="context_8cpp_source.html#l00957">MemoryConfig::print()</a>.</p>

</div>
</div>
<a class="anchor" id="ga084c15f3eff7d1eb6018d00779486013"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string format_si_units </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>precision</em> = <code>3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format number as something like 1 TB. </p>
<p>Format a byte size using SI (K, M, G, T) suffixes (powers of ten). Returns "123 M" or similar. </p>

<p>Definition at line <a class="el" href="format__si__iec__units_8cpp_source.html#l00019">19</a> of file <a class="el" href="format__si__iec__units_8cpp_source.html">format_si_iec_units.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="gab4c0ada9ff7b0d905361e60050316899"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string hexdump </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a (binary) string as a sequence of uppercase hexadecimal pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>binary data to output in hex </td></tr>
    <tr><td class="paramname">size</td><td>length of binary data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hexadecimal pairs </dd></dl>

<p>Definition at line <a class="el" href="hexdump_8cpp_source.html#l00021">21</a> of file <a class="el" href="hexdump_8cpp_source.html">hexdump.cpp</a>.</p>

<p>Referenced by <a class="el" href="stream__sink_8cpp_source.html#l00066">StreamSink::AppendPinnedBlock()</a>, <a class="el" href="hexdump_8cpp_source.html#l00042">tlx::hexdump()</a>, <a class="el" href="hexdump_8hpp_source.html#l00052">tlx::hexdump_type()</a>, <a class="el" href="mock_2group_8cpp_source.html#l00179">Group::MaybeHexdump()</a>, <a class="el" href="socket_8hpp_source.html#l00609">Socket::MaybeHexdump()</a>, <a class="el" href="mix__stream_8cpp_source.html#l00176">MixStream::OnStreamBlock()</a>, and <a class="el" href="cat__stream_8cpp_source.html#l00246">CatStream::OnStreamBlock()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa0757bf9871dc4e2526ab48e4cde28e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string hexdump </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a (binary) string as a sequence of uppercase hexadecimal pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>binary data to output in hex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hexadecimal pairs </dd></dl>

<p>Definition at line <a class="el" href="hexdump_8cpp_source.html#l00042">42</a> of file <a class="el" href="hexdump_8cpp_source.html">hexdump.cpp</a>.</p>

<p>References <a class="el" href="hexdump_8cpp_source.html#l00021">tlx::hexdump()</a>.</p>

</div>
</div>
<a class="anchor" id="ga15c83e3e2055412b0440758c98b3f148"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string hexdump </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a char vector as a sequence of uppercase hexadecimal pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>binary data to output in hex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hexadecimal pairs </dd></dl>

<p>Definition at line <a class="el" href="hexdump_8cpp_source.html#l00046">46</a> of file <a class="el" href="hexdump_8cpp_source.html">hexdump.cpp</a>.</p>

<p>References <a class="el" href="hexdump_8cpp_source.html#l00021">tlx::hexdump()</a>.</p>

</div>
</div>
<a class="anchor" id="ga6c6446ce9a61a434b3a10345cbf3ebed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string hexdump </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a uint8_t vector as a sequence of uppercase hexadecimal pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>binary data to output in hex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hexadecimal pairs </dd></dl>

<p>Definition at line <a class="el" href="hexdump_8cpp_source.html#l00050">50</a> of file <a class="el" href="hexdump_8cpp_source.html">hexdump.cpp</a>.</p>

<p>References <a class="el" href="hexdump_8cpp_source.html#l00021">tlx::hexdump()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0c47a216e0abcdf9a88fc50bb79c98ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string hexdump_lc </td>
          <td>(</td>
          <td class="paramtype">const void *const&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a (binary) string as a sequence of lowercase hexadecimal pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>binary data to output in hex </td></tr>
    <tr><td class="paramname">size</td><td>length of binary data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hexadecimal pairs </dd></dl>

<p>Definition at line <a class="el" href="hexdump_8cpp_source.html#l00095">95</a> of file <a class="el" href="hexdump_8cpp_source.html">hexdump.cpp</a>.</p>

<p>Referenced by <a class="el" href="hexdump_8cpp_source.html#l00116">tlx::hexdump_lc()</a>, and <a class="el" href="hexdump_8hpp_source.html#l00110">tlx::hexdump_lc_type()</a>.</p>

</div>
</div>
<a class="anchor" id="ga60e8912db4511738cfdbf3e97ff6dbbf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string hexdump_lc </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a (binary) string as a sequence of lowercase hexadecimal pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>binary data to output in hex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hexadecimal pairs </dd></dl>

<p>Definition at line <a class="el" href="hexdump_8cpp_source.html#l00116">116</a> of file <a class="el" href="hexdump_8cpp_source.html">hexdump.cpp</a>.</p>

<p>References <a class="el" href="hexdump_8cpp_source.html#l00095">tlx::hexdump_lc()</a>.</p>

</div>
</div>
<a class="anchor" id="gae749cedcfc25af4f829d70e8febba7a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string hexdump_lc </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a char vector as a sequence of lowercase hexadecimal pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>binary data to output in hex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hexadecimal pairs </dd></dl>

<p>Definition at line <a class="el" href="hexdump_8cpp_source.html#l00120">120</a> of file <a class="el" href="hexdump_8cpp_source.html">hexdump.cpp</a>.</p>

<p>References <a class="el" href="hexdump_8cpp_source.html#l00095">tlx::hexdump_lc()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0b35bd68e5974e78327fce13e0e2eaf6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string hexdump_lc </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a uint8_t vector as a sequence of lowercase hexadecimal pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>binary data to output in hex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hexadecimal pairs </dd></dl>

<p>Definition at line <a class="el" href="hexdump_8cpp_source.html#l00124">124</a> of file <a class="el" href="hexdump_8cpp_source.html">hexdump.cpp</a>.</p>

<p>References <a class="el" href="hexdump_8cpp_source.html#l00095">tlx::hexdump_lc()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0b2f444830d8f7b1b0eaf93b5f514bf7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::hexdump_lc_type </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a (binary) item as a sequence of lowercase hexadecimal pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>binary data to output in hex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hexadecimal pairs </dd></dl>

<p>Definition at line <a class="el" href="hexdump_8hpp_source.html#l00110">110</a> of file <a class="el" href="hexdump_8hpp_source.html">hexdump.hpp</a>.</p>

<p>References <a class="el" href="hexdump_8cpp_source.html#l00095">tlx::hexdump_lc()</a>.</p>

</div>
</div>
<a class="anchor" id="gab10f91fa3b24c787e4e0d88c009ac298"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string hexdump_sourcecode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var_name</em> = <code>&quot;name&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a (binary) string into a C source code snippet. </p>
<p>The snippet defines an array of const uint8_t* holding the data of the string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to output as C source array </td></tr>
    <tr><td class="paramname">var_name</td><td>name of the array variable in the outputted code snippet </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string holding C source snippet </dd></dl>

<p>Definition at line <a class="el" href="hexdump_8cpp_source.html#l00054">54</a> of file <a class="el" href="hexdump_8cpp_source.html">hexdump.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="gae2a485134f5e618b846abb630d44ec6f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string tlx::hexdump_type </td>
          <td>(</td>
          <td class="paramtype">const Type &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump a (binary) item as a sequence of uppercase hexadecimal pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">t</td><td>binary data to output in hex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of hexadecimal pairs </dd></dl>

<p>Definition at line <a class="el" href="hexdump_8hpp_source.html#l00052">52</a> of file <a class="el" href="hexdump_8hpp_source.html">hexdump.hpp</a>.</p>

<p>References <a class="el" href="hexdump_8cpp_source.html#l00021">tlx::hexdump()</a>.</p>

<p>Referenced by <a class="el" href="block__reader_8hpp_source.html#l00089">BlockReader&lt; CatBlockSource &gt;::Next()</a>.</p>

</div>
</div>
<a class="anchor" id="ga15b290439811d07e8fc0a6134c4faa0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t index_of </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to find str in the list and return the index. </p>
<p>Throws a std::runtime_error if it is not found. </p>

<p>Definition at line <a class="el" href="index__of_8cpp_source.html#l00019">19</a> of file <a class="el" href="index__of_8cpp_source.html">index_of.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="gac5156b8029cca4a21cb3e1b14ea6526d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t index_of </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to find str in the list and return the index. </p>
<p>Throws a std::runtime_error if it is not found. </p>

<p>Definition at line <a class="el" href="index__of_8cpp_source.html#l00029">29</a> of file <a class="el" href="index__of_8cpp_source.html">index_of.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga00bece0086ba6a8598e97e93694b713f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t index_of_icase </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to find str in the list and return the index using case-insensitive comparisons. </p>
<p>Throws a std::runtime_error if it is not found. </p>

<p>Definition at line <a class="el" href="index__of_8cpp_source.html#l00039">39</a> of file <a class="el" href="index__of_8cpp_source.html">index_of.cpp</a>.</p>

<p>References <a class="el" href="equal__icase_8cpp_source.html#l00018">tlx::equal_icase()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2d3b5b0636e261f97ab3292d78f2201b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t index_of_icase </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Attempts to find str in the list and return the index using case-insensitive comparisons. </p>
<p>Throws a std::runtime_error if it is not found. </p>

<p>Definition at line <a class="el" href="index__of_8cpp_source.html#l00050">50</a> of file <a class="el" href="index__of_8cpp_source.html">index_of.cpp</a>.</p>

<p>References <a class="el" href="equal__icase_8cpp_source.html#l00018">tlx::equal_icase()</a>.</p>

</div>
</div>
<a class="anchor" id="gad383d32ace209b51abe936d256d0bb1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string join </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>glue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join a vector of strings by some glue character between each pair from the sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">glue</td><td>character for glue </td></tr>
    <tr><td class="paramname">parts</td><td>the vector of strings to join </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string constructed from the vector with the glue between two strings </dd></dl>

<p>Definition at line <a class="el" href="join_8cpp_source.html#l00016">16</a> of file <a class="el" href="join_8cpp_source.html">join.cpp</a>.</p>

<p>Referenced by <a class="el" href="join_8cpp_source.html#l00020">tlx::join()</a>, <a class="el" href="block__pool_8cpp_source.html#l00207">thrill::data::operator&lt;&lt;()</a>, <a class="el" href="page__rank_8hpp_source.html#l00071">examples::page_rank::PageRank()</a>, <a class="el" href="page__rank_8hpp_source.html#l00141">examples::page_rank::PageRankJoin()</a>, <a class="el" href="byte__block_8cpp_source.html#l00060">ByteBlock::pin_count_str()</a>, <a class="el" href="read__binary_8hpp_source.html#l00076">ReadBinaryNode&lt; ValueType &gt;::ReadBinaryNode()</a>, <a class="el" href="read__lines_8hpp_source.html#l00050">ReadLinesNode::ReadLinesNode()</a>, and <a class="el" href="thread__pool_8cpp_source.html#l00024">ThreadPool::~ThreadPool()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0cb20ee53f25c37880faf1b5e5ac3619"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string join </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>glue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join a vector of strings by some glue string between each pair from the sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">glue</td><td>string to glue </td></tr>
    <tr><td class="paramname">parts</td><td>the vector of strings to join </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string constructed from the vector with the glue between two strings </dd></dl>

<p>Definition at line <a class="el" href="join_8cpp_source.html#l00020">20</a> of file <a class="el" href="join_8cpp_source.html">join.cpp</a>.</p>

<p>References <a class="el" href="join_8cpp_source.html#l00016">tlx::join()</a>.</p>

</div>
</div>
<a class="anchor" id="ga206c170915b483387448714300d311c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string join </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>glue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join a vector of strings by some glue string between each pair from the sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">glue</td><td>string to glue </td></tr>
    <tr><td class="paramname">parts</td><td>the vector of strings to join </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string constructed from the vector with the glue between two strings </dd></dl>

<p>Definition at line <a class="el" href="join_8cpp_source.html#l00024">24</a> of file <a class="el" href="join_8cpp_source.html">join.cpp</a>.</p>

<p>References <a class="el" href="join_8cpp_source.html#l00016">tlx::join()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1af0448079469f224ea8905c34dc1868"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string tlx::join </td>
          <td>(</td>
          <td class="paramtype">Glue&#160;</td>
          <td class="paramname"><em>glue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Join a sequence of strings by some glue string between each pair from the sequence. </p>
<p>The sequence in given as a range between two iterators.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">glue</td><td>string to glue </td></tr>
    <tr><td class="paramname">first</td><td>the beginning iterator of the range to join </td></tr>
    <tr><td class="paramname">last</td><td>the ending iterator of the range to join </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string constructed from the range with the glue between two strings. </dd></dl>

<p>Definition at line <a class="el" href="join__generic_8hpp_source.html#l00033">33</a> of file <a class="el" href="join__generic_8hpp_source.html">join_generic.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga4a96227b0edd6c65800124ba1dac82cf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string tlx::join </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>glue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Join a Container of strings by some glue character between each pair from the sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">glue</td><td>character for glue </td></tr>
    <tr><td class="paramname">parts</td><td>the vector of strings to join </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string constructed from the vector with the glue between two strings </dd></dl>

<p>Definition at line <a class="el" href="join__generic_8hpp_source.html#l00060">60</a> of file <a class="el" href="join__generic_8hpp_source.html">join_generic.hpp</a>.</p>

<p>References <a class="el" href="join_8cpp_source.html#l00016">tlx::join()</a>.</p>

</div>
</div>
<a class="anchor" id="gaffea57c0c1e61aa8c9bc50e1ec2f9fe2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string tlx::join </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>glue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Join a Container of strings by some glue string between each pair from the sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">glue</td><td>string to glue </td></tr>
    <tr><td class="paramname">parts</td><td>the vector of strings to join </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string constructed from the vector with the glue between two strings </dd></dl>

<p>Definition at line <a class="el" href="join__generic_8hpp_source.html#l00074">74</a> of file <a class="el" href="join__generic_8hpp_source.html">join_generic.hpp</a>.</p>

<p>References <a class="el" href="join_8cpp_source.html#l00016">tlx::join()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2e35ca12bd4564ba470e3bf4f6a91798"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string tlx::join </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>glue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Join a Container of strings by some glue string between each pair from the sequence. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">glue</td><td>string to glue </td></tr>
    <tr><td class="paramname">parts</td><td>the vector of strings to join </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string constructed from the vector with the glue between two strings </dd></dl>

<p>Definition at line <a class="el" href="join__generic_8hpp_source.html#l00088">88</a> of file <a class="el" href="join__generic_8hpp_source.html">join_generic.hpp</a>.</p>

<p>References <a class="el" href="join_8cpp_source.html#l00016">tlx::join()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3a73759be8d7ec5778cb6192bc32c4c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool less_icase </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if a &lt; b without regard for letter case </p>

<p>Definition at line <a class="el" href="less__icase_8cpp_source.html#l00018">18</a> of file <a class="el" href="less__icase_8cpp_source.html">less_icase.cpp</a>.</p>

<p>References <a class="el" href="to__lower_8cpp_source.html#l00017">tlx::to_lower()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0e53bb43043cc4fdf6fef5a9f017957c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool less_icase </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if a &lt; b without regard for letter case </p>

<p>Definition at line <a class="el" href="less__icase_8cpp_source.html#l00033">33</a> of file <a class="el" href="less__icase_8cpp_source.html">less_icase.cpp</a>.</p>

<p>References <a class="el" href="to__lower_8cpp_source.html#l00017">tlx::to_lower()</a>.</p>

</div>
</div>
<a class="anchor" id="ga25e2629353a36fb47c587b4eef89c0d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool less_icase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if a &lt; b without regard for letter case </p>

<p>Definition at line <a class="el" href="less__icase_8cpp_source.html#l00049">49</a> of file <a class="el" href="less__icase_8cpp_source.html">less_icase.cpp</a>.</p>

<p>References <a class="el" href="to__lower_8cpp_source.html#l00017">tlx::to_lower()</a>.</p>

</div>
</div>
<a class="anchor" id="ga9fb49f152c6bf0d96ec46bfb90a38bfc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool less_icase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if a &lt; b without regard for letter case </p>

<p>Definition at line <a class="el" href="less__icase_8cpp_source.html#l00065">65</a> of file <a class="el" href="less__icase_8cpp_source.html">less_icase.cpp</a>.</p>

<p>References <a class="el" href="to__lower_8cpp_source.html#l00017">tlx::to_lower()</a>.</p>

</div>
</div>
<a class="anchor" id="ga03240bad0b02669f254c21c28009c21a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string pad </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>pad_char</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Truncate or pad string to exactly len characters. </p>

<p>Definition at line <a class="el" href="pad_8cpp_source.html#l00015">15</a> of file <a class="el" href="pad_8cpp_source.html">pad.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga81809bc5e0b69034f39659303baa4bf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string parse_hexdump </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a string as a sequence of hexadecimal pairs. </p>
<p>Converts each pair of hexadecimal digits into a byte of the output string. Throws std::runtime_error() if an unknown letter is encountered.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to parse as hex digits </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string of read bytes </dd></dl>

<p>Definition at line <a class="el" href="hexdump_8cpp_source.html#l00131">131</a> of file <a class="el" href="hexdump_8cpp_source.html">hexdump.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga58be0557b1b38913b28d947c935aed42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parse_si_iec_units </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>out_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>default_unit</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a string like "343KB" or "44 GiB" into the corresponding size in bytes. </p>
<p>Returns the number of bytes and sets ok = true if the string could be parsed correctly. If no units indicator is given, use def_unit in k/m/g/t/p (powers of ten) or in K/M/G/T/P (power of two). </p>

<p>Definition at line <a class="el" href="parse__si__iec__units_8cpp_source.html#l00017">17</a> of file <a class="el" href="parse__si__iec__units_8cpp_source.html">parse_si_iec_units.cpp</a>.</p>

<p>Referenced by <a class="el" href="terasort_8cpp_source.html#l00119">main()</a>, <a class="el" href="config__file_8cpp_source.html#l00255">DiskConfig::parse_line()</a>, <a class="el" href="parse__si__iec__units_8cpp_source.html#l00088">tlx::parse_si_iec_units()</a>, and <a class="el" href="context_8cpp_source.html#l00873">MemoryConfig::setup_detect()</a>.</p>

</div>
</div>
<a class="anchor" id="ga42a656ed3586b515140cb71b312f0f9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool parse_si_iec_units </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>out_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>default_unit</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a string like "343KB" or "44 GiB" into the corresponding size in bytes. </p>
<p>Returns the number of bytes and sets ok = true if the string could be parsed correctly. If no units indicator is given, use def_unit in k/m/g/t/p (powers of ten) or in K/M/G/T/P (power of two). </p>

<p>Definition at line <a class="el" href="parse__si__iec__units_8cpp_source.html#l00088">88</a> of file <a class="el" href="parse__si__iec__units_8cpp_source.html">parse_si_iec_units.cpp</a>.</p>

<p>References <a class="el" href="parse__si__iec__units_8cpp_source.html#l00017">tlx::parse_si_iec_units()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7021d36930f4bd434b2082dce8bd43cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; replace_all </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of needle in str. </p>
<p>Each needle will be replaced with instead, if found. The replacement is done in the given string and a reference to the same is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to str </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00141">141</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

<p>Referenced by <a class="el" href="porting_8cpp_source.html#l00067">thrill::common::LogCmdlineParams()</a>.</p>

</div>
</div>
<a class="anchor" id="gadd5bd9f9a887fa20b4a8ebaf987fd5de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; replace_all </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of needle in str. </p>
<p>Each needle will be replaced with instead, if found. The replacement is done in the given string and a reference to the same is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to str </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00154">154</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga6b4b8117690af529b7051a3c10c382ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; replace_all </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of needle in str. </p>
<p>Each needle will be replaced with instead, if found. The replacement is done in the given string and a reference to the same is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to str </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00168">168</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga0d7d14badd05473e5a5c847b3f91b9e9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; replace_all </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of needle in str. </p>
<p>Each needle will be replaced with instead, if found. The replacement is done in the given string and a reference to the same is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to str </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00182">182</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga768d59e5cc6d2c91f25a441ab4d265a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; replace_all </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of needle in str. </p>
<p>Each needle will be replaced with instead, if found. The replacement is done in the given string and a reference to the same is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>character to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to str </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00197">197</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="gac001aff0fa6c3bee2e9755e3ddd516f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string replace_all </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of needle in str. </p>
<p>Each needle will be replaced with instead, if found. Returns a copy of the string with possible replacements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with replacements </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00212">212</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="gadfe9c066393585d1a769cbd55e9f9960"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string replace_all </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of needle in str. </p>
<p>Each needle will be replaced with instead, if found. Returns a copy of the string with possible replacements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with replacements </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00227">227</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga4e3b406ea495a236fff401c3585d8814"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string replace_all </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of needle in str. </p>
<p>Each needle will be replaced with instead, if found. Returns a copy of the string with possible replacements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with replacements </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00242">242</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga14cfa75fa579e1d4943855455d9e605d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string replace_all </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of needle in str. </p>
<p>Each needle will be replaced with instead, if found. Returns a copy of the string with possible replacements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with replacements </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00257">257</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="gae87b40ae8e461c110fffcb7a12b066d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string replace_all </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace all occurrences of needle in str. </p>
<p>Each needle will be replaced with instead, if found. Returns a copy of the string with possible replacements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>character to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with replacements </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00273">273</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaca0aeb9a74105ec849e939229d47970b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; replace_first </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace only the first occurrence of needle in str. </p>
<p>The needle will be replaced with instead, if found. The replacement is done in the given string and a reference to the same is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to str </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00021">21</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga32d2a706e20d6e5b07cbb677c340deba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; replace_first </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace only the first occurrence of needle in str. </p>
<p>The needle will be replaced with instead, if found. The replacement is done in the given string and a reference to the same is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to str </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00032">32</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="gab2b83d93d49145437aec2964f30e4cd1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; replace_first </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace only the first occurrence of needle in str. </p>
<p>The needle will be replaced with instead, if found. The replacement is done in the given string and a reference to the same is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to str </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00043">43</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga6ed49bc3eebffeefeff05f84ffbcc086"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; replace_first </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace only the first occurrence of needle in str. </p>
<p>The needle will be replaced with instead, if found. The replacement is done in the given string and a reference to the same is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to str </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00054">54</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga4865798a465a43845804dda0fe21f888"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; replace_first </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace only the first occurrence of needle in str. </p>
<p>The needle will be replaced with instead, if found. The replacement is done in the given string and a reference to the same is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>character to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to str </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00065">65</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga8b0092a333e84d0c4eaae50955bc5a71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string replace_first </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace only the first occurrence of needle in str. </p>
<p>The needle will be replaced with instead, if found. Returns a copy of the string with the possible replacement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with replacement </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00078">78</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="gab6b1e9aa3d513c96cd5973e50551d6b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string replace_first </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace only the first occurrence of needle in str. </p>
<p>The needle will be replaced with instead, if found. Returns a copy of the string with the possible replacement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with replacement </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00091">91</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="gae7e6db7b1dfe54efc4b195f27df5ed71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string replace_first </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace only the first occurrence of needle in str. </p>
<p>The needle will be replaced with instead, if found. Returns a copy of the string with the possible replacement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with replacement </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00103">103</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga711f2f36ac6d9cb35a6a63672e47a47c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string replace_first </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace only the first occurrence of needle in str. </p>
<p>The needle will be replaced with instead, if found. Returns a copy of the string with the possible replacement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>string to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with replacement </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00115">115</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga276e1110c0ea48a01ef5a84f8ff40f37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string replace_first </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>needle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>instead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace only the first occurrence of needle in str. </p>
<p>The needle will be replaced with instead, if found. Returns a copy of the string with the possible replacement.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>the string to process </td></tr>
    <tr><td class="paramname">needle</td><td>character to search for in str </td></tr>
    <tr><td class="paramname">instead</td><td>replace needle with instead </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>copy of string possibly with replacement </dd></dl>

<p>Definition at line <a class="el" href="replace_8cpp_source.html#l00127">127</a> of file <a class="el" href="replace_8cpp_source.html">replace.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga4fb56b145f00428be03f74257c61f1cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; split </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em> = <code>std::string::npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given string at each separator character into distinct substrings. </p>
<p>Multiple consecutive separators are considered individually and will result in empty split substrings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sep</td><td>separator character </td></tr>
    <tr><td class="paramname">str</td><td>string to split </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of parts returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing each split substring </dd></dl>

<p>Definition at line <a class="el" href="split_8cpp_source.html#l00020">20</a> of file <a class="el" href="split_8cpp_source.html">split.cpp</a>.</p>

<p>Referenced by <a class="el" href="tpch__run_8cpp_source.html#l00167">JoinTPCH4()</a>, <a class="el" href="config__file_8cpp_source.html#l00317">DiskConfig::parse_fileio()</a>, <a class="el" href="config__file_8cpp_source.html#l00255">DiskConfig::parse_line()</a>, <a class="el" href="percentiles_8cpp_source.html#l00031">Percentiles()</a>, and <a class="el" href="split_8cpp_source.html#l00028">tlx::split()</a>.</p>

</div>
</div>
<a class="anchor" id="gad838882b8fc992742b09450925758b32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; split </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em> = <code>std::string::npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given string at each separator string into distinct substrings. </p>
<p>Multiple consecutive separators are considered individually and will result in empty split substrings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sep</td><td>separator string </td></tr>
    <tr><td class="paramname">str</td><td>string to split </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of parts returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing each split substring </dd></dl>

<p>Definition at line <a class="el" href="split_8cpp_source.html#l00028">28</a> of file <a class="el" href="split_8cpp_source.html">split.cpp</a>.</p>

<p>References <a class="el" href="split_8cpp_source.html#l00020">tlx::split()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0d57e8e6ac19e94787bf3cd44a79c1fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em> = <code>std::string::npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given string at each separator string into distinct substrings. </p>
<p>Multiple consecutive separators are considered individually and will result in empty split substrings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sep</td><td>separator string </td></tr>
    <tr><td class="paramname">str</td><td>string to split </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of parts returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing each split substring </dd></dl>

<p>Definition at line <a class="el" href="split_8cpp_source.html#l00036">36</a> of file <a class="el" href="split_8cpp_source.html">split.cpp</a>.</p>

<p>References <a class="el" href="split_8cpp_source.html#l00020">tlx::split()</a>.</p>

</div>
</div>
<a class="anchor" id="ga00c921a6a793d9c4e59e380b2bb32fca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; split </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>min_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given string at each separator character into distinct substrings. </p>
<p>Multiple consecutive separators are considered individually and will result in empty split substrings. Returns a vector of strings with at least min_fields and at most limit_fields, empty fields are added if needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sep</td><td>separator string </td></tr>
    <tr><td class="paramname">str</td><td>string to split </td></tr>
    <tr><td class="paramname">min_fields</td><td>minimum number of parts returned </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of parts returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing each split substring </dd></dl>

<p>Definition at line <a class="el" href="split_8cpp_source.html#l00047">47</a> of file <a class="el" href="split_8cpp_source.html">split.cpp</a>.</p>

<p>References <a class="el" href="split_8cpp_source.html#l00020">tlx::split()</a>.</p>

</div>
</div>
<a class="anchor" id="gac5fb737c26e5fa4d63467b0ded2a1b90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; split </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>min_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given string at each separator string into distinct substrings. </p>
<p>Multiple consecutive separators are considered individually and will result in empty split substrings. Returns a vector of strings with at least min_fields and at most limit_fields, empty fields are added if needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sep</td><td>separator string </td></tr>
    <tr><td class="paramname">str</td><td>string to split </td></tr>
    <tr><td class="paramname">min_fields</td><td>minimum number of parts returned </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of parts returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing each split substring </dd></dl>

<p>Definition at line <a class="el" href="split_8cpp_source.html#l00056">56</a> of file <a class="el" href="split_8cpp_source.html">split.cpp</a>.</p>

<p>References <a class="el" href="split_8cpp_source.html#l00020">tlx::split()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7a0a5d581ecd362eaae43bdee50b3896"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; split </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>min_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given string at each separator string into distinct substrings. </p>
<p>Multiple consecutive separators are considered individually and will result in empty split substrings. Returns a vector of strings with at least min_fields and at most limit_fields, empty fields are added if needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sep</td><td>separator string </td></tr>
    <tr><td class="paramname">str</td><td>string to split </td></tr>
    <tr><td class="paramname">min_fields</td><td>minimum number of parts returned </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of parts returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing each split substring </dd></dl>

<p>Definition at line <a class="el" href="split_8cpp_source.html#l00065">65</a> of file <a class="el" href="split_8cpp_source.html">split.cpp</a>.</p>

<p>References <a class="el" href="split_8cpp_source.html#l00020">tlx::split()</a>.</p>

</div>
</div>
<a class="anchor" id="ga17fd4a3698ca54702b30dddc232bf903"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; &amp; split </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; *&#160;</td>
          <td class="paramname"><em>into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em> = <code>std::string::npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given string at each separator character into distinct substrings. </p>
<p>Multiple consecutive separators are considered individually and will result in empty split substrings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">into</td><td>destination std::vector </td></tr>
    <tr><td class="paramname">sep</td><td>separator character </td></tr>
    <tr><td class="paramname">str</td><td>string to split </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of parts returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing each split substring </dd></dl>

<p>Definition at line <a class="el" href="split_8cpp_source.html#l00077">77</a> of file <a class="el" href="split_8cpp_source.html">split.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga177a8fd78d5cc4e0fd8dc50810967d89"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; &amp; split </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; *&#160;</td>
          <td class="paramname"><em>into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em> = <code>std::string::npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given string at each separator string into distinct substrings. </p>
<p>Multiple consecutive separators are considered individually and will result in empty split substrings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">into</td><td>destination std::vector </td></tr>
    <tr><td class="paramname">sep</td><td>separator string </td></tr>
    <tr><td class="paramname">str</td><td>string to split </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of parts returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing each split substring </dd></dl>

<p>Definition at line <a class="el" href="split_8cpp_source.html#l00147">147</a> of file <a class="el" href="split_8cpp_source.html">split.cpp</a>.</p>

<p>References <a class="el" href="split_8cpp_source.html#l00020">tlx::split()</a>.</p>

</div>
</div>
<a class="anchor" id="ga431c048d40a30f531e2e419e26582e4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; &amp; split </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; *&#160;</td>
          <td class="paramname"><em>into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em> = <code>std::string::npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given string at each separator string into distinct substrings. </p>
<p>Multiple consecutive separators are considered individually and will result in empty split substrings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">into</td><td>destination std::vector </td></tr>
    <tr><td class="paramname">sep</td><td>separator string </td></tr>
    <tr><td class="paramname">str</td><td>string to split </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of parts returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing each split substring </dd></dl>

<p>Definition at line <a class="el" href="split_8cpp_source.html#l00155">155</a> of file <a class="el" href="split_8cpp_source.html">split.cpp</a>.</p>

<p>References <a class="el" href="split_8cpp_source.html#l00020">tlx::split()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4997fcbeb1c6a97d23bce8ea590b3ce3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; &amp; split </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; *&#160;</td>
          <td class="paramname"><em>into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>min_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given string at each separator character into distinct substrings. </p>
<p>Multiple consecutive separators are considered individually and will result in empty split substrings. Returns a vector of strings with at least min_fields and at most limit_fields, empty fields are added if needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">into</td><td>destination std::vector </td></tr>
    <tr><td class="paramname">sep</td><td>separator character </td></tr>
    <tr><td class="paramname">str</td><td>string to split </td></tr>
    <tr><td class="paramname">min_fields</td><td>minimum number of parts returned </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of parts returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing each split substring </dd></dl>

<p>Definition at line <a class="el" href="split_8cpp_source.html#l00166">166</a> of file <a class="el" href="split_8cpp_source.html">split.cpp</a>.</p>

<p>References <a class="el" href="split_8cpp_source.html#l00020">tlx::split()</a>.</p>

</div>
</div>
<a class="anchor" id="ga40222e4ae7f552a3d6f8d485ced3d91d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; &amp; split </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; *&#160;</td>
          <td class="paramname"><em>into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>min_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given string at each separator string into distinct substrings. </p>
<p>Multiple consecutive separators are considered individually and will result in empty split substrings. Returns a vector of strings with at least min_fields and at most limit_fields, empty fields are added if needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">into</td><td>destination std::vector </td></tr>
    <tr><td class="paramname">sep</td><td>separator string </td></tr>
    <tr><td class="paramname">str</td><td>string to split </td></tr>
    <tr><td class="paramname">min_fields</td><td>minimum number of parts returned </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of parts returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing each split substring </dd></dl>

<p>Definition at line <a class="el" href="split_8cpp_source.html#l00179">179</a> of file <a class="el" href="split_8cpp_source.html">split.cpp</a>.</p>

<p>References <a class="el" href="split_8cpp_source.html#l00020">tlx::split()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4aa7e0fb9bd81e31214087d3d85367a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; &amp; split </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; *&#160;</td>
          <td class="paramname"><em>into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>min_fields</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given string at each separator string into distinct substrings. </p>
<p>Multiple consecutive separators are considered individually and will result in empty split substrings. Returns a vector of strings with at least min_fields and at most limit_fields, empty fields are added if needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">into</td><td>destination std::vector </td></tr>
    <tr><td class="paramname">sep</td><td>separator string </td></tr>
    <tr><td class="paramname">str</td><td>string to split </td></tr>
    <tr><td class="paramname">min_fields</td><td>minimum number of parts returned </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of parts returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing each split substring </dd></dl>

<p>Definition at line <a class="el" href="split_8cpp_source.html#l00192">192</a> of file <a class="el" href="split_8cpp_source.html">split.cpp</a>.</p>

<p>References <a class="el" href="split_8cpp_source.html#l00020">tlx::split()</a>.</p>

</div>
</div>
<a class="anchor" id="ga92d58b1e8b06cbb57400b5959281a4a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; split_words </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string::size_type&#160;</td>
          <td class="paramname"><em>limit</em> = <code>std::string::npos</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split the given string by whitespaces into distinct words. </p>
<p>Multiple consecutive whitespaces are considered as one split point. Whitespaces are space, tab, newline and carriage-return.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to split </td></tr>
    <tr><td class="paramname">limit</td><td>maximum number of parts returned </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector containing each split substring </dd></dl>

<p>Definition at line <a class="el" href="split__words_8cpp_source.html#l00015">15</a> of file <a class="el" href="split__words_8cpp_source.html">split_words.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="gadc5cce7e8c7fd30078b9129a7ae1d74b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool starts_with </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given match string is located at the start of this string. </p>

<p>Definition at line <a class="el" href="starts__with_8cpp_source.html#l00019">19</a> of file <a class="el" href="starts__with_8cpp_source.html">starts_with.cpp</a>.</p>

<p>Referenced by <a class="el" href="file__io_8cpp_source.html#l00127">thrill::vfs::Glob()</a>, <a class="el" href="file__io_8cpp_source.html#l00054">thrill::vfs::IsRemoteUri()</a>, <a class="el" href="file__io_8cpp_source.html#l00179">thrill::vfs::OpenReadStream()</a>, and <a class="el" href="file__io_8cpp_source.html#l00210">thrill::vfs::OpenWriteStream()</a>.</p>

</div>
</div>
<a class="anchor" id="ga125efbe989d08402389613766af825b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool starts_with </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given match string is located at the start of this string. </p>

<p>Definition at line <a class="el" href="starts__with_8cpp_source.html#l00026">26</a> of file <a class="el" href="starts__with_8cpp_source.html">starts_with.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="gadbcdc1f2a056e954b197ce9c1d236522"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool starts_with_icase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given match string is located at the start of this string. </p>
<p>Compares the characters case-insensitively. </p>

<p>Definition at line <a class="el" href="starts__with_8cpp_source.html#l00039">39</a> of file <a class="el" href="starts__with_8cpp_source.html">starts_with.cpp</a>.</p>

<p>References <a class="el" href="to__lower_8cpp_source.html#l00017">tlx::to_lower()</a>.</p>

</div>
</div>
<a class="anchor" id="gab6d169441d65d96bceb7c936e88afc67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool starts_with_icase </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the given match string is located at the start of this string. </p>
<p>Compares the characters case-insensitively. </p>

<p>Definition at line <a class="el" href="starts__with_8cpp_source.html#l00049">49</a> of file <a class="el" href="starts__with_8cpp_source.html">starts_with.cpp</a>.</p>

<p>References <a class="el" href="to__lower_8cpp_source.html#l00017">tlx::to_lower()</a>.</p>

</div>
</div>
<a class="anchor" id="ga355a332620f8220ecbb0dc5a0aa67350"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char to_lower </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform the given character to lower case without any localization. </p>

<p>Definition at line <a class="el" href="to__lower_8cpp_source.html#l00017">17</a> of file <a class="el" href="to__lower_8cpp_source.html">to_lower.cpp</a>.</p>

<p>Referenced by <a class="el" href="compare__icase_8cpp_source.html#l00018">tlx::compare_icase()</a>, <a class="el" href="ends__with_8cpp_source.html#l00044">tlx::ends_with_icase()</a>, <a class="el" href="equal__icase_8cpp_source.html#l00018">tlx::equal_icase()</a>, <a class="el" href="less__icase_8cpp_source.html#l00018">tlx::less_icase()</a>, <a class="el" href="starts__with_8cpp_source.html#l00039">tlx::starts_with_icase()</a>, and <a class="el" href="to__lower_8cpp_source.html#l00023">tlx::to_lower()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4ec240b74b77e3ce42f8d67079dea430"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; to_lower </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms the given string to lowercase and returns a reference to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p>Definition at line <a class="el" href="to__lower_8cpp_source.html#l00023">23</a> of file <a class="el" href="to__lower_8cpp_source.html">to_lower.cpp</a>.</p>

<p>References <a class="el" href="to__lower_8cpp_source.html#l00017">tlx::to_lower()</a>.</p>

</div>
</div>
<a class="anchor" id="ga647f5157d00473cf9bf37c92044bd9a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string to_lower </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a copy of the given string converted to lowercase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new string lowercased </dd></dl>

<p>Definition at line <a class="el" href="to__lower_8cpp_source.html#l00029">29</a> of file <a class="el" href="to__lower_8cpp_source.html">to_lower.cpp</a>.</p>

<p>References <a class="el" href="to__lower_8cpp_source.html#l00017">tlx::to_lower()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa00b5d705507da8f74f1ba3874174d8d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char to_upper </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform the given character to upper case without any localization. </p>

<p>Definition at line <a class="el" href="to__upper_8cpp_source.html#l00017">17</a> of file <a class="el" href="to__upper_8cpp_source.html">to_upper.cpp</a>.</p>

<p>Referenced by <a class="el" href="to__upper_8cpp_source.html#l00023">tlx::to_upper()</a>.</p>

</div>
</div>
<a class="anchor" id="ga7d9edcc3303203825126d7d422e8ab75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; to_upper </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transforms the given string to uppercase and returns a reference to it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p>Definition at line <a class="el" href="to__upper_8cpp_source.html#l00023">23</a> of file <a class="el" href="to__upper_8cpp_source.html">to_upper.cpp</a>.</p>

<p>References <a class="el" href="to__upper_8cpp_source.html#l00017">tlx::to_upper()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2be559f6e498862bec070f122feb6e14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string to_upper </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a copy of the given string converted to uppercase. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new string uppercased </dd></dl>

<p>Definition at line <a class="el" href="to__upper_8cpp_source.html#l00029">29</a> of file <a class="el" href="to__upper_8cpp_source.html">to_upper.cpp</a>.</p>

<p>References <a class="el" href="to__upper_8cpp_source.html#l00017">tlx::to_upper()</a>.</p>

</div>
</div>
<a class="anchor" id="gaef21c8a44ad85b60cee80e66ae877b9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; trim </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>drop</em> = <code>&quot;&#160;\r\n\t&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string in-place on the left and right. </p>
<p>Removes all characters in the given drop array, which defaults to " ".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p>Definition at line <a class="el" href="trim_8cpp_source.html#l00020">20</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga9f5067eb83515704232300be374b2857"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; trim </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string in-place on the left and right. </p>
<p>Removes all characters in the given drop array, which defaults to " ".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p>Definition at line <a class="el" href="trim_8cpp_source.html#l00033">33</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="gac6b44c87fe78e1d7479b7a4fff91cc2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string trim </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>drop</em> = <code>&quot;&#160;\r\n\t&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string in-place on the left and right. </p>
<p>Removes all characters in the given drop array, which defaults to " ".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p>Definition at line <a class="el" href="trim_8cpp_source.html#l00046">46</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga7aacbd967bfb76fcb4b4d977b4f5d838"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string trim </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string in-place on the left and right. </p>
<p>Removes all characters in the given drop array, which defaults to " ".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p>Definition at line <a class="el" href="trim_8cpp_source.html#l00062">62</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga9990f13215dc89af47b26ed8f2d26c9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; trim_left </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>drop</em> = <code>&quot;&#160;\r\n\t&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string in-place only on the left. </p>
<p>Removes all characters in the given drop array, which defaults to " ".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p>Definition at line <a class="el" href="trim_8cpp_source.html#l00112">112</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga9db0b1db4ab3774221363c2fafa8bbdf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; trim_left </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string in-place only on the left. </p>
<p>Removes all characters in the given drop array, which defaults to " ".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p>Definition at line <a class="el" href="trim_8cpp_source.html#l00117">117</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="gafaed624d011733264819eb39daae7d64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string trim_left </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>drop</em> = <code>&quot;&#160;\r\n\t&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string only on the left. </p>
<p>Removes all characters in the given drop array, which defaults to " ". Returns a copy of the string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new trimmed string </dd></dl>

<p>Definition at line <a class="el" href="trim_8cpp_source.html#l00122">122</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga9f870dbf0b1602d063de42caefde8b68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string trim_left </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string only on the left. </p>
<p>Removes all characters in the given drop array, which defaults to " ". Returns a copy of the string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new trimmed string </dd></dl>

<p>Definition at line <a class="el" href="trim_8cpp_source.html#l00129">129</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="gae59121dc9b7582edd903016d412bdb4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; trim_right </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>drop</em> = <code>&quot;&#160;\r\n\t&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string in-place only on the right. </p>
<p>Removes all characters in the given drop array, which defaults to " ".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p>Definition at line <a class="el" href="trim_8cpp_source.html#l00086">86</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="gaff5e9a8a1501b420ae5a5f8eca2a2f01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string &amp; trim_right </td>
          <td>(</td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string in-place only on the right. </p>
<p>Removes all characters in the given drop array, which defaults to " ".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>reference to the modified string </dd></dl>

<p>Definition at line <a class="el" href="trim_8cpp_source.html#l00091">91</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga75e734df783f6b4f70f75a8031d930aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string trim_right </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>drop</em> = <code>&quot;&#160;\r\n\t&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string only on the right. </p>
<p>Removes all characters in the given drop array, which defaults to " ". Returns a copy of the string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new trimmed string </dd></dl>

<p>Definition at line <a class="el" href="trim_8cpp_source.html#l00096">96</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga4b761b3a20c3f400f4f3451511016a07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string trim_right </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Trims the given string only on the right. </p>
<p>Removes all characters in the given drop array, which defaults to " ". Returns a copy of the string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string to process </td></tr>
    <tr><td class="paramname">drop</td><td>remove these characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>new trimmed string </dd></dl>

<p>Definition at line <a class="el" href="trim_8cpp_source.html#l00103">103</a> of file <a class="el" href="trim_8cpp_source.html">trim.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga39619db78c7e916bff3544fb07cbe462"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string union_words </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>wordsA</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>wordsB</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return union of two keyword sets. </p>

<p>Definition at line <a class="el" href="union__words_8cpp_source.html#l00016">16</a> of file <a class="el" href="union__words_8cpp_source.html">union_words.cpp</a>.</p>

<p>References <a class="el" href="contains__word_8cpp_source.html#l00019">tlx::contains_word()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2d0ada76ddce7fc09d770fa512780839"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string word_wrap </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>wrap</em> = <code>80</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to wrap a string to 80 columns without split words. </p>
<p>All newlines are kept, new newline characters are inserted only at spaces, hence, words are never split. If words longer than 80 columns occur they are NOT broken. </p>

<p>Definition at line <a class="el" href="word__wrap_8cpp_source.html#l00022">22</a> of file <a class="el" href="word__wrap_8cpp_source.html">word_wrap.cpp</a>.</p>

<p>References <a class="el" href="word__wrap_8cpp_source.html#l00017">tlx::is_space()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Tue Oct 10 2017 17:56:53 for Thrill by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
